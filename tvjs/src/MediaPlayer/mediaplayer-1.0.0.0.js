/* Base.js */

/*
#      The MIT License (MIT)
#
#      Copyright (c) 2016 Microsoft. All rights reserved.
#
#      Permission is hereby granted, free of charge, to any person obtaining a copy
#      of this software and associated documentation files (the "Software"), to deal
#      in the Software without restriction, including without limitation the rights
#      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#      copies of the Software, and to permit persons to whom the Software is
#      furnished to do so, subject to the following conditions:
#
#      The above copyright notice and this permission notice shall be included in
#      all copies or substantial portions of the Software.
#
#      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#      THE SOFTWARE.
 */
(function () {

    var globalObject = 
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    (function (factory) {
        if (typeof define === 'function' && define.amd) {
            // amd
            define([], factory);
        } else {
            if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
                // CommonJS
                factory();
            } else {
                // No module system
                factory(globalObject.TVJS);
            }
        }
    }(function (TVJS) {

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
/*jshint ignore:start */
var require;
var define;
/*jshint ignore:end */

(function () {
    "use strict";

    var defined = {};
    define = function (id, dependencies, factory) {
        if (!Array.isArray(dependencies)) {
            factory = dependencies;
            dependencies = [];
        }

        var mod = {
            dependencies: normalize(id, dependencies),
            factory: factory
        };

        if (dependencies.indexOf('exports') !== -1) {
            mod.exports = {};
        }

        defined[id] = mod;
    };

    // TVJS/Core depends on ./Core/_Base
    // should return TVJS/Core/_Base
    function normalize(id, dependencies) {
        id = id || "";
        var parent = id.split('/');
        parent.pop();
        return dependencies.map(function (dep) {
            if (dep[0] === '.') {
                var parts = dep.split('/');
                var current = parent.slice(0);
                parts.forEach(function (part) {
                    if (part === '..') {
                        current.pop();
                    } else if (part !== '.') {
                        current.push(part);
                    }
                });
                return current.join('/');
            } else {
                return dep;
            }
        });
    }

    function resolve(dependencies, parent, exports) {
        return dependencies.map(function (depName) {
            if (depName === 'exports') {
                return exports;
            }

            if (depName === 'require') {
                return function (dependencies, factory) {
                    require(normalize(parent, dependencies), factory);
                };
            }

            var dep = defined[depName];
            if (!dep) {
                throw new Error("Undefined dependency: " + depName);
            }

            if (!dep.resolved) {
                dep.resolved = load(dep.dependencies, dep.factory, depName, dep.exports);
                if (typeof dep.resolved === "undefined") {
                    dep.resolved = dep.exports;
                }
            }

            return dep.resolved;
        });
    }

    function load(dependencies, factory, parent, exports) {
        var deps = resolve(dependencies, parent, exports);
        if (factory && factory.apply) {
            return factory.apply(null, deps);
        } else {
            return factory;
        }
    }
    require = function (dependencies, factory) { //jshint ignore:line
        if (!Array.isArray(dependencies)) {
            dependencies = [dependencies];
        }
        load(dependencies, factory);
    };


})();
define("amd", function(){});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_TVJS',{});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_Global',[], function () {
    "use strict";
    
    // Appease jshint
    /* global window, self, global */
    
    var globalObject =
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    return globalObject;
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_BaseCoreUtils',[
    './_Global'
    ], function baseCoreUtilsInit(_Global) {
    "use strict";

    var hasWinRT = !!_Global.Windows;

    function markSupportedForProcessing(func) {
        /// <signature helpKeyword="TVJS.Utilities.markSupportedForProcessing">
        /// <summary locid="TVJS.Utilities.markSupportedForProcessing">
        /// Marks a function as being compatible with declarative processing, such as TVJS.UI.processAll
        /// or TVJS.Binding.processAll.
        /// </summary>
        /// <param name="func" type="Function" locid="TVJS.Utilities.markSupportedForProcessing_p:func">
        /// The function to be marked as compatible with declarative processing.
        /// </param>
        /// <returns type="Function" locid="TVJS.Utilities.markSupportedForProcessing_returnValue">
        /// The input function.
        /// </returns>
        /// </signature>
        func.supportedForProcessing = true;
        return func;
    }

    return {
        hasWinRT: hasWinRT,
        markSupportedForProcessing: markSupportedForProcessing,
        _setImmediate: _Global.setImmediate ? _Global.setImmediate.bind(_Global) : function (handler) {
            _Global.setTimeout(handler, 0);
        }
    };
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_Base',[
    './_TVJS',
    './_Global',
    './_BaseCoreUtils'
    ], function baseInit(_TVJS, _Global, _BaseCoreUtils) {
    "use strict";

    function initializeProperties(target, members, prefix) {
        var keys = Object.keys(members);
        var isArray = Array.isArray(target);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    if (prefix && member.setName && typeof member.setName === 'function') {
                        member.setName(prefix + "." + key);
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };
                continue;
            }
            if (isArray) {
                target.forEach(function (target) {
                    target[key] = member;
                });
            } else {
                target[key] = member;
            }
        }
        if (properties) {
            if (isArray) {
                target.forEach(function (target) {
                    Object.defineProperties(target, properties);
                });
            } else {
                Object.defineProperties(target, properties);
            }
        }
    }

    (function () {

        var _rootNamespace = _TVJS;
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function createNamespace(parentNamespace, name) {
            var currentNamespace = parentNamespace || {};
            if (name) {
                var namespaceFragments = name.split(".");
                if (currentNamespace === _Global && namespaceFragments[0] === "TVJS") {
                    currentNamespace = _TVJS;
                    namespaceFragments.splice(0, 1);
                }
                for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                    var namespaceName = namespaceFragments[i];
                    if (!currentNamespace[namespaceName]) {
                        Object.defineProperty(currentNamespace, namespaceName,
                            { value: {}, writable: false, enumerable: true, configurable: true }
                        );
                    }
                    currentNamespace = currentNamespace[namespaceName];
                }
            }
            return currentNamespace;
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="TVJS.Namespace.defineWithParent">
            /// <summary locid="TVJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="TVJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="TVJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="TVJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="TVJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = createNamespace(parentNamespace, name);

            if (members) {
                initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="TVJS.Namespace.define">
            /// <summary locid="TVJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="TVJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="TVJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="TVJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(_Global, name, members);
        }

        var LazyStates = {
            uninitialized: 1,
            working: 2,
            initialized: 3,
        };

        function lazy(f) {
            var name;
            var state = LazyStates.uninitialized;
            var result;
            return {
                setName: function (value) {
                    name = value;
                },
                get: function () {
                    switch (state) {
                        case LazyStates.initialized:
                            return result;

                        case LazyStates.uninitialized:
                            state = LazyStates.working;
                            try {
                                result = f();
                            } finally {
                                state = LazyStates.uninitialized;
                            }
                            f = null;
                            state = LazyStates.initialized;
                            return result;

                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            throw "Illegal";
                    }
                },
                set: function (value) {
                    switch (state) {
                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            state = LazyStates.initialized;
                            result = value;
                            break;
                    }
                },
                enumerable: true,
                configurable: true,
            };
        }

        // helper for defining AMD module members
        function moduleDefine(exports, name, members) {
            var target = [exports];
            var publicNS = null;
            if (name) {
                publicNS = createNamespace(_Global, name);
                target.push(publicNS);
            }
            initializeProperties(target, members, name || "<ANONYMOUS>");
            return publicNS;
        }

        // Establish members of the "TVJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true },

            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },

            _moduleDefine: { value: moduleDefine, writable: true, enumerable: true, configurable: true }

        });

    })();

    (function () {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="TVJS.Class.define">
            /// <summary locid="TVJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="TVJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="TVJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="TVJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="TVJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            _BaseCoreUtils.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="TVJS.Class.derive">
            /// <summary locid="TVJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="TVJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="TVJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="TVJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="TVJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="TVJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                _BaseCoreUtils.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="TVJS.Class.mix">
            /// <summary locid="TVJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="TVJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="TVJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "TVJS.Class" namespace
        _TVJS.Namespace.define("TVJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })();

    return {
        Namespace: _TVJS.Namespace,
        Class: _TVJS.Class
    };
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_ErrorFromName',[
    './_Base'
    ], function errorsInit(_Base) {
    "use strict";

    var ErrorFromName = _Base.Class.derive(Error, function (name, message) {
        /// <signature helpKeyword="TVJS.ErrorFromName">
        /// <summary locid="TVJS.ErrorFromName">
        /// Creates an Error object with the specified name and message properties.
        /// </summary>
        /// <param name="name" type="String" locid="TVJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
        /// <param name="message" type="String" optional="true" locid="TVJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
        /// <returns type="Error" locid="TVJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
        /// </signature>
        this.name = name;
        this.message = message || name;
    }, {
        /* empty */
    }, {
        supportedForProcessing: false,
    });

    _Base.Namespace.define("TVJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: ErrorFromName
    });

    return ErrorFromName;

});


// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_WinRT',[
    'exports',
    './_Global',
    './_Base',
], function winrtInit(exports, _Global, _Base) {
    "use strict";

    exports.msGetWeakWinRTProperty = _Global.msGetWeakWinRTProperty;
    exports.msSetWeakWinRTProperty = _Global.msSetWeakWinRTProperty;

    var APIs = [
        "Windows.ApplicationModel.DesignMode.designModeEnabled",
        "Windows.ApplicationModel.Resources.Core.ResourceContext",
        "Windows.ApplicationModel.Resources.Core.ResourceManager",
        "Windows.ApplicationModel.Search.SearchQueryLinguisticDetails",
        "Windows.Data.Text.SemanticTextQuery",
        "Windows.Foundation.Collections.CollectionChange",
        "Windows.Foundation.Diagnostics",
        "Windows.Foundation.Uri",
        "Windows.Globalization.ApplicationLanguages",
        "Windows.Globalization.Calendar",
        "Windows.Globalization.DateTimeFormatting",
        "Windows.Globalization.Language",
        "Windows.Phone.UI.Input.HardwareButtons",
        "Windows.Storage.ApplicationData",
        "Windows.Storage.CreationCollisionOption",
        "Windows.Storage.BulkAccess.FileInformationFactory",
        "Windows.Storage.FileIO",
        "Windows.Storage.FileProperties.ThumbnailType",
        "Windows.Storage.FileProperties.ThumbnailMode",
        "Windows.Storage.FileProperties.ThumbnailOptions",
        "Windows.Storage.KnownFolders",
        "Windows.Storage.Search.FolderDepth",
        "Windows.Storage.Search.IndexerOption",
        "Windows.Storage.Streams.RandomAccessStreamReference",
        "Windows.System.Profile.AnalyticsInfo",
        "Windows.UI.ApplicationSettings.SettingsEdgeLocation",
        "Windows.UI.ApplicationSettings.SettingsCommand",
        "Windows.UI.ApplicationSettings.SettingsPane",
        "Windows.UI.Core.AnimationMetrics",
        "Windows.UI.Core.SystemNavigationManager",
        "Windows.UI.Input.EdgeGesture",
        "Windows.UI.Input.EdgeGestureKind",
        "Windows.UI.Input.GestureRecognizer",
        "Windows.UI.Input.GestureSettings",
        "Windows.UI.Input.PointerPoint",
        "Windows.UI.Popups.Placement",
        "Windows.UI.ViewManagement.ApplicationView",
        "Windows.UI.ViewManagement.ApplicationViewState",
        "Windows.UI.ViewManagement.HandPreference",
        "Windows.UI.ViewManagement.InputPane",
        "Windows.UI.ViewManagement.UIColorType",
        "Windows.UI.ViewManagement.UISettings",
        "Windows.UI.WebUI.Core.WebUICommandBar",
        "Windows.UI.WebUI.Core.WebUICommandBarBitmapIcon",
        "Windows.UI.WebUI.Core.WebUICommandBarClosedDisplayMode",
        "Windows.UI.WebUI.Core.WebUICommandBarIconButton",
        "Windows.UI.WebUI.Core.WebUICommandBarSymbolIcon",
        "Windows.UI.WebUI.WebUIApplication",
        "Windows.Media.ContentRestrictions.RatedContentRestrictions",
        "Windows.Media.MediaPlaybackType",
        "Windows.Media.MediaPlaybackStatus",
        "Windows.Media.Casting",
        "Windows.Media.SystemMediaTransportControls",
        "Windows.Media.SystemMediaTransportControlsButton",
        "Windows.Media.SystemMediaTransportControlsProperty",
        "Windows.Xbox"
    ];

    APIs.forEach(function (api) {
        var parts = api.split(".");
        var leaf = {};
        leaf[parts[parts.length - 1]] = {
            get: function () {
                return parts.reduce(function (current, part) { return current ? current[part] : null; }, _Global);
            }
        };
        _Base.Namespace.defineWithParent(exports, parts.slice(0, -1).join("."), leaf);
    });

});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_Events',[
    'exports',
    './_Base'
    ], function eventsInit(exports, _Base) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        };
    }

    function createEventProperties() {
        /// <signature helpKeyword="TVJS.Utilities.createEventProperties">
        /// <summary locid="TVJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="TVJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="TVJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = _Base.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="TVJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="TVJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="TVJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="TVJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="useCapture" locid="TVJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="TVJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="TVJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="TVJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="TVJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="TVJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="TVJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="TVJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="TVJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="TVJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="TVJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    _Base.Namespace._moduleDefine(exports, "TVJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

});


define('require-json',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});

define('require-json!strings/en-us/Microsoft.TVJS.resjson',{
    "ui/appBarAriaLabel": "App Bar",
    "ui/appBarCommandAriaLabel": "App Bar Item",
    "ui/appBarOverflowButtonAriaLabel": "View more",
    "ui/autoSuggestBoxAriaLabel": "Autosuggestbox",
    "ui/autoSuggestBoxAriaLabelInputNoPlaceHolder": "Autosuggestbox, enter to submit query, esc to clear text",
    "ui/autoSuggestBoxAriaLabelInputPlaceHolder": "Autosuggestbox, {0}, enter to submit query, esc to clear text",
    "ui/autoSuggestBoxAriaLabelQuery": "Suggestion: {0}",
    "_ui/autoSuggestBoxAriaLabelQuery.comment": "Suggestion: query text (example: Suggestion: contoso)",
    "ui/autoSuggestBoxAriaLabelSeparator": "Separator: {0}",
    "_ui/autoSuggestBoxAriaLabelSeparator.comment": "Separator: separator text (example: Separator: People or Separator: Apps)",
    "ui/autoSuggestBoxAriaLabelResult": "Result: {0}, {1}",
    "_ui/autoSuggestBoxAriaLabelResult.comment": "Result: text, detailed text (example: Result: contoso, www.contoso.com)",
    "ui/averageRating": "Average Rating",
    "ui/backbuttonarialabel": "Back",
    "ui/chapterSkipBackMediaCommandDisplayText": "Chapter back",
    "ui/chapterSkipForwardMediaCommandDisplayText": "Chapter forward",
    "ui/clearYourRating": "Clear your rating",
    "ui/closedCaptionsLabelNone": "Off",
    "ui/closedCaptionsMediaCommandDisplayText": "Closed captioning",
    "ui/closeOverlay": "Close",
    "ui/commandingSurfaceAriaLabel": "CommandingSurface",
    "ui/commandingSurfaceOverflowButtonAriaLabel": "View more",
    "ui/datePicker": "Date Picker",
    "ui/fastForwardMediaCommandDisplayText": "Fast forward",
    "ui/fastForwardFeedbackDisplayText": " {0}X",
    "ui/fastForwardFeedbackSlowMotionDisplayText": "0.5X",
    "ui/flipViewPanningContainerAriaLabel": "Scrolling Container",
    "ui/flyoutAriaLabel": "Flyout",
    "ui/goToFullScreenButtonLabel": "Go full screen",
    "ui/goToLiveMediaCommandDisplayText": "LIVE",
    "ui/hubViewportAriaLabel": "Scrolling Container",
    "ui/listViewViewportAriaLabel": "Scrolling Container",
    "ui/mediaErrorAborted": "Playback was interrupted. Please try again.",
    "ui/mediaErrorNetwork": "There was a network connection error.",
    "ui/mediaErrorDecode": "The content could not be decoded",
    "ui/mediaErrorSourceNotSupported": "This content type is not supported.",
    "ui/mediaErrorUnknown": "There was an unknown error.",
    "ui/mediaPlayerAudioTracksButtonLabel": "Audio tracks",
    "ui/mediaPlayerCastButtonLabel": "Cast",
    "ui/mediaPlayerChapterSkipBackButtonLabel": "Previous",
    "ui/mediaPlayerChapterSkipForwardButtonLabel": "Next",
    "ui/mediaPlayerClosedCaptionsButtonLabel": "Closed captions",
    "ui/mediaPlayerFastForwardButtonLabel": "Fast forward",
    "ui/mediaPlayerFullscreenButtonLabel": "Fullscreen",
    "ui/mediaPlayerLiveButtonLabel": "LIVE",
    "ui/mediaPlayerNextTrackButtonLabel": "Next",
    "ui/mediaPlayerOverlayActiveOptionIndicator": "(On)",
    "ui/mediaPlayerPauseButtonLabel": "Pause",
    "ui/mediaPlayerPlayButtonLabel": "Play",
    "ui/mediaPlayerPlayFromBeginningButtonLabel": "Replay",
    "ui/mediaPlayerPlayRateButtonLabel": "Playback rate",
    "ui/mediaPlayerPreviousTrackButtonLabel": "Previous",
    "ui/mediaPlayerRewindButtonLabel": "Rewind",
    "ui/mediaPlayerStopButtonLabel": "Stop",
    "ui/mediaPlayerTimeSkipBackButtonLabel": "8 second replay",   
    "ui/mediaPlayerTimeSkipForwardButtonLabel": "30 second skip",
    "ui/mediaPlayerToggleSnapButtonLabel": "Snap",
    "ui/mediaPlayerVolumeButtonLabel": "Volume",
    "ui/mediaPlayerZoomButtonLabel": "Zoom",
    "ui/menuCommandAriaLabel": "Menu Item",
    "ui/menuAriaLabel": "Menu",
    "ui/navBarContainerViewportAriaLabel": "Scrolling Container",
    "ui/nextTrackMediaCommandDisplayText": "Next track",
    "ui/off": "Off",
    "ui/on": "On",
    "ui/pauseMediaCommandDisplayText": "Pause",
    "ui/playFromBeginningMediaCommandDisplayText": "Play again",
    "ui/playbackRateHalfSpeedLabel": "0.5x",
    "ui/playbackRateNormalSpeedLabel": "Normal",
    "ui/playbackRateOneAndHalfSpeedLabel": "1.5x",
    "ui/playbackRateDoubleSpeedLabel": "2x",
    "ui/playMediaCommandDisplayText": "Play",
    "ui/pivotAriaLabel": "Pivot",
    "ui/pivotViewportAriaLabel": "Scrolling Container",
    "ui/replayMediaCommandDisplayText": "Play again",
    "ui/rewindMediaCommandDisplayText": "Rewind",
    "ui/rewindFeedbackDisplayText": " {0}X",
    "ui/rewindFeedbackSlowMotionDisplayText": "0.5X",
    "ui/searchBoxAriaLabel": "Searchbox",
    "ui/searchBoxAriaLabelInputNoPlaceHolder": "Searchbox, enter to submit query, esc to clear text",
    "ui/searchBoxAriaLabelInputPlaceHolder": "Searchbox, {0}, enter to submit query, esc to clear text",
    "ui/searchBoxAriaLabelButton": "Click to submit query",
    "ui/seeMore":  "See more",
    "ui/selectAMPM": "Select A.M P.M",
    "ui/selectDay": "Select Day",
    "ui/selectHour": "Select Hour",
    "ui/selectMinute": "Select Minute",
    "ui/selectMonth": "Select Month",
    "ui/selectYear": "Select Year",
    "ui/settingsFlyoutAriaLabel": "Settings Flyout",
    "ui/stopMediaCommandDisplayText": "Stop",
    "ui/tentativeRating": "Tentative Rating",
    "ui/timePicker": "Time Picker",
    "ui/timeSeparator": ":",
    "ui/timeSkipBackMediaCommandDisplayText": "Skip back",
    "ui/timeSkipForwardMediaCommandDisplayText": "Skip forward",
    "ui/toolbarAriaLabel": "ToolBar",
    "ui/toolbarOverflowButtonAriaLabel": "View more",
    "ui/unrated": "Unrated",
    "ui/userRating": "User Rating",
    "ui/zoomMediaCommandDisplayText": "Zoom",
    // AppBar Icons follow, the format of the ui.js and ui.resjson differ for
    // the AppBarIcon namespace.  The remainder of the file therefore differs.
    // Code point comments are the icon glyphs in the 'Segoe UI Symbol' font.
    "ui/appBarIcons/previous":                            "\uE100", // group:Media
    "_ui/appBarIcons/previous.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/next":                                "\uE101", // group:Media
    "_ui/appBarIcons/next.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/play":                                "\uE102", // group:Media
    "_ui/appBarIcons/play.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/pause":                               "\uE103", // group:Media
    "_ui/appBarIcons/pause.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/edit":                                "\uE104", // group:File
    "_ui/appBarIcons/edit.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/save":                                "\uE105", // group:File
    "_ui/appBarIcons/save.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/clear":                               "\uE106", // group:File
    "_ui/appBarIcons/clear.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/delete":                              "\uE107", // group:File
    "_ui/appBarIcons/delete.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/remove":                              "\uE108", // group:File
    "_ui/appBarIcons/remove.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/add":                                 "\uE109", // group:File
    "_ui/appBarIcons/add.comment":                        "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/cancel":                              "\uE10A", // group:Editing
    "_ui/appBarIcons/cancel.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/accept":                              "\uE10B", // group:General
    "_ui/appBarIcons/accept.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/more":                                "\uE10C", // group:General
    "_ui/appBarIcons/more.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/redo":                                "\uE10D", // group:Editing
    "_ui/appBarIcons/redo.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/undo":                                "\uE10E", // group:Editing
    "_ui/appBarIcons/undo.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/home":                                "\uE10F", // group:General
    "_ui/appBarIcons/home.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/up":                                  "\uE110", // group:General
    "_ui/appBarIcons/up.comment":                         "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/forward":                             "\uE111", // group:General
    "_ui/appBarIcons/forward.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/right":                               "\uE111", // group:General
    "_ui/appBarIcons/right.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/back":                                "\uE112", // group:General
    "_ui/appBarIcons/back.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/left":                                "\uE112", // group:General
    "_ui/appBarIcons/left.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/favorite":                            "\uE113", // group:Media
    "_ui/appBarIcons/favorite.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/camera":                              "\uE114", // group:System
    "_ui/appBarIcons/camera.comment":                     "{Locked=qps-ploc,qps-plocm}",    
    "ui/appBarIcons/settings":                            "\uE115", // group:System
    "_ui/appBarIcons/settings.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/video":                               "\uE116", // group:Media
    "_ui/appBarIcons/video.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/sync":                                "\uE117", // group:Media
    "_ui/appBarIcons/sync.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/download":                            "\uE118", // group:Media
    "_ui/appBarIcons/download.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/mail":                                "\uE119", // group:Mail and calendar
    "_ui/appBarIcons/mail.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/find":                                "\uE11A", // group:Data
    "_ui/appBarIcons/find.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/help":                                "\uE11B", // group:General
    "_ui/appBarIcons/help.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/upload":                              "\uE11C", // group:Media
    "_ui/appBarIcons/upload.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/emoji":                               "\uE11D", // group:Communications
    "_ui/appBarIcons/emoji.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/twopage":                             "\uE11E", // group:Layout
    "_ui/appBarIcons/twopage.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/leavechat":                           "\uE11F", // group:Communications
    "_ui/appBarIcons/leavechat.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/mailforward":                         "\uE120", // group:Mail and calendar
    "_ui/appBarIcons/mailforward.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/clock":                               "\uE121", // group:General
    "_ui/appBarIcons/clock.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/send":                                "\uE122", // group:Mail and calendar
    "_ui/appBarIcons/send.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/crop":                                "\uE123", // group:Editing
    "_ui/appBarIcons/crop.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/rotatecamera":                        "\uE124", // group:System
    "_ui/appBarIcons/rotatecamera.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/people":                              "\uE125", // group:Communications
    "_ui/appBarIcons/people.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/closepane":                           "\uE126", // group:Layout
    "_ui/appBarIcons/closepane.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/openpane":                            "\uE127", // group:Layout
    "_ui/appBarIcons/openpane.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/world":                               "\uE128", // group:General
    "_ui/appBarIcons/world.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/flag":                                "\uE129", // group:Mail and calendar
    "_ui/appBarIcons/flag.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/previewlink":                         "\uE12A", // group:General
    "_ui/appBarIcons/previewlink.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/globe":                               "\uE12B", // group:Communications
    "_ui/appBarIcons/globe.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/trim":                                "\uE12C", // group:Editing
    "_ui/appBarIcons/trim.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/attachcamera":                        "\uE12D", // group:System
    "_ui/appBarIcons/attachcamera.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/zoomin":                              "\uE12E", // group:Layout
    "_ui/appBarIcons/zoomin.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/bookmarks":                           "\uE12F", // group:Editing
    "_ui/appBarIcons/bookmarks.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/document":                            "\uE130", // group:File
    "_ui/appBarIcons/document.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/protecteddocument":                   "\uE131", // group:File
    "_ui/appBarIcons/protecteddocument.comment":          "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/page":                                "\uE132", // group:Layout
    "_ui/appBarIcons/page.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/bullets":                             "\uE133", // group:Editing
    "_ui/appBarIcons/bullets.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/comment":                             "\uE134", // group:Communications
    "_ui/appBarIcons/comment.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/mail2":                               "\uE135", // group:Mail and calendar
    "_ui/appBarIcons/mail2.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/contactinfo":                         "\uE136", // group:Communications
    "_ui/appBarIcons/contactinfo.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/hangup":                              "\uE137", // group:Communications
    "_ui/appBarIcons/hangup.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/viewall":                             "\uE138", // group:Data
    "_ui/appBarIcons/viewall.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/mappin":                              "\uE139", // group:General
    "_ui/appBarIcons/mappin.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/phone":                               "\uE13A", // group:Communications
    "_ui/appBarIcons/phone.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/videochat":                           "\uE13B", // group:Communications
    "_ui/appBarIcons/videochat.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/switch":                              "\uE13C", // group:Communications
    "_ui/appBarIcons/switch.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/contact":                             "\uE13D", // group:Communications
    "_ui/appBarIcons/contact.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/rename":                              "\uE13E", // group:File
    "_ui/appBarIcons/rename.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/pin":                                 "\uE141", // group:System
    "_ui/appBarIcons/pin.comment":                        "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/musicinfo":                           "\uE142", // group:Media
    "_ui/appBarIcons/musicinfo.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/go":                                  "\uE143", // group:General
    "_ui/appBarIcons/go.comment":                         "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/keyboard":                            "\uE144", // group:System
    "_ui/appBarIcons/keyboard.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/dockleft":                            "\uE145", // group:Layout
    "_ui/appBarIcons/dockleft.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/dockright":                           "\uE146", // group:Layout
    "_ui/appBarIcons/dockright.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/dockbottom":                          "\uE147", // group:Layout
    "_ui/appBarIcons/dockbottom.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/remote":                              "\uE148", // group:System
    "_ui/appBarIcons/remote.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/refresh":                             "\uE149", // group:Data
    "_ui/appBarIcons/refresh.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/rotate":                              "\uE14A", // group:Layout
    "_ui/appBarIcons/rotate.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/shuffle":                             "\uE14B", // group:Media
    "_ui/appBarIcons/shuffle.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/list":                                "\uE14C", // group:Editing
    "_ui/appBarIcons/list.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/shop":                                "\uE14D", // group:General
    "_ui/appBarIcons/shop.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/selectall":                           "\uE14E", // group:Data
    "_ui/appBarIcons/selectall.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/orientation":                         "\uE14F", // group:Layout
    "_ui/appBarIcons/orientation.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/import":                              "\uE150", // group:Data
    "_ui/appBarIcons/import.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/importall":                           "\uE151", // group:Data
    "_ui/appBarIcons/importall.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/browsephotos":                        "\uE155", // group:Media
    "_ui/appBarIcons/browsephotos.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/webcam":                              "\uE156", // group:System
    "_ui/appBarIcons/webcam.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/pictures":                            "\uE158", // group:Media
    "_ui/appBarIcons/pictures.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/savelocal":                           "\uE159", // group:File
    "_ui/appBarIcons/savelocal.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/caption":                             "\uE15A", // group:Media
    "_ui/appBarIcons/caption.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/stop":                                "\uE15B", // group:Media
    "_ui/appBarIcons/stop.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/showresults":                         "\uE15C", // group:Data
    "_ui/appBarIcons/showresults.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/volume":                              "\uE15D", // group:Media
    "_ui/appBarIcons/volume.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/repair":                              "\uE15E", // group:System
    "_ui/appBarIcons/repair.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/message":                             "\uE15F", // group:Communications
    "_ui/appBarIcons/message.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/page2":                               "\uE160", // group:Layout
    "_ui/appBarIcons/page2.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/calendarday":                         "\uE161", // group:Mail and calendar
    "_ui/appBarIcons/calendarday.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/calendarweek":                        "\uE162", // group:Mail and calendar
    "_ui/appBarIcons/calendarweek.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/calendar":                            "\uE163", // group:Mail and calendar
    "_ui/appBarIcons/calendar.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/characters":                          "\uE164", // group:Editing
    "_ui/appBarIcons/characters.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/mailreplyall":                        "\uE165", // group:Mail and calendar
    "_ui/appBarIcons/mailreplyall.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/read":                                "\uE166", // group:Mail and calendar
    "_ui/appBarIcons/read.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/link":                                "\uE167", // group:Communications
    "_ui/appBarIcons/link.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/accounts":                            "\uE168", // group:Communications
    "_ui/appBarIcons/accounts.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/showbcc":                             "\uE169", // group:Mail and calendar
    "_ui/appBarIcons/showbcc.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/hidebcc":                             "\uE16A", // group:Mail and calendar
    "_ui/appBarIcons/hidebcc.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/cut":                                 "\uE16B", // group:Editing
    "_ui/appBarIcons/cut.comment":                        "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/attach":                              "\uE16C", // group:Mail and calendar
    "_ui/appBarIcons/attach.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/paste":                               "\uE16D", // group:Editing
    "_ui/appBarIcons/paste.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/filter":                              "\uE16E", // group:Data
    "_ui/appBarIcons/filter.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/copy":                                "\uE16F", // group:Editing
    "_ui/appBarIcons/copy.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/emoji2":                              "\uE170", // group:Mail and calendar
    "_ui/appBarIcons/emoji2.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/important":                           "\uE171", // group:Mail and calendar
    "_ui/appBarIcons/important.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/mailreply":                           "\uE172", // group:Mail and calendar
    "_ui/appBarIcons/mailreply.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/slideshow":                           "\uE173", // group:Media
    "_ui/appBarIcons/slideshow.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/sort":                                "\uE174", // group:Data
    "_ui/appBarIcons/sort.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/manage":                              "\uE178", // group:System
    "_ui/appBarIcons/manage.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/allapps":                             "\uE179", // group:System
    "_ui/appBarIcons/allapps.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/disconnectdrive":                     "\uE17A", // group:System
    "_ui/appBarIcons/disconnectdrive.comment":            "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/mapdrive":                            "\uE17B", // group:System
    "_ui/appBarIcons/mapdrive.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/newwindow":                           "\uE17C", // group:System
    "_ui/appBarIcons/newwindow.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/openwith":                            "\uE17D", // group:System
    "_ui/appBarIcons/openwith.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/contactpresence":                     "\uE181", // group:Communications
    "_ui/appBarIcons/contactpresence.comment":            "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/priority":                            "\uE182", // group:Mail and calendar
    "_ui/appBarIcons/priority.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/uploadskydrive":                      "\uE183", // group:File
    "_ui/appBarIcons/uploadskydrive.comment":             "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/gototoday":                           "\uE184", // group:Mail and calendar
    "_ui/appBarIcons/gototoday.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/font":                                "\uE185", // group:Editing
    "_ui/appBarIcons/font.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/fontcolor":                           "\uE186", // group:Editing
    "_ui/appBarIcons/fontcolor.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/contact2":                            "\uE187", // group:Communications
    "_ui/appBarIcons/contact2.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/folder":                              "\uE188", // group:File
    "_ui/appBarIcons/folder.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/audio":                               "\uE189", // group:Media
    "_ui/appBarIcons/audio.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/placeholder":                         "\uE18A", // group:General
    "_ui/appBarIcons/placeholder.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/view":                                "\uE18B", // group:Layout
    "_ui/appBarIcons/view.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/setlockscreen":                       "\uE18C", // group:System
    "_ui/appBarIcons/setlockscreen.comment":              "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/settile":                             "\uE18D", // group:System
    "_ui/appBarIcons/settile.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/cc":                                  "\uE190", // group:Media
    "_ui/appBarIcons/cc.comment":                         "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/stopslideshow":                       "\uE191", // group:Media
    "_ui/appBarIcons/stopslideshow.comment":              "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/permissions":                         "\uE192", // group:System
    "_ui/appBarIcons/permissions.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/highlight":                           "\uE193", // group:Editing
    "_ui/appBarIcons/highlight.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/disableupdates":                      "\uE194", // group:System
    "_ui/appBarIcons/disableupdates.comment":             "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/unfavorite":                          "\uE195", // group:Media
    "_ui/appBarIcons/unfavorite.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/unpin":                               "\uE196", // group:System
    "_ui/appBarIcons/unpin.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/openlocal":                           "\uE197", // group:File
    "_ui/appBarIcons/openlocal.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/mute":                                "\uE198", // group:Media
    "_ui/appBarIcons/mute.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/italic":                              "\uE199", // group:Editing
    "_ui/appBarIcons/italic.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/underline":                           "\uE19A", // group:Editing
    "_ui/appBarIcons/underline.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/bold":                                "\uE19B", // group:Editing
    "_ui/appBarIcons/bold.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/movetofolder":                        "\uE19C", // group:File
    "_ui/appBarIcons/movetofolder.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/likedislike":                         "\uE19D", // group:Data
    "_ui/appBarIcons/likedislike.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/dislike":                             "\uE19E", // group:Data
    "_ui/appBarIcons/dislike.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/like":                                "\uE19F", // group:Data
    "_ui/appBarIcons/like.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/alignright":                          "\uE1A0", // group:Editing
    "_ui/appBarIcons/alignright.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/aligncenter":                         "\uE1A1", // group:Editing
    "_ui/appBarIcons/aligncenter.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/alignleft":                           "\uE1A2", // group:Editing
    "_ui/appBarIcons/alignleft.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/zoom":                                "\uE1A3", // group:Layout
    "_ui/appBarIcons/zoom.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/zoomout":                             "\uE1A4", // group:Layout
    "_ui/appBarIcons/zoomout.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/openfile":                            "\uE1A5", // group:File
    "_ui/appBarIcons/openfile.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/otheruser":                           "\uE1A6", // group:System
    "_ui/appBarIcons/otheruser.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/admin":                               "\uE1A7", // group:System
    "_ui/appBarIcons/admin.comment":                      "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/street":                              "\uE1C3", // group:General
    "_ui/appBarIcons/street.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/map":                                 "\uE1C4", // group:General
    "_ui/appBarIcons/map.comment":                        "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/clearselection":                      "\uE1C5", // group:Data
    "_ui/appBarIcons/clearselection.comment":             "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/fontdecrease":                        "\uE1C6", // group:Editing
    "_ui/appBarIcons/fontdecrease.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/fontincrease":                        "\uE1C7", // group:Editing
    "_ui/appBarIcons/fontincrease.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/fontsize":                            "\uE1C8", // group:Editing
    "_ui/appBarIcons/fontsize.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/cellphone":                           "\uE1C9", // group:Communications
    "_ui/appBarIcons/cellphone.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/reshare":                             "\uE1CA", // group:Communications
    "_ui/appBarIcons/reshare.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/tag":                                 "\uE1CB", // group:Data
    "_ui/appBarIcons/tag.comment":                        "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/repeatone":                           "\uE1CC", // group:Media
    "_ui/appBarIcons/repeatone.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/repeatall":                           "\uE1CD", // group:Media
    "_ui/appBarIcons/repeatall.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/outlinestar":                         "\uE1CE", // group:Data
    "_ui/appBarIcons/outlinestar.comment":                "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/solidstar":                           "\uE1CF", // group:Data
    "_ui/appBarIcons/solidstar.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/calculator":                          "\uE1D0", // group:General
    "_ui/appBarIcons/calculator.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/directions":                          "\uE1D1", // group:General
    "_ui/appBarIcons/directions.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/target":                              "\uE1D2", // group:General
    "_ui/appBarIcons/target.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/library":                             "\uE1D3", // group:Media
    "_ui/appBarIcons/library.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/phonebook":                           "\uE1D4", // group:Communications
    "_ui/appBarIcons/phonebook.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/memo":                                "\uE1D5", // group:Communications
    "_ui/appBarIcons/memo.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/microphone":                          "\uE1D6", // group:System
    "_ui/appBarIcons/microphone.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/postupdate":                          "\uE1D7", // group:Communications
    "_ui/appBarIcons/postupdate.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/backtowindow":                        "\uE1D8", // group:Layout
    "_ui/appBarIcons/backtowindow.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/fullscreen":                          "\uE1D9", // group:Layout
    "_ui/appBarIcons/fullscreen.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/newfolder":                           "\uE1DA", // group:File
    "_ui/appBarIcons/newfolder.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/calendarreply":                       "\uE1DB", // group:Mail and calendar
    "_ui/appBarIcons/calendarreply.comment":              "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/unsyncfolder":                        "\uE1DD", // group:File
    "_ui/appBarIcons/unsyncfolder.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/reporthacked":                        "\uE1DE", // group:Communications
    "_ui/appBarIcons/reporthacked.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/syncfolder":                          "\uE1DF", // group:File
    "_ui/appBarIcons/syncfolder.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/blockcontact":                        "\uE1E0", // group:Communications
    "_ui/appBarIcons/blockcontact.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/switchapps":                          "\uE1E1", // group:System
    "_ui/appBarIcons/switchapps.comment":                 "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/addfriend":                           "\uE1E2", // group:Communications
    "_ui/appBarIcons/addfriend.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/touchpointer":                        "\uE1E3", // group:System
    "_ui/appBarIcons/touchpointer.comment":               "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/gotostart":                           "\uE1E4", // group:System
    "_ui/appBarIcons/gotostart.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/zerobars":                            "\uE1E5", // group:System
    "_ui/appBarIcons/zerobars.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/onebar":                              "\uE1E6", // group:System
    "_ui/appBarIcons/onebar.comment":                     "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/twobars":                             "\uE1E7", // group:System
    "_ui/appBarIcons/twobars.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/threebars":                           "\uE1E8", // group:System
    "_ui/appBarIcons/threebars.comment":                  "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/fourbars":                            "\uE1E9", // group:System
    "_ui/appBarIcons/fourbars.comment":                   "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/scan":                                "\uE294", // group:General
    "_ui/appBarIcons/scan.comment":                       "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/preview":                             "\uE295", // group:General
    "_ui/appBarIcons/preview.comment":                    "{Locked=qps-ploc,qps-plocm}",
    "ui/appBarIcons/hamburger":                           "\uE700", // group:General
    "_ui/appBarIcons/hamburger.comment":                  "{Locked=qps-ploc,qps-plocm}"
}
);
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_Resources',[
    'exports',
    './_Global',
    './_WinRT',
    './_Base',
    './_Events',
    'require-json!strings/en-us/Microsoft.TVJS.resjson',
    ], function resourcesInit(exports, _Global, _WinRT, _Base, _Events, defaultStrings) {
    "use strict";

    function _getTVJSString(id) {
        var result = getString("ms-resource:///Microsoft.TVJS/" + id);

        if (result.empty) {
            result = _getStringBuiltIn(id);
        }

        return result;
    }

    function _getStringBuiltIn(resourceId) {
        var str = defaultStrings[resourceId];

        if (typeof str === "string") {
            str = { value: str };
        }

        return str || { value: resourceId, empty: true };
    }

    var resourceMap;
    var mrtEventHook = false;
    var contextChangedET = "contextchanged";
    var resourceContext;

    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /* empty */ }, { supportedForProcessing: false }), _Events.eventMixin);
    var listeners = new ListenerType();
    var createEvent = _Events._createEventProperty;

    var strings = {
        get malformedFormatStringInput() { return "Malformed, did you mean to escape your '{0}'?"; },
    };

    _Base.Namespace.define("TVJS.Resources", {
        _getTVJSString: _getTVJSString
    });

    function formatString(string) {
        var args = arguments;
        if (args.length > 1) {
            string = string.replace(/({{)|(}})|{(\d+)}|({)|(})/g, function (unused, left, right, index, illegalLeft, illegalRight) {
                if (illegalLeft || illegalRight) { throw formatString(strings.malformedFormatStringInput, illegalLeft || illegalRight); }
                return (left && "{") || (right && "}") || args[(index | 0) + 1];
            });
        }
        return string;
    }

    _Base.Namespace._moduleDefine(exports, "TVJS.Resources", {
        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="TVJS.Resources.addEventListener">
            /// <summary locid="TVJS.Resources.addEventListener">
            /// Registers an event handler for the specified event.
            /// </summary>
            /// <param name='type' type="String" locid='TVJS.Resources.addEventListener_p:type'>
            /// The name of the event to handle.
            /// </param>
            /// <param name='listener' type="Function" locid='TVJS.Resources.addEventListener_p:listener'>
            /// The listener to invoke when the event gets raised.
            /// </param>
            /// <param name='useCapture' type="Boolean" locid='TVJS.Resources.addEventListener_p:useCapture'>
            /// Set to true to register the event handler for the capturing phase; set to false to register for the bubbling phase.
            /// </param>
            /// </signature>
            if (_WinRT.Windows.ApplicationModel.Resources.Core.ResourceManager && !mrtEventHook) {
                if (type === contextChangedET) {
                    try {
                        var resContext = exports._getResourceContext();
                        if (resContext) {
                            resContext.qualifierValues.addEventListener("mapchanged", function (e) {
                                exports.dispatchEvent(contextChangedET, { qualifier: e.key, changed: e.target[e.key] });
                            }, false);

                        } else {
                            // The API can be called in the Background thread (web worker).
                            _WinRT.Windows.ApplicationModel.Resources.Core.ResourceManager.current.defaultContext.qualifierValues.addEventListener("mapchanged", function (e) {
                                exports.dispatchEvent(contextChangedET, { qualifier: e.key, changed: e.target[e.key] });
                            }, false);
                        }
                        mrtEventHook = true;
                    } catch (e) {
                    }
                }
            }
            listeners.addEventListener(type, listener, useCapture);
        },
        removeEventListener: listeners.removeEventListener.bind(listeners),
        dispatchEvent: listeners.dispatchEvent.bind(listeners),

        _formatString: formatString,

        _getStringWinRT: function (resourceId) {
            if (!resourceMap) {
                var mainResourceMap = _WinRT.Windows.ApplicationModel.Resources.Core.ResourceManager.current.mainResourceMap;
                try {
                    resourceMap = mainResourceMap.getSubtree('Resources');
                }
                catch (e) {
                }
                if (!resourceMap) {
                    resourceMap = mainResourceMap;
                }
            }

            var stringValue;
            var langValue;
            var resCandidate;
            try {
                var resContext = exports._getResourceContext();
                if (resContext) {
                    resCandidate = resourceMap.getValue(resourceId, resContext);
                } else {
                    resCandidate = resourceMap.getValue(resourceId);
                }

                if (resCandidate) {
                    stringValue = resCandidate.valueAsString;
                    if (stringValue === undefined) {
                        stringValue = resCandidate.toString();
                    }
                }
            }
            catch (e) { }

            if (!stringValue) {
                return exports._getStringJS(resourceId);
            }

            try {
                langValue = resCandidate.getQualifierValue("Language");
            }
            catch (e) {
                return { value: stringValue };
            }

            return { value: stringValue, lang: langValue };
        },

        _getStringJS: function (resourceId) {
            var str = _Global.strings && _Global.strings[resourceId];
            if (typeof str === "string") {
                str = { value: str };
            }
            return str || { value: resourceId, empty: true };
        },

        _getResourceContext: function () {
            if (_Global.document) {
                if (typeof (resourceContext) === 'undefined') {
                    var context = _WinRT.Windows.ApplicationModel.Resources.Core.ResourceContext;
                    if (context.getForCurrentView) {
                        resourceContext = context.getForCurrentView();
                    } else {
                        resourceContext = null;
                    }

                }
            }
            return resourceContext;
        },

        oncontextchanged: createEvent(contextChangedET)

    });

    var getStringImpl = _WinRT.Windows.ApplicationModel.Resources.Core.ResourceManager ? exports._getStringWinRT : exports._getStringJS;

    var getString = function (resourceId) {
        /// <signature helpKeyword="TVJS.Resources.getString">
        /// <summary locid='TVJS.Resources.getString'>
        /// Retrieves the resource string that has the specified resource id.
        /// </summary>
        /// <param name='resourceId' type="Number" locid='TVJS.Resources.getString._p:resourceId'>
        /// The resource id of the string to retrieve.
        /// </param>
        /// <returns type='Object' locid='TVJS.Resources.getString_returnValue'>
        /// An object that can contain these properties:
        ///
        /// value:
        /// The value of the requested string. This property is always present.
        ///
        /// empty:
        /// A value that specifies whether the requested string wasn't found.
        /// If its true, the string wasn't found. If its false or undefined,
        /// the requested string was found.
        ///
        /// lang:
        /// The language of the string, if specified. This property is only present
        /// for multi-language resources.
        ///
        /// </returns>
        /// </signature>

        return getStringImpl(resourceId);
    };

    _Base.Namespace._moduleDefine(exports, null, {
        _formatString: formatString,
        _getTVJSString: _getTVJSString
    });

    _Base.Namespace._moduleDefine(exports, "TVJS.Resources", {
        getString: {
            get: function () {
                return getString;
            },
            set: function (value) {
                getString = value;
            }
        }
    });

});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_Trace',[
    './_Global'
    ], function traceInit(_Global) {
    "use strict";

    function nop(v) {
        return v;
    }

    return {
        _traceAsyncOperationStarting: (_Global.Debug && _Global.Debug.msTraceAsyncOperationStarting && _Global.Debug.msTraceAsyncOperationStarting.bind(_Global.Debug)) || nop,
        _traceAsyncOperationCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncOperationCompleted && _Global.Debug.msTraceAsyncOperationCompleted.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackStarting: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackStarting && _Global.Debug.msTraceAsyncCallbackStarting.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackCompleted && _Global.Debug.msTraceAsyncCallbackCompleted.bind(_Global.Debug)) || nop
    };
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Promise/_StateMachine',[
    '../Core/_Global',
    '../Core/_BaseCoreUtils',
    '../Core/_Base',
    '../Core/_ErrorFromName',
    '../Core/_Events',
    '../Core/_Trace'
    ], function promiseStateMachineInit(_Global, _BaseCoreUtils, _Base, _ErrorFromName, _Events, _Trace) {
    "use strict";

    _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);

    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), _Events.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise: 0x01,
        thenPromise: 0x02,
        errorPromise: 0x04,
        exceptionPromise: 0x08,
        completePromise: 0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (TVJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            // We can special case our own intermediate promises which are not in a
            //  terminal state by just pushing this promise as a listener without
            //  having to create new indirection functions
            if (waitedUpon instanceof ThenPromise &&
                waitedUpon._state !== state_error &&
                waitedUpon._state !== state_success) {
                pushListener(waitedUpon, { promise: promise });
            } else {
                var error = function (value) {
                    if (waitedUpon._errorId) {
                        promise._chainedError(value, waitedUpon);
                    } else {
                        // Because this is an interop boundary we want to indicate that this
                        //  error has been handled by the promise infrastructure before we
                        //  begin a new handling chain.
                        //
                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                        promise._error(value);
                    }
                };
                error.handlesOnError = true;
                waitedUpon.then(
                    promise._completed.bind(promise),
                    error,
                    promise._progress.bind(promise)
                );
            }
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = _Base.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="TVJS.PromiseStateMachine.cancel">
            /// <summary locid="TVJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="TVJS.PromiseStateMachine.done">
            /// <summary locid="TVJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="TVJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="TVJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="TVJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="TVJS.PromiseStateMachine.then">
            /// <summary locid="TVJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="TVJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="TVJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="TVJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="TVJS.Promise" locid="TVJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        var asyncOpID = _Trace._traceAsyncOperationStarting("TVJS.Promise.done");
        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;

            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, _Global.Debug && _Global.Debug.MS_ASYNC_OP_STATUS_SUCCESS);

            if (target) {
                _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    _Trace._traceAsyncCallbackCompleted();
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;

            var errorID = _Global.Debug && (value && value.name === canceledName ? _Global.Debug.MS_ASYNC_OP_STATUS_CANCELED : _Global.Debug.MS_ASYNC_OP_STATUS_ERROR);
            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, errorID);

            if (target) {
                var asyncCallbackStarted = false;
                try {
                    if (onError) {
                        _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                        asyncCallbackStarted = true;
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value));
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    if (asyncCallbackStarted) {
                        _Trace._traceAsyncCallbackCompleted();
                    }
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        var asyncOpID = _Trace._traceAsyncOperationStarting("TVJS.Promise.then");
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = _Base.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by TVJS.Promise.wrap
    // and TVJS.Promise.wrapError.
    //

    var ErrorPromise = _Base.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="TVJS.PromiseStateMachine.cancel">
                /// <summary locid="TVJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="TVJS.PromiseStateMachine.done">
                /// <summary locid="TVJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="TVJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="TVJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="TVJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                Promise._doneHandler(value);
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="TVJS.PromiseStateMachine.then">
                /// <summary locid="TVJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="TVJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="TVJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="TVJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = _Base.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = _Base.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="TVJS.PromiseStateMachine.cancel">
                /// <summary locid="TVJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="TVJS.PromiseStateMachine.done">
                /// <summary locid="TVJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="TVJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="TVJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="TVJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    Promise._doneHandler(ex);
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="TVJS.PromiseStateMachine.then">
                /// <summary locid="TVJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="TVJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="TVJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="TVJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable TVJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new Promise(
            function (c) {
                if (timeoutMS) {
                    id = _Global.setTimeout(c, timeoutMS);
                } else {
                    _BaseCoreUtils._setImmediate(c);
                }
            },
            function () {
                if (id) {
                    _Global.clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); };
        var cancelTimeout = function () { timeout.cancel(); };
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = _Base.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="TVJS.Promise">
            /// <summary locid="TVJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="TVJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="TVJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
                if (this._oncancel) {
                    try { this._oncancel(); } catch (ex) { }
                }
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="TVJS.Promise.addEventListener">
                /// <summary locid="TVJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="TVJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="TVJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="TVJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="TVJS.Promise.any">
                /// <summary locid="TVJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="TVJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error) {
                        var keys = Object.keys(values);
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="TVJS.Promise.as">
                /// <summary locid="TVJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="TVJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="TVJS.Promise" helpKeyword="TVJS.Promise.cancel" locid="TVJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new _ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="TVJS.Promise.dispatchEvent">
                /// <summary locid="TVJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="TVJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="TVJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="TVJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="TVJS.Promise.is">
                /// <summary locid="TVJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="TVJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="TVJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="TVJS.Promise.join">
                /// <summary locid="TVJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="TVJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="TVJS.Promise.removeEventListener">
                /// <summary locid="TVJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="TVJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="TVJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="TVJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="TVJS.Promise.then">
                /// <summary locid="TVJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="TVJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="TVJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="TVJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="TVJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="TVJS.Promise.thenEach">
                /// <summary locid="TVJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="TVJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="TVJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="TVJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="TVJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="TVJS.Promise.timeout">
                /// <summary locid="TVJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="TVJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="TVJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="TVJS.Promise.wrap">
                /// <summary locid="TVJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="TVJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="TVJS.Promise.wrapError">
                /// <summary locid="TVJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="TVJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                if (_Global.Debug && _Global.Debug.debuggerEnabled) {
                    try { throw new Error(); } catch (e) { return e.stack; }
                }
            },

            _cancelBlocker: function Promise__cancelBlocker(input, oncancel) {
                //
                // Returns a promise which on cancelation will still result in downstream cancelation while
                //  protecting the promise 'input' from being  canceled which has the effect of allowing
                //  'input' to be shared amoung various consumers.
                //
                if (!Promise.is(input)) {
                    return Promise.wrap(input);
                }
                var complete;
                var error;
                var output = new Promise(
                    function (c, e) {
                        complete = c;
                        error = e;
                    },
                    function () {
                        complete = null;
                        error = null;
                        oncancel && oncancel();
                    }
                );
                input.then(
                    function (v) { complete && complete(v); },
                    function (e) { error && error(e); }
                );
                return output;
            },

        }
    );
    Object.defineProperties(Promise, _Events.createEventProperties(errorET));

    Promise._doneHandler = function (value) {
        _BaseCoreUtils._setImmediate(function Promise_done_rethrow() {
            throw value;
        });
    };

    return {
        PromiseStateMachine: PromiseStateMachine,
        Promise: Promise,
        state_created: state_created
    };
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Promise',[
    './Core/_Base',
    './Promise/_StateMachine'
    ], function promiseInit( _Base, _StateMachine) {
    "use strict";

    _Base.Namespace.define("TVJS", {
        Promise: _StateMachine.Promise
    });

    return _StateMachine.Promise;
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_Log',[
    'exports',
    './_Global',
    './_Base',
    ], function logInit(exports, _Global, _Base) {
    "use strict";

    var spaceR = /\s+/g;
    var typeR = /^(error|warn|info|log)$/;
    var TVJSLog = null;

    function format(message, tag, type) {
        /// <signature helpKeyword="TVJS.Utilities.formatLog">
        /// <summary locid="TVJS.Utilities.formatLog">
        /// Adds tags and type to a logging message.
        /// </summary>
        /// <param name="message" type="String" locid="TVJS.Utilities.startLog_p:message">The message to format.</param>
        /// <param name="tag" type="String" locid="TVJS.Utilities.startLog_p:tag">
        /// The tag(s) to apply to the message. Separate multiple tags with spaces.
        /// </param>
        /// <param name="type" type="String" locid="TVJS.Utilities.startLog_p:type">The type of the message.</param>
        /// <returns type="String" locid="TVJS.Utilities.startLog_returnValue">The formatted message.</returns>
        /// </signature>
        var m = message;
        if (typeof (m) === "function") { m = m(); }

        return ((type && typeR.test(type)) ? ("") : (type ? (type + ": ") : "")) +
            (tag ? tag.replace(spaceR, ":") + ": " : "") +
            m;
    }
    function defAction(message, tag, type) {
        var m = exports.formatLog(message, tag, type);
        if (_Global.console) {
            _Global.console[(type && typeR.test(type)) ? type : "log"](m);
        }
    }
    function escape(s) {
        // \s (whitespace) is used as separator, so don't escape it
        return s.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
    }
    _Base.Namespace._moduleDefine(exports, "TVJS.Utilities", {
        startLog: function (options) {
            /// <signature helpKeyword="TVJS.Utilities.startLog">
            /// <summary locid="TVJS.Utilities.startLog">
            /// Configures a logger that writes messages containing the specified tags from TVJS.log to console.log.
            /// </summary>
            /// <param name="options" type="String" locid="TVJS.Utilities.startLog_p:options">
            /// The tags for messages to log. Separate multiple tags with spaces.
            /// </param>
            /// </signature>
            /// <signature>
            /// <summary locid="TVJS.Utilities.startLog2">
            /// Configure a logger to write TVJS.log output.
            /// </summary>
            /// <param name="options" type="Object" locid="TVJS.Utilities.startLog_p:options2">
            /// May contain .type, .tags, .excludeTags and .action properties.
            ///  - .type is a required tag.
            ///  - .excludeTags is a space-separated list of tags, any of which will result in a message not being logged.
            ///  - .tags is a space-separated list of tags, any of which will result in a message being logged.
            ///  - .action is a function that, if present, will be called with the log message, tags and type. The default is to log to the console.
            /// </param>
            /// </signature>
            options = options || {};
            if (typeof options === "string") {
                options = { tags: options };
            }
            var el = options.type && new RegExp("^(" + escape(options.type).replace(spaceR, " ").split(" ").join("|") + ")$");
            var not = options.excludeTags && new RegExp("(^|\\s)(" + escape(options.excludeTags).replace(spaceR, " ").split(" ").join("|") + ")(\\s|$)", "i");
            var has = options.tags && new RegExp("(^|\\s)(" + escape(options.tags).replace(spaceR, " ").split(" ").join("|") + ")(\\s|$)", "i");
            var action = options.action || defAction;

            if (!el && !not && !has && !exports.log) {
                exports.log = action;
                return;
            }

            var result = function (message, tag, type) {
                if (!((el && !el.test(type))          // if the expected log level is not satisfied
                    || (not && not.test(tag))         // if any of the excluded categories exist
                    || (has && !has.test(tag)))) {    // if at least one of the included categories doesn't exist
                        action(message, tag, type);
                    }

                result.next && result.next(message, tag, type);
            };
            result.next = exports.log;
            exports.log = result;
        },
        stopLog: function () {
            /// <signature helpKeyword="TVJS.Utilities.stopLog">
            /// <summary locid="TVJS.Utilities.stopLog">
            /// Removes the previously set up logger.
            /// </summary>
            /// </signature>
            exports.log = null;
        },
        formatLog: format
    });

    _Base.Namespace._moduleDefine(exports, "TVJS", {
        log: {
            get: function () {
                return TVJSLog;
            },
            set: function (value) {
                TVJSLog = value;
            }
        }
    });
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Core/_BaseUtils',[
    'exports',
    './_Global',
    './_Base',
    './_BaseCoreUtils',
    './_ErrorFromName',
    './_Resources',
    './_Trace',
    '../Promise',
    ], function baseUtilsInit(exports, _Global, _Base, _BaseCoreUtils, _ErrorFromName, _Resources, _Trace, Promise) {
    "use strict";

    var strings = {
        get notSupportedForProcessing() { return "Value is not supported within a declarative processing context, if you want it to be supported mark it using TVJS.Utilities.markSupportedForProcessing. The value was: '{0}'"; }
    };

    var requestAnimationWorker;
    var requestAnimationId = 0;
    var requestAnimationHandlers = {};
    var validation = false;
    var platform = _Global.navigator.platform;
    var isiOS = platform === "iPhone" || platform === "iPad" || platform === "iPod";

    function nop(v) {
        return v;
    }

    function getMemberFiltered(name, root, filter) {
        return name.split(".").reduce(function (currentNamespace, name) {
            if (currentNamespace) {
                return filter(currentNamespace[name]);
            }
            return null;
        }, root);
    }

    function getMember(name, root) {
        /// <signature helpKeyword="TVJS.Utilities.getMember">
        /// <summary locid="TVJS.Utilities.getMember">
        /// Gets the leaf-level type or namespace specified by the name parameter.
        /// </summary>
        /// <param name="name" locid="TVJS.Utilities.getMember_p:name">
        /// The name of the member.
        /// </param>
        /// <param name="root" locid="TVJS.Utilities.getMember_p:root">
        /// The root to start in. Defaults to the global object.
        /// </param>
        /// <returns type="Object" locid="TVJS.Utilities.getMember_returnValue">
        /// The leaf-level type or namespace in the specified parent namespace.
        /// </returns>
        /// </signature>
        if (!name) {
            return null;
        }
        return getMemberFiltered(name, root || _Global, nop);
    }

    function getCamelCasedName(styleName) {
        // special case -moz prefixed styles because their JS property name starts with Moz
        if (styleName.length > 0 && styleName.indexOf("-moz") !== 0 && styleName.charAt(0) === "-") {
            styleName = styleName.slice(1);
        }
        return styleName.replace(/\-[a-z]/g, function (x) { return x[1].toUpperCase(); });
    }

    function addPrefixToCamelCasedName(prefix, name) {
        if (prefix === "") {
            return name;
        }

        return prefix + name.charAt(0).toUpperCase() + name.slice(1);
    }

    function addPrefixToCSSName(prefix, name) {
        return (prefix !== "" ? "-" + prefix.toLowerCase() + "-" : "") + name;
    }

    function getBrowserStyleEquivalents() {
        // not supported in WebWorker
        if (!_Global.document) {
            return {};
        }

        var equivalents = {},
            docStyle = _Global.document.documentElement.style,
            stylePrefixesToTest = ["", "webkit", "ms", "Moz"],
            styles = ["animation",
                "transition",
                "transform",
                "animation-name",
                "animation-duration",
                "animation-delay",
                "animation-timing-function",
                "animation-iteration-count",
                "animation-direction",
                "animation-fill-mode",
                "grid-column",
                "grid-columns",
                "grid-column-span",
                "grid-row",
                "grid-rows",
                "grid-row-span",
                "transform-origin",
                "transition-property",
                "transition-duration",
                "transition-delay",
                "transition-timing-function",
                "scroll-snap-points-x",
                "scroll-snap-points-y",
                "scroll-chaining",
                "scroll-limit",
                "scroll-limit-x-max",
                "scroll-limit-x-min",
                "scroll-limit-y-max",
                "scroll-limit-y-min",
                "scroll-snap-type",
                "scroll-snap-x",
                "scroll-snap-y",
                "touch-action",
                "overflow-style",
                "user-select" // used for Template Compiler test
            ],
            prefixesUsedOnStyles = {};

        for (var i = 0, len = styles.length; i < len; i++) {
            var originalName = styles[i],
                styleToTest = getCamelCasedName(originalName);
            for (var j = 0, prefixLen = stylePrefixesToTest.length; j < prefixLen; j++) {
                var prefix = stylePrefixesToTest[j];
                var styleName = addPrefixToCamelCasedName(prefix, styleToTest);
                if (styleName in docStyle) {
                    // Firefox doesn't support dashed style names being get/set via script. (eg, something like element.style["transform-origin"] = "" wouldn't work).
                    // For each style translation we create, we'll make a CSS name version and a script name version for it so each can be used where appropriate.
                    var cssName = addPrefixToCSSName(prefix, originalName);
                    equivalents[originalName] = {
                        cssName: cssName,
                        scriptName: styleName
                    };
                    prefixesUsedOnStyles[originalName] = prefix;
                    break;
                }
            }
        }

        // Special cases:
        equivalents.animationPrefix = addPrefixToCSSName(prefixesUsedOnStyles["animation"], "");
        equivalents.keyframes = addPrefixToCSSName(prefixesUsedOnStyles["animation"], "keyframes");

        return equivalents;
    }

    function getBrowserEventEquivalents() {
        var equivalents = {};
        var animationEventPrefixes = ["", "WebKit"],
            animationEvents = [
                {
                    eventObject: "TransitionEvent",
                    events: ["transitionStart", "transitionEnd"]
                },
                {
                    eventObject: "AnimationEvent",
                    events: ["animationStart", "animationEnd"]
                }
            ];

        for (var i = 0, len = animationEvents.length; i < len; i++) {
            var eventToTest = animationEvents[i],
                chosenPrefix = "";
            for (var j = 0, prefixLen = animationEventPrefixes.length; j < prefixLen; j++) {
                var prefix = animationEventPrefixes[j];
                if ((prefix + eventToTest.eventObject) in _Global) {
                    chosenPrefix = prefix.toLowerCase();
                    break;
                }
            }
            for (var j = 0, eventsLen = eventToTest.events.length; j < eventsLen; j++) {
                var eventName = eventToTest.events[j];
                equivalents[eventName] = addPrefixToCamelCasedName(chosenPrefix, eventName);
                if (chosenPrefix === "") {
                    // Transition and animation events are case sensitive. When there's no prefix, the event name should be in lowercase.
                    // In IE, Chrome and Firefox, an event handler listening to transitionend will be triggered properly, but transitionEnd will not.
                    // When a prefix is provided, though, the event name needs to be case sensitive.
                    // IE and Firefox will trigger an animationend event handler correctly, but Chrome won't trigger webkitanimationend -- it has to be webkitAnimationEnd.
                    equivalents[eventName] = equivalents[eventName].toLowerCase();
                }
            }
        }

        // Non-standardized events
        equivalents["manipulationStateChanged"] = ("MSManipulationEvent" in _Global ? "ManipulationEvent" : null);
        return equivalents;
    }

    // Returns a function which, when called, will call *fn*. However,
    // if called multiple times, it will only call *fn* at most once every
    // *delay* milliseconds. Multiple calls during the throttling period
    // will be coalesced into a single call to *fn* with the arguments being
    // the ones from the last call received during the throttling period.
    // Note that, due to the throttling period, *fn* may be invoked asynchronously
    // relative to the time it was called so make sure its arguments are still valid
    // (for example, eventObjects will not be valid).
    //
    // Example usage. If you want your key down handler to run once every 100 ms,
    // you could do this:
    //   var onKeyDown = throttledFunction(function (keyCode) {
    //     // do something with keyCode
    //   });
    //   element.addEventListener("keydown", function (eventObject) { onKeyDown(eventObject.keyCode); });
    //
    function throttledFunction(delay, fn) {
        var throttlePromise = null;
        var pendingCallPromise = null;
        var nextContext = null;
        var nextArgs = null;

        function makeThrottlePromise() {
            return Promise.timeout(delay).then(function () {
                throttlePromise = null;
            });
        }

        return function () {
            if (pendingCallPromise) {
                nextContext = this;
                nextArgs = [].slice.call(arguments, 0);
            } else if (throttlePromise) {
                nextContext = this;
                nextArgs = [].slice.call(arguments, 0);
                pendingCallPromise = throttlePromise.then(function () {
                    var context = nextContext;
                    nextContext = null;
                    var args = nextArgs;
                    nextArgs = null;
                    throttlePromise = makeThrottlePromise();
                    pendingCallPromise = null;
                    fn.apply(context, args);
                });
            } else {
                throttlePromise = makeThrottlePromise();
                fn.apply(this, arguments);
            }
        };
    }

    _Base.Namespace._moduleDefine(exports, "TVJS.Utilities", {
        // Used for mocking in tests
        _setHasWinRT: {
            value: function (value) {
                _BaseCoreUtils.hasWinRT = value;
            },
            configurable: false,
            writable: false,
            enumerable: false
        },

        /// <field type="Boolean" locid="TVJS.Utilities.hasWinRT" helpKeyword="TVJS.Utilities.hasWinRT">Determine if WinRT is accessible in this script context.</field>
        hasWinRT: {
            get: function () { return _BaseCoreUtils.hasWinRT; },
            configurable: false,
            enumerable: true
        },

        // Used for mocking in tests
        _setIsiOS: {
            value: function (value) {
                isiOS = value;
            },
            configurable: false,
            writable: false,
            enumerable: false
        },

        _isiOS: {
            get: function () { return isiOS; },
            configurable: false,
            enumerable: true
        },

        _getMemberFiltered: getMemberFiltered,

        getMember: getMember,

        _browserStyleEquivalents: getBrowserStyleEquivalents(),
        _browserEventEquivalents: getBrowserEventEquivalents(),
        _getCamelCasedName: getCamelCasedName,

        ready: function ready(callback, async) {
            /// <signature helpKeyword="TVJS.Utilities.ready">
            /// <summary locid="TVJS.Utilities.ready">
            /// Ensures that the specified function executes only after the DOMContentLoaded event has fired
            /// for the current page.
            /// </summary>
            /// <returns type="TVJS.Promise" locid="TVJS.Utilities.ready_returnValue">A promise that completes after DOMContentLoaded has occurred.</returns>
            /// <param name="callback" optional="true" locid="TVJS.Utilities.ready_p:callback">
            /// A function that executes after DOMContentLoaded has occurred.
            /// </param>
            /// <param name="async" optional="true" locid="TVJS.Utilities.ready_p:async">
            /// If true, the callback is executed asynchronously.
            /// </param>
            /// </signature>
            return new Promise(function (c, e) {
                function complete() {
                    if (callback) {
                        try {
                            callback();
                            c();
                        }
                        catch (err) {
                            e(err);
                        }
                    } else {
                        c();
                    }
                }

                var readyState = ready._testReadyState;
                if (!readyState) {
                    if (_Global.document) {
                        readyState = _Global.document.readyState;
                    } else {
                        readyState = "complete";
                    }
                }
                if (readyState === "complete" || (_Global.document && _Global.document.body !== null)) {
                    if (async) {
                        setImmediate(function TVJS_Utilities_ready() {
                            complete();
                        });
                    } else {
                        complete();
                    }
                } else {
                    _Global.addEventListener("DOMContentLoaded", complete, false);
                }
            });
        },

        /// <field type="Boolean" locid="TVJS.Utilities.strictProcessing" helpKeyword="TVJS.Utilities.strictProcessing">Determines if strict declarative processing is enabled in this script context.</field>
        strictProcessing: {
            get: function () { return true; },
            configurable: false,
            enumerable: true,
        },

        markSupportedForProcessing: {
            value: _BaseCoreUtils.markSupportedForProcessing,
            configurable: false,
            writable: false,
            enumerable: true
        },

        requireSupportedForProcessing: {
            value: function (value) {
                /// <signature helpKeyword="TVJS.Utilities.requireSupportedForProcessing">
                /// <summary locid="TVJS.Utilities.requireSupportedForProcessing">
                /// Asserts that the value is compatible with declarative processing, such as TVJS.UI.processAll
                /// or TVJS.Binding.processAll. If it is not compatible an exception will be thrown.
                /// </summary>
                /// <param name="value" type="Object" locid="TVJS.Utilities.requireSupportedForProcessing_p:value">
                /// The value to be tested for compatibility with declarative processing. If the
                /// value is a function it must be marked with a property 'supportedForProcessing'
                /// with a value of true.
                /// </param>
                /// <returns type="Object" locid="TVJS.Utilities.requireSupportedForProcessing_returnValue">
                /// The input value.
                /// </returns>
                /// </signature>
                var supportedForProcessing = true;

                supportedForProcessing = supportedForProcessing && value !== _Global;
                supportedForProcessing = supportedForProcessing && value !== _Global.location;
                supportedForProcessing = supportedForProcessing && !(value instanceof _Global.HTMLIFrameElement);
                supportedForProcessing = supportedForProcessing && !(typeof value === "function" && !value.supportedForProcessing);

                switch (_Global.frames.length) {
                    case 0:
                        break;

                    case 1:
                        supportedForProcessing = supportedForProcessing && value !== _Global.frames[0];
                        break;

                    default:
                        for (var i = 0, len = _Global.frames.length; supportedForProcessing && i < len; i++) {
                            supportedForProcessing = supportedForProcessing && value !== _Global.frames[i];
                        }
                        break;
                }

                if (supportedForProcessing) {
                    return value;
                }

                throw new _ErrorFromName("TVJS.Utilities.requireSupportedForProcessing", _Resources._formatString(strings.notSupportedForProcessing, value));
            },
            configurable: false,
            writable: false,
            enumerable: true
        },

        _setImmediate: _BaseCoreUtils._setImmediate,

        _requestAnimationFrame: _Global.requestAnimationFrame ? _Global.requestAnimationFrame.bind(_Global) : function (handler) {
            var handle = ++requestAnimationId;
            requestAnimationHandlers[handle] = handler;
            requestAnimationWorker = requestAnimationWorker || _Global.setTimeout(function () {
                var toProcess = requestAnimationHandlers;
                var now = Date.now();
                requestAnimationHandlers = {};
                requestAnimationWorker = null;
                Object.keys(toProcess).forEach(function (key) {
                    toProcess[key](now);
                });
            }, 16);
            return handle;
        },

        _cancelAnimationFrame: _Global.cancelAnimationFrame ? _Global.cancelAnimationFrame.bind(_Global) : function (handle) {
            delete requestAnimationHandlers[handle];
        },

        // Allows the browser to finish dispatching its current set of events before running
        // the callback.
        _yieldForEvents: _Global.setImmediate ? _Global.setImmediate.bind(_Global) : function (handler) {
            _Global.setTimeout(handler, 0);
        },

        // Allows the browser to notice a DOM modification before running the callback.
        _yieldForDomModification: _Global.setImmediate ? _Global.setImmediate.bind(_Global) : function (handler) {
            _Global.setTimeout(handler, 0);
        },

        _throttledFunction: throttledFunction,

        _shallowCopy: function _shallowCopy(a) {
            // Shallow copy a single object.
            return this._mergeAll([a]);
        },

        _merge: function _merge(a, b) {
            // Merge 2 objects together into a new object
            return this._mergeAll([a, b]);
        },

        _mergeAll: function _mergeAll(list) {
            // Merge a list of objects together
            var o = {};
            list.forEach(function (part) {
                Object.keys(part).forEach(function (k) {
                    o[k] = part[k];
                });
            });
            return o;
        },

        _getProfilerMarkIdentifier: function _getProfilerMarkIdentifier(element) {
            var profilerMarkIdentifier = "";
            if (element.id) {
                profilerMarkIdentifier += " id='" + element.id + "'";
            }
            if (element.className) {
                profilerMarkIdentifier += " class='" + element.className + "'";
            }
            return profilerMarkIdentifier;
        },

        _now: function _now() {
            return (_Global.performance && _Global.performance.now && _Global.performance.now()) || Date.now();
        },

        _traceAsyncOperationStarting: _Trace._traceAsyncOperationStarting,
        _traceAsyncOperationCompleted: _Trace._traceAsyncOperationCompleted,
        _traceAsyncCallbackStarting: _Trace._traceAsyncCallbackStarting,
        _traceAsyncCallbackCompleted: _Trace._traceAsyncCallbackCompleted,

        _version: "4.2.0"
    });

    _Base.Namespace._moduleDefine(exports, "TVJS", {
        validation: {
            get: function () {
                return validation;
            },
            set: function (value) {
                validation = value;
            }
        }
    });

    // strictProcessing also exists as a module member
    _Base.Namespace.define("TVJS", {
        strictProcessing: {
            value: function () {
                /// <signature helpKeyword="TVJS.strictProcessing">
                /// <summary locid="TVJS.strictProcessing">
                /// Strict processing is always enforced, this method has no effect.
                /// </summary>
                /// </signature>
            },
            configurable: false,
            writable: false,
            enumerable: false
        }
    });
});


define('TVJS/Core',[
    './Core/_Base',
    './Core/_BaseCoreUtils',
    './Core/_BaseUtils',
    './Core/_ErrorFromName',
    './Core/_Events',
    './Core/_Global',
    './Core/_Log',
    './Core/_Resources',
    './Core/_Trace',
    './Core/_WinRT'
    ], function () {
    // Wrapper module
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/_Signal',[
    './Core/_Base',
    './Promise/_StateMachine'
    ], function signalInit(_Base, _StateMachine) {
    "use strict";

    var SignalPromise = _Base.Class.derive(_StateMachine.PromiseStateMachine,
        function (cancel) {
            this._oncancel = cancel;
            this._setState(_StateMachine.state_created);
            this._run();
        }, {
            _cancelAction: function () { this._oncancel && this._oncancel(); },
            _cleanupAction: function () { this._oncancel = null; }
        }, {
            supportedForProcessing: false
        }
    );

    var Signal = _Base.Class.define(
        function Signal_ctor(oncancel) {
            this._promise = new SignalPromise(oncancel);
        }, {
            promise: {
                get: function () { return this._promise; }
            },

            cancel: function Signal_cancel() {
                this._promise.cancel();
            },
            complete: function Signal_complete(value) {
                this._promise._completed(value);
            },
            error: function Signal_error(value) {
                this._promise._error(value);
            },
            progress: function Signal_progress(value) {
                this._promise._progress(value);
            }
        }, {
            supportedForProcessing: false,
        }
    );

    _Base.Namespace.define("TVJS", {
        _Signal: Signal
    });

    return Signal;
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_Control',[
    'exports',
    '../Core/_Global',
    '../Core/_Base'
    ], function controlInit(exports, _Global, _Base) {
    "use strict";

    // not supported in WebWorker
    if (!_Global.document) {
        return;
    }

    function setOptions(control, options) {
        /// <signature helpKeyword="TVJS.UI.setOptions">
        /// <summary locid="TVJS.UI.setOptions">
        /// Adds the set of declaratively specified options (properties and events) to the specified control.
        /// If name of the options property begins with "on", the property value is a function and the control
        /// supports addEventListener. The setOptions method calls the addEventListener method on the control.
        /// </summary>
        /// <param name="control" type="Object" domElement="false" locid="TVJS.UI.setOptions_p:control">
        /// The control on which the properties and events are to be applied.
        /// </param>
        /// <param name="options" type="Object" domElement="false" locid="TVJS.UI.setOptions_p:options">
        /// The set of options that are specified declaratively.
        /// </param>
        /// </signature>
        _setOptions(control, options);
    }

    function _setOptions(control, options, eventsOnly) {
        if (typeof options === "object") {
            var keys = Object.keys(options);
            for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i];
                var value = options[key];
                if (key.length > 2) {
                    var ch1 = key[0];
                    var ch2 = key[1];
                    if ((ch1 === 'o' || ch1 === 'O') && (ch2 === 'n' || ch2 === 'N')) {
                        if (typeof value === "function") {
                            if (control.addEventListener) {
                                control.addEventListener(key.substr(2), value);
                                continue;
                            }
                        }
                    }
                }

                if (!eventsOnly) {
                    control[key] = value;
                }
            }
        }
    }

    _Base.Namespace._moduleDefine(exports, "TVJS.UI", {
        DOMEventMixin: _Base.Namespace._lazy(function () {
            return {
                _domElement: null,

                addEventListener: function (type, listener, useCapture) {
                    /// <signature helpKeyword="TVJS.UI.DOMEventMixin.addEventListener">
                    /// <summary locid="TVJS.UI.DOMEventMixin.addEventListener">
                    /// Adds an event listener to the control.
                    /// </summary>
                    /// <param name="type" type="String" locid="TVJS.UI.DOMEventMixin.addEventListener_p:type">
                    /// The type (name) of the event.
                    /// </param>
                    /// <param name="listener" type="Function" locid="TVJS.UI.DOMEventMixin.addEventListener_p:listener">
                    /// The listener to invoke when the event gets raised.
                    /// </param>
                    /// <param name="useCapture" type="Boolean" locid="TVJS.UI.DOMEventMixin.addEventListener_p:useCapture">
                    /// true to initiate capture; otherwise, false.
                    /// </param>
                    /// </signature>
                    (this.element || this._domElement).addEventListener(type, listener, useCapture || false);
                },
                dispatchEvent: function (type, eventProperties) {
                    /// <signature helpKeyword="TVJS.UI.DOMEventMixin.dispatchEvent">
                    /// <summary locid="TVJS.UI.DOMEventMixin.dispatchEvent">
                    /// Raises an event of the specified type, adding the specified additional properties.
                    /// </summary>
                    /// <param name="type" type="String" locid="TVJS.UI.DOMEventMixin.dispatchEvent_p:type">
                    /// The type (name) of the event.
                    /// </param>
                    /// <param name="eventProperties" type="Object" locid="TVJS.UI.DOMEventMixin.dispatchEvent_p:eventProperties">
                    /// The set of additional properties to be attached to the event object when the event is raised.
                    /// </param>
                    /// <returns type="Boolean" locid="TVJS.UI.DOMEventMixin.dispatchEvent_returnValue">
                    /// true if preventDefault was called on the event, otherwise false.
                    /// </returns>
                    /// </signature>
                    var eventValue = _Global.document.createEvent("Event");
                    eventValue.initEvent(type, false, false);
                    eventValue.detail = eventProperties;
                    if (typeof eventProperties === "object") {
                        Object.keys(eventProperties).forEach(function (key) {
                            eventValue[key] = eventProperties[key];
                        });
                    }
                    return (this.element || this._domElement).dispatchEvent(eventValue);
                },
                removeEventListener: function (type, listener, useCapture) {
                    /// <signature helpKeyword="TVJS.UI.DOMEventMixin.removeEventListener">
                    /// <summary locid="TVJS.UI.DOMEventMixin.removeEventListener">
                    /// Removes an event listener from the control.
                    /// </summary>
                    /// <param name="type" type="String" locid="TVJS.UI.DOMEventMixin.removeEventListener_p:type">
                    /// The type (name) of the event.
                    /// </param>
                    /// <param name="listener" type="Function" locid="TVJS.UI.DOMEventMixin.removeEventListener_p:listener">
                    /// The listener to remove.
                    /// </param>
                    /// <param name="useCapture" type="Boolean" locid="TVJS.UI.DOMEventMixin.removeEventListener_p:useCapture">
                    /// true to initiate capture; otherwise, false.
                    /// </param>
                    /// </signature>
                    (this.element || this._domElement).removeEventListener(type, listener, useCapture || false);
                }
            };
        }),

        setOptions: setOptions,

        _setOptions: _setOptions
    });

});


// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_ElementUtilities',[
    'exports',
    '../Core/_Global',
    '../Core/_Base',
    '../Core/_BaseUtils',
    '../Core/_WinRT',
    '../Promise'
], function elementUtilities(exports, _Global, _Base, _BaseUtils, _WinRT, Promise) {
    "use strict";

    // not supported in WebWorker
    if (!_Global.document) {
        return;
    }

    var _zoomToDuration = 167;
    
    // Firefox's implementation of getComputedStyle returns null when called within
    // an iframe that is display:none. This is a bug: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    // _getComputedStyle is a helper which is guaranteed to return an object whose keys
    // map to strings.
    var defaultComputedStyle = null;
    function getDefaultComputedStyle() {
        if (!defaultComputedStyle) {
            defaultComputedStyle = {};
            Object.keys(_Global.CSS2Properties.prototype).forEach(function (cssProperty) {
                defaultComputedStyle[cssProperty] = "";
            });
        }
        return defaultComputedStyle;
    }
    function _getComputedStyle(element, pseudoElement) {
        // jscs:disable disallowDirectGetComputedStyle
        return _Global.getComputedStyle(element, pseudoElement) || getDefaultComputedStyle();
        // jscs:enable disallowDirectGetComputedStyle
    }

    function removeEmpties(arr) {
        var len = arr.length;
        for (var i = len - 1; i >= 0; i--) {
            if (!arr[i]) {
                arr.splice(i, 1);
                len--;
            }
        }
        return len;
    }

    function getClassName(e) {
        var name = e.className || "";
        if (typeof (name) === "string") {
            return name;
        } else {
            return name.baseVal || "";
        }
    }
    function setClassName(e, value) {
        // SVG elements (which use e.className.baseVal) are never undefined,
        // so this logic makes the comparison a bit more compact.
        //
        var name = e.className || "";
        if (typeof (name) === "string") {
            e.className = value;
        } else {
            e.className.baseVal = value;
        }
        return e;
    }
    function addClass(e, name) {
        /// <signature helpKeyword="TVJS.Utilities.addClass">
        /// <summary locid="TVJS.Utilities.addClass">
        /// Adds the specified class(es) to the specified element. Multiple classes can be added using space delimited names.
        /// </summary>
        /// <param name="e" type="HTMLElement" locid="TVJS.Utilities.addClass_p:e">
        /// The element to which to add the class.
        /// </param>
        /// <param name="name" type="String" locid="TVJS.Utilities.addClass_p:name">
        /// The name of the class to add, multiple classes can be added using space delimited names
        /// </param>
        /// <returns type="HTMLElement" locid="TVJS.Utilities.addClass_returnValue">
        /// The element.
        /// </returns>
        /// </signature>
        if (e.classList) {
            // Fastpath: adding a single class, no need to string split the argument
            if (name.indexOf(" ") < 0) {
                e.classList.add(name);
            } else {
                var namesToAdd = name.split(" ");
                removeEmpties(namesToAdd);

                for (var i = 0, len = namesToAdd.length; i < len; i++) {
                    e.classList.add(namesToAdd[i]);
                }
            }
            return e;
        } else {
            var className = getClassName(e);
            var names = className.split(" ");
            var l = removeEmpties(names);
            var toAdd;

            // we have a fast path for the common case of a single name in the class name
            //
            if (name.indexOf(" ") >= 0) {
                var namesToAdd = name.split(" ");
                removeEmpties(namesToAdd);
                for (var i = 0; i < l; i++) {
                    var found = namesToAdd.indexOf(names[i]);
                    if (found >= 0) {
                        namesToAdd.splice(found, 1);
                    }
                }
                if (namesToAdd.length > 0) {
                    toAdd = namesToAdd.join(" ");
                }
            } else {
                var saw = false;
                for (var i = 0; i < l; i++) {
                    if (names[i] === name) {
                        saw = true;
                        break;
                    }
                }
                if (!saw) { toAdd = name; }

            }
            if (toAdd) {
                if (l > 0 && names[0].length > 0) {
                    setClassName(e, className + " " + toAdd);
                } else {
                    setClassName(e, toAdd);
                }
            }
            return e;
        }
    }
    function removeClass(e, name) {
        /// <signature helpKeyword="TVJS.Utilities.removeClass">
        /// <summary locid="TVJS.Utilities.removeClass">
        /// Removes the specified class from the specified element.
        /// </summary>
        /// <param name="e" type="HTMLElement" locid="TVJS.Utilities.removeClass_p:e">
        /// The element from which to remove the class.
        /// </param>
        /// <param name="name" type="String" locid="TVJS.Utilities.removeClass_p:name">
        /// The name of the class to remove.
        /// </param>
        /// <returns type="HTMLElement" locid="TVJS.Utilities.removeClass_returnValue">
        /// The element.
        /// </returns>
        /// </signature>
        if (e.classList) {

            // Fastpath: Nothing to remove
            if (e.classList.length === 0) {
                return e;
            }
            var namesToRemove = name.split(" ");
            removeEmpties(namesToRemove);

            for (var i = 0, len = namesToRemove.length; i < len; i++) {
                e.classList.remove(namesToRemove[i]);
            }
            return e;
        } else {
            var original = getClassName(e);
            var namesToRemove;
            var namesToRemoveLen;

            if (name.indexOf(" ") >= 0) {
                namesToRemove = name.split(" ");
                namesToRemoveLen = removeEmpties(namesToRemove);
            } else {
                // early out for the case where you ask to remove a single
                // name and that name isn't found.
                //
                if (original.indexOf(name) < 0) {
                    return e;
                }
                namesToRemove = [name];
                namesToRemoveLen = 1;
            }
            var removed;
            var names = original.split(" ");
            var namesLen = removeEmpties(names);

            for (var i = namesLen - 1; i >= 0; i--) {
                if (namesToRemove.indexOf(names[i]) >= 0) {
                    names.splice(i, 1);
                    removed = true;
                }
            }

            if (removed) {
                setClassName(e, names.join(" "));
            }
            return e;
        }
    }
    function toggleClass(e, name) {
        /// <signature helpKeyword="TVJS.Utilities.toggleClass">
        /// <summary locid="TVJS.Utilities.toggleClass">
        /// Toggles (adds or removes) the specified class on the specified element.
        /// If the class is present, it is removed; if it is absent, it is added.
        /// </summary>
        /// <param name="e" type="HTMLElement" locid="TVJS.Utilities.toggleClass_p:e">
        /// The element on which to toggle the class.
        /// </param>
        /// <param name="name" type="String" locid="TVJS.Utilities.toggleClass_p:name">
        /// The name of the class to toggle.
        /// </param>
        /// <returns type="HTMLElement" locid="TVJS.Utilities.toggleClass_returnValue">
        /// The element.
        /// </returns>
        /// </signature>
        if (e.classList) {
            e.classList.toggle(name);
            return e;
        } else {
            var className = getClassName(e);
            var names = className.trim().split(" ");
            var l = names.length;
            var found = false;
            for (var i = 0; i < l; i++) {
                if (names[i] === name) {
                    found = true;
                }
            }
            if (!found) {
                if (l > 0 && names[0].length > 0) {
                    setClassName(e, className + " " + name);
                } else {
                    setClassName(e, className + name);
                }
            } else {
                setClassName(e, names.reduce(function (r, e) {
                    if (e === name) {
                        return r;
                    } else if (r && r.length > 0) {
                        return r + " " + e;
                    } else {
                        return e;
                    }
                }, ""));
            }
            return e;
        }
    }

    // Only set the attribute if its value has changed
    function setAttribute(element, attribute, value) {
        if (element.getAttribute(attribute) !== "" + value) {
            element.setAttribute(attribute, value);
        }
    }

    function _clamp(value, lowerBound, upperBound, defaultValue) {
        var n = Math.max(lowerBound, Math.min(upperBound, +value));
        return n === 0 ? 0 : n || Math.max(lowerBound, Math.min(upperBound, defaultValue));
    }
    var _pixelsRE = /^-?\d+\.?\d*(px)?$/i;
    var _numberRE = /^-?\d+/i;
    function convertToPixels(element, value) {
        /// <signature helpKeyword="TVJS.Utilities.convertToPixels">
        /// <summary locid="TVJS.Utilities.convertToPixels">
        /// Converts a CSS positioning string for the specified element to pixels.
        /// </summary>
        /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.convertToPixels_p:element">
        /// The element.
        /// </param>
        /// <param name="value" type="String" locid="TVJS.Utilities.convertToPixels_p:value">
        /// The CSS positioning string.
        /// </param>
        /// <returns type="Number" locid="TVJS.Utilities.convertToPixels_returnValue">
        /// The number of pixels.
        /// </returns>
        /// </signature>
        if (!_pixelsRE.test(value) && _numberRE.test(value)) {
            var previousValue = element.style.left;

            element.style.left = value;
            value = element.style.pixelLeft;

            element.style.left = previousValue;

            return value;
        } else {
            return Math.round(parseFloat(value)) || 0;
        }
    }

    function getDimension(element, property) {
        return convertToPixels(element, _getComputedStyle(element, null)[property]);
    }

    function _convertToPrecisePixels(value) {
        return parseFloat(value) || 0;
    }
    function _getPreciseDimension(element, property) {
        return _convertToPrecisePixels(_getComputedStyle(element, null)[property]);
    }
    function _getPreciseMargins(element) {
        var style = _getComputedStyle(element);
        return {
            top: _convertToPrecisePixels(style.marginTop),
            right: _convertToPrecisePixels(style.marginRight),
            bottom: _convertToPrecisePixels(style.marginBottom),
            left: _convertToPrecisePixels(style.marginLeft),
        };
    }

    var _MSGestureEvent = _Global.MSGestureEvent || {
        MSGESTURE_FLAG_BEGIN: 1,
        MSGESTURE_FLAG_CANCEL: 4,
        MSGESTURE_FLAG_END: 2,
        MSGESTURE_FLAG_INERTIA: 8,
        MSGESTURE_FLAG_NONE: 0
    };

    var _MSManipulationEvent = _Global.MSManipulationEvent || {
        MS_MANIPULATION_STATE_ACTIVE: 1,
        MS_MANIPULATION_STATE_CANCELLED: 6,
        MS_MANIPULATION_STATE_COMMITTED: 7,
        MS_MANIPULATION_STATE_DRAGGING: 5,
        MS_MANIPULATION_STATE_INERTIA: 2,
        MS_MANIPULATION_STATE_PRESELECT: 3,
        MS_MANIPULATION_STATE_SELECTING: 4,
        MS_MANIPULATION_STATE_STOPPED: 0
    };

    var _MSPointerEvent = _Global.MSPointerEvent || {
        MSPOINTER_TYPE_TOUCH: "touch",
        MSPOINTER_TYPE_PEN: "pen",
        MSPOINTER_TYPE_MOUSE: "mouse",
    };

    // Helpers for managing element._eventsMap for custom events
    //

    function addListenerToEventMap(element, type, listener, useCapture, data) {
        var eventNameLowercase = type.toLowerCase();
        if (!element._eventsMap) {
            element._eventsMap = {};
        }
        if (!element._eventsMap[eventNameLowercase]) {
            element._eventsMap[eventNameLowercase] = [];
        }
        element._eventsMap[eventNameLowercase].push({
            listener: listener,
            useCapture: useCapture,
            data: data
        });
    }

    function removeListenerFromEventMap(element, type, listener, useCapture) {
        var eventNameLowercase = type.toLowerCase();
        var mappedEvents = element._eventsMap && element._eventsMap[eventNameLowercase];
        if (mappedEvents) {
            for (var i = mappedEvents.length - 1; i >= 0; i--) {
                var mapping = mappedEvents[i];
                if (mapping.listener === listener && (!!useCapture === !!mapping.useCapture)) {
                    mappedEvents.splice(i, 1);
                    return mapping;
                }
            }
        }
        return null;
    }

    function lookupListeners(element, type) {
        var eventNameLowercase = type.toLowerCase();
        return element._eventsMap && element._eventsMap[eventNameLowercase] && element._eventsMap[eventNameLowercase].slice(0) || [];
    }

    // Custom focusin/focusout events
    // Generally, use these instead of using the browser's blur/focus/focusout/focusin events directly.
    // However, this doesn't support the window object. If you need to listen to focus events on the window,
    // use the browser's events directly.
    //
    // In order to send our custom focusin/focusout events synchronously on every browser, we feature detect
    // for native "focusin" and "focusout" since every browser that supports them will fire them synchronously.
    // Every browser in our support matrix, except for IE, also fires focus/blur synchronously, we fall back to
    // those events in browsers such as Firefox that do not have native support for focusin/focusout.

    function bubbleEvent(element, type, eventObject) {
        while (element) {
            var handlers = lookupListeners(element, type);
            for (var i = 0, len = handlers.length; i < len; i++) {
                handlers[i].listener.call(element, eventObject);
            }

            element = element.parentNode;
        }
    }

    function prepareFocusEvent(eventObject) {
        // If an iframe is involved, then relatedTarget should be null.
        if (eventObject.relatedTarget && eventObject.relatedTarget.tagName === "IFRAME" ||
                eventObject.target && eventObject.target.tagName === "IFRAME") {
            eventObject.relatedTarget = null;
        }

        return eventObject;
    }

    var nativeSupportForFocusIn = "onfocusin" in _Global.document.documentElement;
    var activeElement = null;
    _Global.addEventListener(nativeSupportForFocusIn ? "focusout" : "blur", function (eventObject) {
        // Fires focusout when focus move to another window or into an iframe.
        if (eventObject.target === _Global) {
            var previousActiveElement = activeElement;
            if (previousActiveElement) {
                bubbleEvent(previousActiveElement, "focusout", prepareFocusEvent({
                    type: "focusout",
                    target: previousActiveElement,
                    relatedTarget: null
                }));
            }
            activeElement = null;
        }
    });

    _Global.document.documentElement.addEventListener(nativeSupportForFocusIn ? "focusin" : "focus", function (eventObject) {
        var previousActiveElement = activeElement;
        activeElement = eventObject.target;
        if (previousActiveElement) {
            bubbleEvent(previousActiveElement, "focusout", prepareFocusEvent({
                type: "focusout",
                target: previousActiveElement,
                relatedTarget: activeElement
            }));
        }
        if (activeElement) {
            bubbleEvent(activeElement, "focusin", prepareFocusEvent({
                type: "focusin",
                target: activeElement,
                relatedTarget: previousActiveElement
            }));
        }
    }, true);

    function registerBubbleListener(element, type, listener, useCapture) {
        if (useCapture) {
            throw "This custom TVJS event only supports bubbling";
        }
        addListenerToEventMap(element, type, listener, useCapture);
    }

    // Custom pointer events
    //

    // Sets the properties in *overrideProperties* on the object. Delegates all other
    // property accesses to *eventObject*.
    //
    // The purpose of PointerEventProxy is that it allows us to customize properties on
    // an eventObject despite those properties being unwritable and unconfigurable.
    var PointerEventProxy = function (eventObject, overrideProperties) {
        overrideProperties = overrideProperties || {};
        this.__eventObject = eventObject;
        var that = this;
        Object.keys(overrideProperties).forEach(function (propertyName) {
            Object.defineProperty(that, propertyName, {
                value: overrideProperties[propertyName]
            });
        });
    };

    // Define PointerEventProxy properties which should be delegated to the original eventObject.
    [
        "altKey", "AT_TARGET", "bubbles", "BUBBLING_PHASE", "button", "buttons",
        "cancelable", "cancelBubble", "CAPTURING_PHASE", "clientX", "clientY",
        "ctrlKey", "currentTarget", "defaultPrevented", "detail", "eventPhase",
        "fromElement", "getModifierState", "height", "hwTimestamp", "initEvent",
        "initMouseEvent", "initPointerEvent", "initUIEvent", "isPrimary", "isTrusted",
        "layerX", "layerY", "metaKey", "offsetX", "offsetY", "pageX", "pageY",
        "pointerId", "pointerType", "pressure", "preventDefault", "relatedTarget",
        "rotation", "screenX", "screenY", "shiftKey", "srcElement", "stopImmediatePropagation",
        "stopPropagation", "target", "tiltX", "tiltY", "timeStamp", "toElement", "type",
        "view", "which", "width", "x", "y", "_normalizedType", "_fakedBySemanticZoom"
    ].forEach(function (propertyName) {
        Object.defineProperty(PointerEventProxy.prototype, propertyName, {
            get: function () {
                var value = this.__eventObject[propertyName];
                return typeof value === "function" ? value.bind(this.__eventObject) : value;
            },
            configurable: true
        });
    });

    function touchEventTranslator(callback, eventObject) {
        var changedTouches = eventObject.changedTouches,
            retVal = null;

        if (!changedTouches) {
            return retVal;
        }

        for (var i = 0, len = changedTouches.length; i < len; i++) {
            var touchObject = changedTouches[i];
            var pointerEventObject = new PointerEventProxy(eventObject, {
                pointerType: _MSPointerEvent.MSPOINTER_TYPE_TOUCH,
                pointerId: touchObject.identifier,
                isPrimary: i === 0,
                screenX: touchObject.screenX,
                screenY: touchObject.screenY,
                clientX: touchObject.clientX,
                clientY: touchObject.clientY,
                pageX: touchObject.pageX,
                pageY: touchObject.pageY,
                radiusX: touchObject.radiusX,
                radiusY: touchObject.radiusY,
                rotationAngle: touchObject.rotationAngle,
                force: touchObject.force,
                _currentTouch: touchObject
            });
            var newRetVal = callback(pointerEventObject);
            retVal = retVal || newRetVal;
        }
        return retVal;
    }

    function mouseEventTranslator(callback, eventObject) {
        eventObject.pointerType = _MSPointerEvent.MSPOINTER_TYPE_MOUSE;
        eventObject.pointerId = -1;
        eventObject.isPrimary = true;
        return callback(eventObject);
    }

    function mspointerEventTranslator(callback, eventObject) {
        return callback(eventObject);
    }

    var eventTranslations = {
        pointerdown: {
            touch: "touchstart",
            mspointer: "MSPointerDown",
            mouse: "mousedown"
        },
        pointerup: {
            touch: "touchend",
            mspointer: "MSPointerUp",
            mouse: "mouseup"
        },
        pointermove: {
            touch: "touchmove",
            mspointer: "MSPointerMove",
            mouse: "mousemove"
        },
        pointerenter: {
            touch: "touchenter",
            mspointer: "MSPointerEnter",
            mouse: "mouseenter"
        },
        pointerover: {
            touch: null,
            mspointer: "MSPointerOver",
            mouse: "mouseover"
        },
        pointerout: {
            touch: "touchleave",
            mspointer: "MSPointerOut",
            mouse: "mouseout"
        },
        pointercancel: {
            touch: "touchcancel",
            mspointer: "MSPointerCancel",
            mouse: null
        }
    };

    function registerPointerEvent(element, type, callback, capture) {
        var eventNameLowercase = type.toLowerCase();

        var mouseWrapper,
            touchWrapper,
            mspointerWrapper;
        var translations = eventTranslations[eventNameLowercase];

        // Browsers fire a touch event and then a mouse event when the input is touch. touchHandled is used to prevent invoking the pointer callback twice.
        var touchHandled;

        // If we are in IE10, we should use MSPointer as it provides a better interface than touch events
        if (_Global.MSPointerEvent) {
            mspointerWrapper = function (eventObject) {
                eventObject._normalizedType = eventNameLowercase;
                touchHandled = true;
                return mspointerEventTranslator(callback, eventObject);
            };
            element.addEventListener(translations.mspointer, mspointerWrapper, capture);
        } else {
            // Otherwise, use a mouse and touch event
            if (translations.mouse) {
                mouseWrapper = function (eventObject) {
                    eventObject._normalizedType = eventNameLowercase;
                    if (!touchHandled) {
                        return mouseEventTranslator(callback, eventObject);
                    }
                    touchHandled = false;
                };
                element.addEventListener(translations.mouse, mouseWrapper, capture);
            }
            if (translations.touch) {
                touchWrapper = function (eventObject) {
                    eventObject._normalizedType = eventNameLowercase;
                    touchHandled = true;
                    return touchEventTranslator(callback, eventObject);
                };
                element.addEventListener(translations.touch, touchWrapper, capture);
            }
        }

        addListenerToEventMap(element, type, callback, capture, {
            mouseWrapper: mouseWrapper,
            touchWrapper: touchWrapper,
            mspointerWrapper: mspointerWrapper
        });
    }

    function unregisterPointerEvent(element, type, callback, capture) {
        var eventNameLowercase = type.toLowerCase();

        var mapping = removeListenerFromEventMap(element, type, callback, capture);
        if (mapping) {
            var translations = eventTranslations[eventNameLowercase];
            if (mapping.data.mouseWrapper) {
                element.removeEventListener(translations.mouse, mapping.data.mouseWrapper, capture);
            }
            if (mapping.data.touchWrapper) {
                element.removeEventListener(translations.touch, mapping.data.touchWrapper, capture);
            }
            if (mapping.data.mspointerWrapper) {
                element.removeEventListener(translations.mspointer, mapping.data.mspointerWrapper, capture);
            }
        }
    }

    // Custom events dispatch table. Event names should be lowercased.
    //

    var customEvents = {
        focusout: {
            register: registerBubbleListener,
            unregister: removeListenerFromEventMap
        },
        focusin: {
            register: registerBubbleListener,
            unregister: removeListenerFromEventMap
        }
    };
    if (!_Global.PointerEvent) {
        var pointerEventEntry = {
            register: registerPointerEvent,
            unregister: unregisterPointerEvent
        };

        customEvents.pointerdown = pointerEventEntry;
        customEvents.pointerup = pointerEventEntry;
        customEvents.pointermove = pointerEventEntry;
        customEvents.pointerenter = pointerEventEntry;
        customEvents.pointerover = pointerEventEntry;
        customEvents.pointerout = pointerEventEntry;
        customEvents.pointercancel = pointerEventEntry;
    }

    // The MutationObserverShim only supports the following configuration:
    //  attributes
    //  attributeFilter
    var MutationObserverShim = _Base.Class.define(
        function MutationObserverShim_ctor(callback) {
            this._callback = callback;
            this._toDispose = [];
            this._attributeFilter = [];
            this._scheduled = false;
            this._pendingChanges = [];
            this._observerCount = 0;
            this._handleCallback = this._handleCallback.bind(this);
            this._targetElements = [];
        },
        {
            observe: function MutationObserverShim_observe(element, configuration) {
                if (this._targetElements.indexOf(element) === -1) {
                    this._targetElements.push(element);
                }
                this._observerCount++;
                if (configuration.attributes) {
                    this._addRemovableListener(element, "DOMAttrModified", this._handleCallback);
                }
                if (configuration.attributeFilter) {
                    this._attributeFilter = configuration.attributeFilter;
                }
            },
            disconnect: function MutationObserverShim_disconnect() {
                this._observerCount = 0;
                this._targetElements = [];
                this._toDispose.forEach(function (disposeFunc) {
                    disposeFunc();
                });
            },
            _addRemovableListener: function MutationObserverShim_addRemovableListener(target, event, listener) {
                target.addEventListener(event, listener);
                this._toDispose.push(function () {
                    target.removeEventListener(event, listener);
                });
            },
            _handleCallback: function MutationObserverShim_handleCallback(evt) {

                // prevent multiple events from firing when nesting observers
                evt.stopPropagation();

                var attrName = evt.attrName;
                if (this._attributeFilter.length && this._attributeFilter.indexOf(attrName) === -1) {
                    return;
                }

                // subtree:true is not currently supported
                if (this._targetElements.indexOf(evt.target) === -1) {
                    return;
                }

                var isAriaMutation = attrName.indexOf("aria") >= 0;

                // DOM mutation events use different naming for this attribute
                if (attrName === 'tabindex') {
                    attrName = 'tabIndex';
                }

                this._pendingChanges.push({
                    type: 'attributes',
                    target: evt.target,
                    attributeName: attrName
                });

                if (this._observerCount === 1 && !isAriaMutation) {
                    this._dispatchEvent();
                } else if (this._scheduled === false) {
                    this._scheduled = true;
                    _BaseUtils._setImmediate(this._dispatchEvent.bind(this));
                }

            },
            _dispatchEvent: function MutationObserverShim_dispatchEvent() {
                try {
                    this._callback(this._pendingChanges);
                }
                finally {
                    this._pendingChanges = [];
                    this._scheduled = false;
                }
            }
        },
        {
            _isShim: true
        }
    );

    var _MutationObserver = _Global.MutationObserver || MutationObserverShim;

    // Lazily init singleton on first access.
    var _resizeNotifier = null;

    // Class to provide a global listener for window.onresize events.
    // This keeps individual elements from having to listen to window.onresize
    // and having to dispose themselves to avoid leaks.
    var ResizeNotifier = _Base.Class.define(
        function ElementResizer_ctor() {
            _Global.addEventListener("resize", this._handleResize.bind(this));
        },
        {
            subscribe: function ElementResizer_subscribe(element, handler) {
                element.addEventListener(this._resizeEvent, handler);
                addClass(element, this._resizeClass);
            },
            unsubscribe: function ElementResizer_unsubscribe(element, handler) {
                removeClass(element, this._resizeClass);
                element.removeEventListener(this._resizeEvent, handler);
            },
            _handleResize: function ElementResizer_handleResize() {
                var resizables = _Global.document.querySelectorAll('.' + this._resizeClass);
                var length = resizables.length;
                for (var i = 0; i < length; i++) {
                    var event = _Global.document.createEvent("Event");
                    event.initEvent(this._resizeEvent, false, true);
                    resizables[i].dispatchEvent(event);
                }
            },
            _resizeClass: { get: function () { return 'tv-element-resize'; } },
            _resizeEvent: { get: function () { return 'TVJSElementResize'; } }
        }
    );

    // - object: The object on which GenericListener will listen for events.
    // - objectName: A string representing the name of *object*. This will be
    //   incorporated into the names of the events and classNames created by
    //   GenericListener.
    // - options
    //   - registerThruTVJSCustomEvents: If true, will register for events using
    //     _exports._addEventListener so that you can take advantage of TVJS's custom
    //     events (e.g. focusin, pointer*). Otherwise, registers directly on *object*
    //     using its add/removeEventListener methods.
    var GenericListener = _Base.Class.define(
        function GenericListener_ctor(objectName, object, options) {
            options = options || {};
            this.registerThruTVJSCustomEvents = !!options.registerThruTVJSCustomEvents;

            this.objectName = objectName;
            this.object = object;
            this.capture = {};
            this.bubble = {};
        },
        {
            addEventListener: function GenericListener_addEventListener(element, name, listener, capture) {
                name = name.toLowerCase();
                var handlers = this._getHandlers(capture);
                var handler = handlers[name];

                if (!handler) {
                    handler = this._getListener(name, capture);
                    handler.refCount = 0;
                    handlers[name] = handler;

                    if (this.registerThruTVJSCustomEvents) {
                        exports._addEventListener(this.object, name, handler, capture);
                    } else {
                        this.object.addEventListener(name, handler, capture);
                    }
                }

                handler.refCount++;
                element.addEventListener(this._getEventName(name, capture), listener);
                addClass(element, this._getClassName(name, capture));
            },
            removeEventListener: function GenericListener_removeEventListener(element, name, listener, capture) {
                name = name.toLowerCase();
                var handlers = this._getHandlers(capture);
                var handler = handlers[name];

                if (handler) {
                    handler.refCount--;
                    if (handler.refCount === 0) {
                        if (this.registerThruTVJSCustomEvents) {
                            exports._removeEventListener(this.object, name, handler, capture);
                        } else {
                            this.object.removeEventListener(name, handler, capture);
                        }
                        delete handlers[name];
                    }
                }

                removeClass(element, this._getClassName(name, capture));
                element.removeEventListener(this._getEventName(name, capture), listener);
            },

            _getHandlers: function GenericListener_getHandlers(capture) {
                if (capture) {
                    return this.capture;
                } else {
                    return this.bubble;
                }
            },

            _getClassName: function GenericListener_getClassName(name, capture) {
                var captureSuffix = capture ? 'capture' : 'bubble';
                return 'tv-' + this.objectName.toLowerCase() + '-event-' + name + captureSuffix;
            },

            _getEventName: function GenericListener_getEventName(name, capture) {
                var captureSuffix = capture ? 'capture' : 'bubble';
                return 'TVJS' + this.objectName + 'Event-' + name + captureSuffix;
            },

            _getListener: function GenericListener_getListener(name, capture) {
                var listener = function GenericListener_generatedListener(ev) {

                    var targets = _Global.document.querySelectorAll('.' + this._getClassName(name, capture));
                    var length = targets.length;
                    var handled = false;
                    for (var i = 0; i < length; i++) {
                        var event = _Global.document.createEvent("Event");
                        event.initEvent(this._getEventName(name, capture), false, true);
                        event.detail = { originalEvent: ev };
                        var doDefault = targets[i].dispatchEvent(event);
                        handled = handled || !doDefault;
                    }
                    return handled;
                };

                return listener.bind(this);
            }
        }
    );

    var determinedRTLEnvironment = false,
        usingWebkitScrollCoordinates = false,
        usingFirefoxScrollCoordinates = false;
    function determineRTLEnvironment() {
        var element = _Global.document.createElement("div");
        element.style.direction = "rtl";
        element.innerHTML = "" +
            "<div style='width: 100px; height: 100px; overflow: scroll; visibility:hidden'>" +
                "<div style='width: 10000px; height: 100px;'></div>" +
            "</div>";
        _Global.document.body.appendChild(element);
        var elementScroller = element.firstChild;
        if (elementScroller.scrollLeft > 0) {
            usingWebkitScrollCoordinates = true;
        }
        elementScroller.scrollLeft += 100;
        if (elementScroller.scrollLeft === 0) {
            usingFirefoxScrollCoordinates = true;
        }
        _Global.document.body.removeChild(element);
        determinedRTLEnvironment = true;
    }

    function getAdjustedScrollPosition(element) {
        var computedStyle = _getComputedStyle(element),
            scrollLeft = element.scrollLeft;
        if (computedStyle.direction === "rtl") {
            if (!determinedRTLEnvironment) {
                determineRTLEnvironment();
            }
            if (usingWebkitScrollCoordinates) {
                scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;
            }
            scrollLeft = Math.abs(scrollLeft);
        }

        return {
            scrollLeft: scrollLeft,
            scrollTop: element.scrollTop
        };
    }

    function setAdjustedScrollPosition(element, scrollLeft, scrollTop) {
        if (scrollLeft !== undefined) {
            var computedStyle = _getComputedStyle(element);
            if (computedStyle.direction === "rtl") {
                if (!determinedRTLEnvironment) {
                    determineRTLEnvironment();
                }
                if (usingFirefoxScrollCoordinates) {
                    scrollLeft = -scrollLeft;
                } else if (usingWebkitScrollCoordinates) {
                    scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;
                }
            }
            element.scrollLeft = scrollLeft;
        }

        if (scrollTop !== undefined) {
            element.scrollTop = scrollTop;
        }
    }

    function getScrollPosition(element) {
        /// <signature helpKeyword="TVJS.Utilities.getScrollPosition">
        /// <summary locid="TVJS.Utilities.getScrollPosition">
        /// Gets the scrollLeft and scrollTop of the specified element, adjusting the scrollLeft to change from browser specific coordinates to logical coordinates when in RTL.
        /// </summary>
        /// <param name="element" type="HTMLElement" domElement="true" locid="TVJS.Utilities.getScrollPosition_p:element">
        /// The element.
        /// </param>
        /// <returns type="Object" locid="TVJS.Utilities.getScrollPosition_returnValue">
        /// An object with two properties: scrollLeft and scrollTop
        /// </returns>
        /// </signature>
        return getAdjustedScrollPosition(element);
    }

    function setScrollPosition(element, position) {
        /// <signature helpKeyword="TVJS.Utilities.setScrollPosition">
        /// <summary locid="TVJS.Utilities.setScrollPosition">
        /// Sets the scrollLeft and scrollTop of the specified element, changing the scrollLeft from logical coordinates to browser-specific coordinates when in RTL.
        /// </summary>
        /// <param name="element" type="HTMLElement" domElement="true" locid="TVJS.Utilities.setScrollPosition_p:element">
        /// The element.
        /// </param>
        /// <param name="position" type="Object" domElement="true" locid="TVJS.Utilities.setScrollPosition_p:position">
        /// The element.
        /// </param>
        /// </signature>
        position = position || {};
        setAdjustedScrollPosition(element, position.scrollLeft, position.scrollTop);
    }

    // navigator.msManipulationViewsEnabled tells us whether snap points work or not regardless of whether the style properties exist, however,
    // on Phone WWAs, this check returns false even though snap points are supported. To work around this bug, we check for the presence of
    // 'MSAppHost' in the user agent string which indicates that we are in a WWA environment; all WWA environments support snap points.
    var supportsSnapPoints = _Global.navigator.msManipulationViewsEnabled || _Global.navigator.userAgent.indexOf("MSAppHost") >= 0;
    var supportsTouchDetection = !!(_Global.MSPointerEvent || _Global.TouchEvent);

    var uniqueElementIDCounter = 0;

    function uniqueID(e) {
        if (!(e.uniqueID || e._uniqueID)) {
            e._uniqueID = "element__" + (++uniqueElementIDCounter);
        }

        return e.uniqueID || e._uniqueID;
    }

    function ensureId(element) {
        if (!element.id) {
            element.id = uniqueID(element);
        }
    }

    function _getCursorPos(eventObject) {
        var docElement = _Global.document.documentElement;
        var docScrollPos = getScrollPosition(docElement);

        return {
            left: eventObject.clientX + (_Global.document.body.dir === "rtl" ? -docScrollPos.scrollLeft : docScrollPos.scrollLeft),
            top: eventObject.clientY + docElement.scrollTop
        };
    }

    function _getElementsByClasses(parent, classes) {
        var retVal = [];

        for (var i = 0, len = classes.length; i < len; i++) {
            var element = parent.querySelector("." + classes[i]);
            if (element) {
                retVal.push(element);
            }
        }
        return retVal;
    }

    var _selectionPartsSelector = ".tv-selectionborder, .tv-selectionbackground, .tv-selectioncheckmark, .tv-selectioncheckmarkbackground";
    var _dataKey = "_msDataKey";
    _Base.Namespace._moduleDefine(exports, "TVJS.Utilities", {
        _dataKey: _dataKey,

        _supportsSnapPoints: {
            get: function () {
                return supportsSnapPoints;
            }
        },

        _supportsTouchDetection: {
            get: function () {
                return supportsTouchDetection;
            }
        },

        _uniqueID: uniqueID,

        _ensureId: ensureId,

        _clamp: _clamp,

        _getCursorPos: _getCursorPos,

        _getElementsByClasses: _getElementsByClasses,

        _createGestureRecognizer: function () {
            if (_Global.MSGesture) {
                return new _Global.MSGesture();
            }

            var doNothing = function () {
            };
            return {
                addEventListener: doNothing,
                removeEventListener: doNothing,
                addPointer: doNothing,
                stop: doNothing
            };
        },

        _MSGestureEvent: _MSGestureEvent,
        _MSManipulationEvent: _MSManipulationEvent,

        _elementsFromPoint: function (x, y) {
            if (_Global.document.msElementsFromPoint) {
                return _Global.document.msElementsFromPoint(x, y);
            } else {
                var element = _Global.document.elementFromPoint(x, y);
                return element ? [element] : null;
            }
        },

        _matchesSelector: function _matchesSelector(element, selectorString) {
            var matchesSelector = element.matches
                    || element.msMatchesSelector
                    || element.mozMatchesSelector
                    || element.webkitMatchesSelector;
            return matchesSelector.call(element, selectorString);
        },

        _selectionPartsSelector: _selectionPartsSelector,

        _isSelectionRendered: function _isSelectionRendered(itemBox) {
            // The tree is changed at pointerDown but _selectedClass is added only when the user drags an item below the selection threshold so checking for _selectedClass is not reliable.
            return itemBox.querySelectorAll(_selectionPartsSelector).length > 0;
        },

        _addEventListener: function _addEventListener(element, type, listener, useCapture) {
            var eventNameLower = type && type.toLowerCase();
            var entry = customEvents[eventNameLower];
            var equivalentEvent = _BaseUtils._browserEventEquivalents[type];
            if (entry) {
                entry.register(element, type, listener, useCapture);
            } else if (equivalentEvent) {
                element.addEventListener(equivalentEvent, listener, useCapture);
            } else {
                element.addEventListener(type, listener, useCapture);
            }
        },

        _removeEventListener: function _removeEventListener(element, type, listener, useCapture) {
            var eventNameLower = type && type.toLowerCase();
            var entry = customEvents[eventNameLower];
            var equivalentEvent = _BaseUtils._browserEventEquivalents[type];
            if (entry) {
                entry.unregister(element, type, listener, useCapture);
            } else if (equivalentEvent) {
                element.removeEventListener(equivalentEvent, listener, useCapture);
            } else {
                element.removeEventListener(type, listener, useCapture);
            }
        },

        _initEventImpl: function (initType, event, eventType) {
            eventType = eventType.toLowerCase();
            var mapping = eventTranslations[eventType];
            if (mapping) {
                switch (initType.toLowerCase()) {
                    case "pointer":
                        if (!_Global.PointerEvent) {
                            arguments[2] = mapping.mspointer;
                        }
                        break;

                    default:
                        arguments[2] = mapping[initType.toLowerCase()];
                        break;
                }
            }
            event["init" + initType + "Event"].apply(event, Array.prototype.slice.call(arguments, 2));
        },

        _initMouseEvent: function (event) {
            this._initEventImpl.apply(this, ["Mouse", event].concat(Array.prototype.slice.call(arguments, 1)));
        },

        _initPointerEvent: function (event) {
            this._initEventImpl.apply(this, ["Pointer", event].concat(Array.prototype.slice.call(arguments, 1)));
        },

        _PointerEventProxy: PointerEventProxy,

        _bubbleEvent: bubbleEvent,

        _setPointerCapture: function (element, pointerId) {
            if (element.setPointerCapture) {
                element.setPointerCapture(pointerId);
            }
        },

        _releasePointerCapture: function (element, pointerId) {
            if (element.releasePointerCapture) {
                element.releasePointerCapture(pointerId);
            }
        },

        _MSPointerEvent: _MSPointerEvent,
        
        _getComputedStyle: _getComputedStyle,

        _zoomToDuration: _zoomToDuration,

        _zoomTo: function _zoomTo(element, args) {
            if (this._supportsSnapPoints && element.msZoomTo) {
                element.msZoomTo(args);
            } else {
                // Schedule to ensure that we're not running from within an event handler. For example, if running
                // within a focus handler triggered by TVJS.Utilities._setActive, scroll position will not yet be
                // restored.
                setImmediate(function () {
                    var initialPos = getAdjustedScrollPosition(element);
                    var effectiveScrollLeft = (typeof element._zoomToDestX === "number" ? element._zoomToDestX : initialPos.scrollLeft);
                    var effectiveScrollTop = (typeof element._zoomToDestY === "number" ? element._zoomToDestY : initialPos.scrollTop);
                    var cs = _getComputedStyle(element);
                    var scrollLimitX = element.scrollWidth - parseInt(cs.width, 10) - parseInt(cs.paddingLeft, 10) - parseInt(cs.paddingRight, 10);
                    var scrollLimitY = element.scrollHeight - parseInt(cs.height, 10) - parseInt(cs.paddingTop, 10) - parseInt(cs.paddingBottom, 10);

                    if (typeof args.contentX !== "number") {
                        args.contentX = effectiveScrollLeft;
                    }
                    if (typeof args.contentY !== "number") {
                        args.contentY = effectiveScrollTop;
                    }

                    var zoomToDestX = _clamp(args.contentX, 0, scrollLimitX);
                    var zoomToDestY = _clamp(args.contentY, 0, scrollLimitY);
                    if (zoomToDestX === effectiveScrollLeft && zoomToDestY === effectiveScrollTop) {
                        // Scroll position is already in the proper state. This zoomTo is a no-op.
                        return;
                    }

                    element._zoomToId = element._zoomToId || 0;
                    element._zoomToId++;
                    element._zoomToDestX = zoomToDestX;
                    element._zoomToDestY = zoomToDestY;

                    var thisZoomToId = element._zoomToId;
                    var start = _BaseUtils._now();
                    var xFactor = (element._zoomToDestX - initialPos.scrollLeft) / _zoomToDuration;
                    var yFactor = (element._zoomToDestY - initialPos.scrollTop) / _zoomToDuration;

                    var update = function () {
                        var t = _BaseUtils._now() - start;
                        if (element._zoomToId !== thisZoomToId) {
                            return;
                        } else if (t > _zoomToDuration) {
                            setAdjustedScrollPosition(element, element._zoomToDestX, element._zoomToDestY);
                            element._zoomToDestX = null;
                            element._zoomToDestY = null;
                        } else {
                            setAdjustedScrollPosition(element, initialPos.scrollLeft + t * xFactor, initialPos.scrollTop + t * yFactor);
                            _BaseUtils._requestAnimationFrame(update);
                        }
                    };

                    _BaseUtils._requestAnimationFrame(update);
                });
            }
        },

        _setActive: function _setActive(element, scroller) {
            var success = true;
            try {
                if (_Global.HTMLElement && _Global.HTMLElement.prototype.setActive) {
                    element.setActive();
                } else {
                    // We are aware that, unlike setActive(), focus() will scroll to the element that gets focus. However, this is
                    // our current cross-browser solution until there is an equivalent for setActive() in other browsers.
                    //
                    // This _setActive polyfill does have limited support for preventing scrolling: via the scroller parameter, it
                    // can prevent one scroller from scrolling. This functionality is necessary in some scenarios. For example, when using
                    // _zoomTo and _setActive together.

                    var scrollLeft,
                        scrollTop;

                    if (scroller) {
                        scrollLeft = scroller.scrollLeft;
                        scrollTop = scroller.scrollTop;
                    }
                    element.focus();
                    if (scroller) {
                        scroller.scrollLeft = scrollLeft;
                        scroller.scrollTop = scrollTop;
                    }
                }
            } catch (e) {
                // setActive() raises an exception when trying to focus an invisible item. Checking visibility is non-trivial, so it's best
                // just to catch the exception and ignore it. focus() on the other hand, does not raise exceptions.
                success = false;
            }
            return success;
        },

        _MutationObserver: _MutationObserver,

        _resizeNotifier: {
            get: function () {
                if (!_resizeNotifier) {
                    _resizeNotifier = new ResizeNotifier();
                }
                return _resizeNotifier;
            }
        },

        _GenericListener: GenericListener,
        _globalListener: new GenericListener("Global", _Global, { registerThruTVJSCustomEvents: true }),
        _documentElementListener: new GenericListener("DocumentElement", _Global.document.documentElement, { registerThruTVJSCustomEvents: true }),
        _inputPaneListener: _WinRT.Windows.UI.ViewManagement.InputPane ?
            new GenericListener("InputPane", _WinRT.Windows.UI.ViewManagement.InputPane.getForCurrentView()) :
            { addEventListener: function () { }, removeEventListener: function () { } },

        // Appends a hidden child to the given element that will listen for being added
        // to the DOM. When the hidden element is added to the DOM, it will dispatch a
        // "TVJSNodeInserted" event on the provided element.
        _addInsertedNotifier: function (element) {
            var hiddenElement = _Global.document.createElement("div");
            hiddenElement.style[_BaseUtils._browserStyleEquivalents["animation-name"].scriptName] = "TVJS-node-inserted";
            hiddenElement.style[_BaseUtils._browserStyleEquivalents["animation-duration"].scriptName] = "0.01s";
            hiddenElement.style["position"] = "absolute";
            element.appendChild(hiddenElement);

            exports._addEventListener(hiddenElement, "animationStart", function (e) {
                if (e.animationName === "TVJS-node-inserted") {
                    var e = _Global.document.createEvent("Event");
                    e.initEvent("TVJSNodeInserted", false, true);
                    element.dispatchEvent(e);
                }
            }, false);

            return hiddenElement;
        },

        // Returns a promise which completes when *element* is in the DOM.
        _inDom: function Utilities_inDom(element) {
            return new Promise(function (c) {
                if (_Global.document.body.contains(element)) {
                    c();
                } else {
                    var nodeInsertedHandler = function () {
                        element.removeEventListener("TVJSNodeInserted", nodeInsertedHandler, false);
                        c();
                    };
                    exports._addInsertedNotifier(element);
                    element.addEventListener("TVJSNodeInserted", nodeInsertedHandler, false);
                }
            });
        },

        // Browser agnostic method to set element flex style
        // Param is an object in the form {grow: flex-grow, shrink: flex-shrink, basis: flex-basis}
        // All fields optional
        _setFlexStyle: function (element, flexParams) {
            var styleObject = element.style;
            if (typeof flexParams.grow !== "undefined") {
                styleObject.msFlexPositive = flexParams.grow;
                styleObject.webkitFlexGrow = flexParams.grow;
                styleObject.flexGrow = flexParams.grow;
            }
            if (typeof flexParams.shrink !== "undefined") {
                styleObject.msFlexNegative = flexParams.shrink;
                styleObject.webkitFlexShrink = flexParams.shrink;
                styleObject.flexShrink = flexParams.shrink;
            }
            if (typeof flexParams.basis !== "undefined") {
                styleObject.msFlexPreferredSize = flexParams.basis;
                styleObject.webkitFlexBasis = flexParams.basis;
                styleObject.flexBasis = flexParams.basis;
            }
        },

        /// <field locid="TVJS.Utilities.Key" helpKeyword="TVJS.Utilities.Key">
        /// Defines a set of keyboard values.
        /// </field>
        Key: {
            /// <field locid="TVJS.Utilities.Key.backspace" helpKeyword="TVJS.Utilities.Key.backspace">
            /// BACKSPACE key.
            /// </field>
            backspace: 8,

            /// <field locid="TVJS.Utilities.Key.tab" helpKeyword="TVJS.Utilities.Key.tab">
            /// TAB key.
            /// </field>
            tab: 9,

            /// <field locid="TVJS.Utilities.Key.enter" helpKeyword="TVJS.Utilities.Key.enter">
            /// ENTER key.
            /// </field>
            enter: 13,

            /// <field locid="TVJS.Utilities.Key.shift" helpKeyword="TVJS.Utilities.Key.shift">
            /// Shift key.
            /// </field>
            shift: 16,

            /// <field locid="TVJS.Utilities.Key.ctrl" helpKeyword="TVJS.Utilities.Key.ctrl">
            /// CTRL key.
            /// </field>
            ctrl: 17,

            /// <field locid="TVJS.Utilities.Key.alt" helpKeyword="TVJS.Utilities.Key.alt">
            /// ALT key
            /// </field>
            alt: 18,

            /// <field locid="TVJS.Utilities.Key.pause" helpKeyword="TVJS.Utilities.Key.pause">
            /// Pause key.
            /// </field>
            pause: 19,

            /// <field locid="TVJS.Utilities.Key.capsLock" helpKeyword="TVJS.Utilities.Key.capsLock">
            /// CAPS LOCK key.
            /// </field>
            capsLock: 20,

            /// <field locid="TVJS.Utilities.Key.escape" helpKeyword="TVJS.Utilities.Key.escape">
            /// ESCAPE key.
            /// </field>
            escape: 27,

            /// <field locid="TVJS.Utilities.Key.space" helpKeyword="TVJS.Utilities.Key.space">
            /// SPACE key.
            /// </field>
            space: 32,

            /// <field locid="TVJS.Utilities.Key.pageUp" helpKeyword="TVJS.Utilities.Key.pageUp">
            /// PAGE UP key.
            /// </field>
            pageUp: 33,

            /// <field locid="TVJS.Utilities.Key.pageDown" helpKeyword="TVJS.Utilities.Key.pageDown">
            /// PAGE DOWN key.
            /// </field>
            pageDown: 34,

            /// <field locid="TVJS.Utilities.Key.end" helpKeyword="TVJS.Utilities.Key.end">
            /// END key.
            /// </field>
            end: 35,

            /// <field locid="TVJS.Utilities.Key.home" helpKeyword="TVJS.Utilities.Key.home">
            /// HOME key.
            /// </field>
            home: 36,

            /// <field locid="TVJS.Utilities.Key.leftArrow" helpKeyword="TVJS.Utilities.Key.leftArrow">
            /// Left arrow key.
            /// </field>
            leftArrow: 37,

            /// <field locid="TVJS.Utilities.Key.upArrow" helpKeyword="TVJS.Utilities.Key.upArrow">
            /// Up arrow key.
            /// </field>
            upArrow: 38,

            /// <field locid="TVJS.Utilities.Key.rightArrow" helpKeyword="TVJS.Utilities.Key.rightArrow">
            /// Right arrow key.
            /// </field>
            rightArrow: 39,

            /// <field locid="TVJS.Utilities.Key.downArrow" helpKeyword="TVJS.Utilities.Key.downArrow">
            /// Down arrow key.
            /// </field>
            downArrow: 40,

            /// <field locid="TVJS.Utilities.Key.insert" helpKeyword="TVJS.Utilities.Key.insert">
            /// INSERT key.
            /// </field>
            insert: 45,

            /// <field locid="TVJS.Utilities.Key.deleteKey" helpKeyword="TVJS.Utilities.Key.deleteKey">
            /// DELETE key.
            /// </field>
            deleteKey: 46,

            /// <field locid="TVJS.Utilities.Key.num0" helpKeyword="TVJS.Utilities.Key.num0">
            /// Number 0 key.
            /// </field>
            num0: 48,

            /// <field locid="TVJS.Utilities.Key.num1" helpKeyword="TVJS.Utilities.Key.num1">
            /// Number 1 key.
            /// </field>
            num1: 49,

            /// <field locid="TVJS.Utilities.Key.num2" helpKeyword="TVJS.Utilities.Key.num2">
            /// Number 2 key.
            /// </field>
            num2: 50,

            /// <field locid="TVJS.Utilities.Key.num3" helpKeyword="TVJS.Utilities.Key.num3">
            /// Number 3 key.
            /// </field>
            num3: 51,

            /// <field locid="TVJS.Utilities.Key.num4" helpKeyword="TVJS.Utilities.Key.num4">
            /// Number 4 key.
            /// </field>
            num4: 52,

            /// <field locid="TVJS.Utilities.Key.num5" helpKeyword="TVJS.Utilities.Key.num5">
            /// Number 5 key.
            /// </field>
            num5: 53,

            /// <field locid="TVJS.Utilities.Key.num6" helpKeyword="TVJS.Utilities.Key.num6">
            /// Number 6 key.
            /// </field>
            num6: 54,

            /// <field locid="TVJS.Utilities.Key.num7" helpKeyword="TVJS.Utilities.Key.num7">
            /// Number 7 key.
            /// </field>
            num7: 55,

            /// <field locid="TVJS.Utilities.Key.num8" helpKeyword="TVJS.Utilities.Key.num8">
            /// Number 8 key.
            /// </field>
            num8: 56,

            /// <field locid="TVJS.Utilities.Key.num9" helpKeyword="TVJS.Utilities.Key.num9">
            /// Number 9 key.
            /// </field>
            num9: 57,

            /// <field locid="TVJS.Utilities.Key.a" helpKeyword="TVJS.Utilities.Key.a">
            /// A key.
            /// </field>
            a: 65,

            /// <field locid="TVJS.Utilities.Key.b" helpKeyword="TVJS.Utilities.Key.b">
            /// B key.
            /// </field>
            b: 66,

            /// <field locid="TVJS.Utilities.Key.c" helpKeyword="TVJS.Utilities.Key.c">
            /// C key.
            /// </field>
            c: 67,

            /// <field locid="TVJS.Utilities.Key.d" helpKeyword="TVJS.Utilities.Key.d">
            /// D key.
            /// </field>
            d: 68,

            /// <field locid="TVJS.Utilities.Key.e" helpKeyword="TVJS.Utilities.Key.e">
            /// E key.
            /// </field>
            e: 69,

            /// <field locid="TVJS.Utilities.Key.f" helpKeyword="TVJS.Utilities.Key.f">
            /// F key.
            /// </field>
            f: 70,

            /// <field locid="TVJS.Utilities.Key.g" helpKeyword="TVJS.Utilities.Key.g">
            /// G key.
            /// </field>
            g: 71,

            /// <field locid="TVJS.Utilities.Key.h" helpKeyword="TVJS.Utilities.Key.h">
            /// H key.
            /// </field>
            h: 72,

            /// <field locid="TVJS.Utilities.Key.i" helpKeyword="TVJS.Utilities.Key.i">
            /// I key.
            /// </field>
            i: 73,

            /// <field locid="TVJS.Utilities.Key.j" helpKeyword="TVJS.Utilities.Key.j">
            /// J key.
            /// </field>
            j: 74,

            /// <field locid="TVJS.Utilities.Key.k" helpKeyword="TVJS.Utilities.Key.k">
            /// K key.
            /// </field>
            k: 75,

            /// <field locid="TVJS.Utilities.Key.l" helpKeyword="TVJS.Utilities.Key.l">
            /// L key.
            /// </field>
            l: 76,

            /// <field locid="TVJS.Utilities.Key.m" helpKeyword="TVJS.Utilities.Key.m">
            /// M key.
            /// </field>
            m: 77,

            /// <field locid="TVJS.Utilities.Key.n" helpKeyword="TVJS.Utilities.Key.n">
            /// N key.
            /// </field>
            n: 78,

            /// <field locid="TVJS.Utilities.Key.o" helpKeyword="TVJS.Utilities.Key.o">
            /// O key.
            /// </field>
            o: 79,

            /// <field locid="TVJS.Utilities.Key.p" helpKeyword="TVJS.Utilities.Key.p">
            /// P key.
            /// </field>
            p: 80,

            /// <field locid="TVJS.Utilities.Key.q" helpKeyword="TVJS.Utilities.Key.q">
            /// Q key.
            /// </field>
            q: 81,

            /// <field locid="TVJS.Utilities.Key.r" helpKeyword="TVJS.Utilities.Key.r">
            /// R key.
            /// </field>
            r: 82,

            /// <field locid="TVJS.Utilities.Key.s" helpKeyword="TVJS.Utilities.Key.s">
            /// S key.
            /// </field>
            s: 83,

            /// <field locid="TVJS.Utilities.Key.t" helpKeyword="TVJS.Utilities.Key.t">
            /// T key.
            /// </field>
            t: 84,

            /// <field locid="TVJS.Utilities.Key.u" helpKeyword="TVJS.Utilities.Key.u">
            /// U key.
            /// </field>
            u: 85,

            /// <field locid="TVJS.Utilities.Key.v" helpKeyword="TVJS.Utilities.Key.v">
            /// V key.
            /// </field>
            v: 86,

            /// <field locid="TVJS.Utilities.Key.w" helpKeyword="TVJS.Utilities.Key.w">
            /// W key.
            /// </field>
            w: 87,

            /// <field locid="TVJS.Utilities.Key.x" helpKeyword="TVJS.Utilities.Key.x">
            /// X key.
            /// </field>
            x: 88,

            /// <field locid="TVJS.Utilities.Key.y" helpKeyword="TVJS.Utilities.Key.y">
            /// Y key.
            /// </field>
            y: 89,

            /// <field locid="TVJS.Utilities.Key.z" helpKeyword="TVJS.Utilities.Key.z">
            /// Z key.
            /// </field>
            z: 90,

            /// <field locid="TVJS.Utilities.Key.leftWindows" helpKeyword="TVJS.Utilities.Key.leftWindows">
            /// Left Windows key.
            /// </field>
            leftWindows: 91,

            /// <field locid="TVJS.Utilities.Key.rightWindows" helpKeyword="TVJS.Utilities.Key.rightWindows">
            /// Right Windows key.
            /// </field>
            rightWindows: 92,

            /// <field locid="TVJS.Utilities.Key.menu" helpKeyword="TVJS.Utilities.Key.menu">
            /// Menu key.
            /// </field>
            menu: 93,

            /// <field locid="TVJS.Utilities.Key.numPad0" helpKeyword="TVJS.Utilities.Key.numPad0">
            /// Number pad 0 key.
            /// </field>
            numPad0: 96,

            /// <field locid="TVJS.Utilities.Key.numPad1" helpKeyword="TVJS.Utilities.Key.numPad1">
            /// Number pad 1 key.
            /// </field>
            numPad1: 97,

            /// <field locid="TVJS.Utilities.Key.numPad2" helpKeyword="TVJS.Utilities.Key.numPad2">
            /// Number pad 2 key.
            /// </field>
            numPad2: 98,

            /// <field locid="TVJS.Utilities.Key.numPad3" helpKeyword="TVJS.Utilities.Key.numPad3">
            /// Number pad 3 key.
            /// </field>
            numPad3: 99,

            /// <field locid="TVJS.Utilities.Key.numPad4" helpKeyword="TVJS.Utilities.Key.numPad4">
            /// Number pad 4 key.
            /// </field>
            numPad4: 100,

            /// <field locid="TVJS.Utilities.Key.numPad5" helpKeyword="TVJS.Utilities.Key.numPad5">
            /// Number pad 5 key.
            /// </field>
            numPad5: 101,

            /// <field locid="TVJS.Utilities.Key.numPad6" helpKeyword="TVJS.Utilities.Key.numPad6">
            /// Number pad 6 key.
            /// </field>
            numPad6: 102,

            /// <field locid="TVJS.Utilities.Key.numPad7" helpKeyword="TVJS.Utilities.Key.numPad7">
            /// Number pad 7 key.
            /// </field>
            numPad7: 103,

            /// <field locid="TVJS.Utilities.Key.numPad8" helpKeyword="TVJS.Utilities.Key.numPad8">
            /// Number pad 8 key.
            /// </field>
            numPad8: 104,

            /// <field locid="TVJS.Utilities.Key.numPad9" helpKeyword="TVJS.Utilities.Key.numPad9">
            /// Number pad 9 key.
            /// </field>
            numPad9: 105,

            /// <field locid="TVJS.Utilities.Key.multiply" helpKeyword="TVJS.Utilities.Key.multiply">
            /// Multiplication key.
            /// </field>
            multiply: 106,

            /// <field locid="TVJS.Utilities.Key.add" helpKeyword="TVJS.Utilities.Key.add">
            /// Addition key.
            /// </field>
            add: 107,

            /// <field locid="TVJS.Utilities.Key.subtract" helpKeyword="TVJS.Utilities.Key.subtract">
            /// Subtraction key.
            /// </field>
            subtract: 109,

            /// <field locid="TVJS.Utilities.Key.decimalPoint" helpKeyword="TVJS.Utilities.Key.decimalPoint">
            /// Decimal point key.
            /// </field>
            decimalPoint: 110,

            /// <field locid="TVJS.Utilities.Key.divide" helpKeyword="TVJS.Utilities.Key.divide">
            /// Division key.
            /// </field>
            divide: 111,

            /// <field locid="TVJS.Utilities.Key.F1" helpKeyword="TVJS.Utilities.Key.F1">
            /// F1 key.
            /// </field>
            F1: 112,

            /// <field locid="TVJS.Utilities.Key.F2" helpKeyword="TVJS.Utilities.Key.F2">
            /// F2 key.
            /// </field>
            F2: 113,

            /// <field locid="TVJS.Utilities.Key.F3" helpKeyword="TVJS.Utilities.Key.F3">
            /// F3 key.
            /// </field>
            F3: 114,

            /// <field locid="TVJS.Utilities.Key.F4" helpKeyword="TVJS.Utilities.Key.F4">
            /// F4 key.
            /// </field>
            F4: 115,

            /// <field locid="TVJS.Utilities.Key.F5" helpKeyword="TVJS.Utilities.Key.F5">
            /// F5 key.
            /// </field>
            F5: 116,

            /// <field locid="TVJS.Utilities.Key.F6" helpKeyword="TVJS.Utilities.Key.F6">
            /// F6 key.
            /// </field>
            F6: 117,

            /// <field locid="TVJS.Utilities.Key.F7" helpKeyword="TVJS.Utilities.Key.F7">
            /// F7 key.
            /// </field>
            F7: 118,

            /// <field locid="TVJS.Utilities.Key.F8" helpKeyword="TVJS.Utilities.Key.F8">
            /// F8 key.
            /// </field>
            F8: 119,

            /// <field locid="TVJS.Utilities.Key.F9" helpKeyword="TVJS.Utilities.Key.F9">
            /// F9 key.
            /// </field>
            F9: 120,

            /// <field locid="TVJS.Utilities.Key.F10" helpKeyword="TVJS.Utilities.Key.F10">
            /// F10 key.
            /// </field>
            F10: 121,

            /// <field locid="TVJS.Utilities.Key.F11" helpKeyword="TVJS.Utilities.Key.F11">
            /// F11 key.
            /// </field>
            F11: 122,

            /// <field locid="TVJS.Utilities.Key.F12" helpKeyword="TVJS.Utilities.Key.F12">
            /// F12 key.
            /// </field>
            F12: 123,

            /// <field locid="TVJS.Utilities.Key.NavigationView" helpKeyword="TVJS.Utilities.Key.NavigationView">
            /// XBox One Remote NavigationView key.
            /// </field>
            NavigationView: 136,

            /// <field locid="TVJS.Utilities.Key.NavigationMenu" helpKeyword="TVJS.Utilities.Key.NavigationMenu">
            /// XBox One Remote NavigationMenu key.
            /// </field>
            NavigationMenu: 137,

            /// <field locid="TVJS.Utilities.Key.NavigationUp" helpKeyword="TVJS.Utilities.Key.NavigationUp">
            /// XBox One Remote NavigationUp key.
            /// </field>
            NavigationUp: 138,

            /// <field locid="TVJS.Utilities.Key.NavigationDown" helpKeyword="TVJS.Utilities.Key.NavigationDown">
            /// XBox One Remote NavigationDown key.
            /// </field>
            NavigationDown: 139,

            /// <field locid="TVJS.Utilities.Key.NavigationLeft" helpKeyword="TVJS.Utilities.Key.NavigationLeft">
            /// XBox One Remote NavigationLeft key.
            /// </field>
            NavigationLeft: 140,

            /// <field locid="TVJS.Utilities.Key.NavigationRight" helpKeyword="TVJS.Utilities.Key.NavigationRight">
            /// XBox One Remote NavigationRight key.
            /// </field>
            NavigationRight: 141,

            /// <field locid="TVJS.Utilities.Key.NavigationAccept" helpKeyword="TVJS.Utilities.Key.NavigationAccept">
            /// XBox One Remote NavigationAccept key.
            /// </field>
            NavigationAccept: 142,

            /// <field locid="TVJS.Utilities.Key.NavigationCancel" helpKeyword="TVJS.Utilities.Key.NavigationCancel">
            /// XBox One Remote NavigationCancel key.
            /// </field>
            NavigationCancel: 143,

            /// <field locid="TVJS.Utilities.Key.numLock" helpKeyword="TVJS.Utilities.Key.numLock">
            /// NUMBER LOCK key.
            /// </field>
            numLock: 144,

            /// <field locid="TVJS.Utilities.Key.scrollLock" helpKeyword="TVJS.Utilities.Key.scrollLock">
            /// SCROLL LOCK key.
            /// </field>
            scrollLock: 145,

            /// <field locid="TVJS.Utilities.Key.browserBack" helpKeyword="TVJS.Utilities.Key.browserBack">
            /// Browser back key.
            /// </field>
            browserBack: 166,

            /// <field locid="TVJS.Utilities.Key.browserForward" helpKeyword="TVJS.Utilities.Key.browserForward">
            /// Browser forward key.
            /// </field>
            browserForward: 167,

            /// <field locid="TVJS.Utilities.Key.semicolon" helpKeyword="TVJS.Utilities.Key.semicolon">
            /// SEMICOLON key.
            /// </field>
            semicolon: 186,

            /// <field locid="TVJS.Utilities.Key.equal" helpKeyword="TVJS.Utilities.Key.equal">
            /// EQUAL key.
            /// </field>
            equal: 187,

            /// <field locid="TVJS.Utilities.Key.comma" helpKeyword="TVJS.Utilities.Key.comma">
            /// COMMA key.
            /// </field>
            comma: 188,

            /// <field locid="TVJS.Utilities.Key.dash" helpKeyword="TVJS.Utilities.Key.dash">
            /// DASH key.
            /// </field>
            dash: 189,

            /// <field locid="TVJS.Utilities.Key.period" helpKeyword="TVJS.Utilities.Key.period">
            /// PERIOD key.
            /// </field>
            period: 190,

            /// <field locid="TVJS.Utilities.Key.forwardSlash" helpKeyword="TVJS.Utilities.Key.forwardSlash">
            /// FORWARD SLASH key.
            /// </field>
            forwardSlash: 191,

            /// <field locid="TVJS.Utilities.Key.graveAccent" helpKeyword="TVJS.Utilities.Key.graveAccent">
            /// Accent grave key.
            /// </field>
            graveAccent: 192,

            /// <field locid="TVJS.Utilities.Key.GamepadA" helpKeyword="TVJS.Utilities.Key.GamepadA">
            /// XBox One GamepadA key.
            /// </field>
            gamepadA: 195,

            /// <field locid="TVJS.Utilities.Key.GamepadB" helpKeyword="TVJS.Utilities.Key.GamepadB">
            /// XBox One GamepadB key.
            /// </field>
            gamepadB: 196,

            /// <field locid="TVJS.Utilities.Key.GamepadX" helpKeyword="TVJS.Utilities.Key.GamepadX">
            /// XBox One GamepadX key.
            /// </field>
            gamepadX: 197,

            /// <field locid="TVJS.Utilities.Key.GamepadY" helpKeyword="TVJS.Utilities.Key.GamepadY">
            /// XBox One GamepadY key.
            /// </field>
            gamepadY: 198,

            /// <field locid="TVJS.Utilities.Key.GamepadRightShoulder" helpKeyword="TVJS.Utilities.Key.GamepadRightShoulder">
            /// XBox One GamepadRightShoulder key.
            /// </field>
            gamepadRightShoulder: 199,

            /// <field locid="TVJS.Utilities.Key.GamepadLeftShoulder" helpKeyword="TVJS.Utilities.Key.GamepadLeftShoulder">
            /// XBox One GamepadLeftShoulder key.
            /// </field>
            gamepadLeftShoulder: 200,

            /// <field locid="TVJS.Utilities.Key.GamepadLeftTrigger" helpKeyword="TVJS.Utilities.Key.GamepadLeftTrigger">
            /// XBox One GamepadLeftTrigger key.
            /// </field>
            gamepadLeftTrigger: 201,

            /// <field locid="TVJS.Utilities.Key.GamepadRightTrigger" helpKeyword="TVJS.Utilities.Key.GamepadRightTrigger">
            /// XBox One GamepadRightTrigger key.
            /// </field>
            gamepadRightTrigger: 202,

            /// <field locid="TVJS.Utilities.Key.GamepadDPadUp" helpKeyword="TVJS.Utilities.Key.GamepadDPadUp">
            /// XBox One GamepadDPadUp key.
            /// </field>
            gamepadDPadUp: 203,

            /// <field locid="TVJS.Utilities.Key.GamepadDPadDown" helpKeyword="TVJS.Utilities.Key.GamepadDPadDown">
            /// XBox One GamepadDPadDown key.
            /// </field>
            gamepadDPadDown: 204,

            /// <field locid="TVJS.Utilities.Key.GamepadDPadLeft" helpKeyword="TVJS.Utilities.Key.GamepadDPadLeft">
            /// XBox One GamepadDPadLeft key.
            /// </field>
            gamepadDPadLeft: 205,

            /// <field locid="TVJS.Utilities.Key.GamepadDPadRight" helpKeyword="TVJS.Utilities.Key.GamepadDPadRight">
            /// XBox One GamepadDPadRight key.
            /// </field>
            gamepadDPadRight: 206,

            /// <field locid="TVJS.Utilities.Key.GamepadMenu" helpKeyword="TVJS.Utilities.Key.GamepadMenu">
            /// XBox One GamepadMenu key.
            /// </field>
            gamepadMenu: 207,

            /// <field locid="TVJS.Utilities.Key.GamepadView" helpKeyword="TVJS.Utilities.Key.GamepadView">
            /// XBox One GamepadView key.
            /// </field>
            gamepadView: 208,

            /// <field locid="TVJS.Utilities.Key.GamepadLeftThumbstick" helpKeyword="TVJS.Utilities.Key.GamepadLeftThumbstick">
            /// XBox One GamepadLeftThumbstick key.
            /// </field>
            gamepadLeftThumbstick: 209,

            /// <field locid="TVJS.Utilities.Key.GamepadRightThumbstick" helpKeyword="TVJS.Utilities.Key.GamepadRightThumbstick">
            /// XBox One GamepadRightThumbstick key.
            /// </field>
            gamepadRightThumbstick: 210,

            /// <field locid="TVJS.Utilities.Key.GamepadLeftThumbstickUp" helpKeyword="TVJS.Utilities.Key.GamepadLeftThumbstickUp">
            /// XBox One GamepadLeftThumbstickUp key.
            /// </field>
            gamepadLeftThumbstickUp: 211,

            /// <field locid="TVJS.Utilities.Key.GamepadLeftThumbstickDown" helpKeyword="TVJS.Utilities.Key.GamepadLeftThumbstickDown">
            /// XBox One GamepadLeftThumbstickDown key.
            /// </field>
            gamepadLeftThumbstickDown: 212,

            /// <field locid="TVJS.Utilities.Key.GamepadLeftThumbstickRight" helpKeyword="TVJS.Utilities.Key.GamepadLeftThumbstickRight">
            /// XBox One GamepadLeftThumbstickRight key.
            /// </field>
            gamepadLeftThumbstickRight: 213,

            /// <field locid="TVJS.Utilities.Key.GamepadLeftThumbstickLeft" helpKeyword="TVJS.Utilities.Key.GamepadLeftThumbstickLeft">
            /// XBox One GamepadLeftThumbstickLeft key.
            /// </field>
            gamepadLeftThumbstickLeft: 214,

            /// <field locid="TVJS.Utilities.Key.GamepadRightThumbstickUp" helpKeyword="TVJS.Utilities.Key.GamepadRightThumbstickUp">
            /// XBox One GamepadRightThumbstickUp key.
            /// </field>
            gamepadRightThumbstickUp: 215,

            /// <field locid="TVJS.Utilities.Key.GamepadRightThumbstickDown" helpKeyword="TVJS.Utilities.Key.GamepadRightThumbstickDown">
            /// XBox One GamepadRightThumbstickDown key.
            /// </field>
            gamepadRightThumbstickDown: 216,

            /// <field locid="TVJS.Utilities.Key.GamepadRightThumbstickRight" helpKeyword="TVJS.Utilities.Key.GamepadRightThumbstickRight">
            /// XBox One GamepadRightThumbstickRight key.
            /// </field>
            gamepadRightThumbstickRight: 217,

            /// <field locid="TVJS.Utilities.Key.GamepadRightThumbstickLeft" helpKeyword="TVJS.Utilities.Key.GamepadRightThumbstickLeft">
            /// XBox One GamepadRightThumbstickLeft key.
            /// </field>
            gamepadRightThumbstickLeft: 218,

            /// <field locid="TVJS.Utilities.Key.openBracket" helpKeyword="TVJS.Utilities.Key.openBracket">
            /// OPEN BRACKET key.
            /// </field>
            openBracket: 219,

            /// <field locid="TVJS.Utilities.Key.backSlash" helpKeyword="TVJS.Utilities.Key.backSlash">
            /// BACKSLASH key.
            /// </field>
            backSlash: 220,

            /// <field locid="TVJS.Utilities.Key.closeBracket" helpKeyword="TVJS.Utilities.Key.closeBracket">
            /// CLOSE BRACKET key.
            /// </field>
            closeBracket: 221,

            /// <field locid="TVJS.Utilities.Key.singleQuote" helpKeyword="TVJS.Utilities.Key.singleQuote">
            /// SINGLE QUOTE key.
            /// </field>
            singleQuote: 222,

            /// <field locid="TVJS.Utilities.Key.IME" helpKeyword="TVJS.Utilities.Key.IME">
            /// Any IME input.
            /// </field>
            IME: 229
        },

        data: function (element) {
            /// <signature helpKeyword="TVJS.Utilities.data">
            /// <summary locid="TVJS.Utilities.data">
            /// Gets the data value associated with the specified element.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.data_p:element">
            /// The element.
            /// </param>
            /// <returns type="Object" locid="TVJS.Utilities.data_returnValue">
            /// The value associated with the element.
            /// </returns>
            /// </signature>
            if (!element[_dataKey]) {
                element[_dataKey] = {};
            }
            return element[_dataKey];
        },

        hasClass: function (e, name) {
            /// <signature helpKeyword="TVJS.Utilities.hasClass">
            /// <summary locid="TVJS.Utilities.hasClass">
            /// Determines whether the specified element has the specified class.
            /// </summary>
            /// <param name="e" type="HTMLElement" locid="TVJS.Utilities.hasClass_p:e">
            /// The element.
            /// </param>
            /// <param name="name" type="String" locid="TVJS.Utilities.hasClass_p:name">
            /// The name of the class.
            /// </param>
            /// <returns type="Boolean" locid="TVJS.Utilities.hasClass_returnValue">
            /// true if the specified element contains the specified class; otherwise, false.
            /// </returns>
            /// </signature>

            if (e.classList) {
                return e.classList.contains(name);
            } else {
                var className = getClassName(e);
                var names = className.trim().split(" ");
                var l = names.length;
                for (var i = 0; i < l; i++) {
                    if (names[i] === name) {
                        return true;
                    }
                }
                return false;
            }
        },

        addClass: addClass,

        removeClass: removeClass,

        toggleClass: toggleClass,

        _setAttribute: setAttribute,

        getRelativeLeft: function (element, parent) {
            /// <signature helpKeyword="TVJS.Utilities.getRelativeLeft">
            /// <summary locid="TVJS.Utilities.getRelativeLeft">
            /// Gets the left coordinate of the specified element relative to the specified parent.
            /// </summary>
            /// <param name="element" domElement="true" locid="TVJS.Utilities.getRelativeLeft_p:element">
            /// The element.
            /// </param>
            /// <param name="parent" domElement="true" locid="TVJS.Utilities.getRelativeLeft_p:parent">
            /// The parent element.
            /// </param>
            /// <returns type="Number" locid="TVJS.Utilities.getRelativeLeft_returnValue">
            /// The relative left coordinate.
            /// </returns>
            /// </signature>
            if (!element) {
                return 0;
            }

            var left = element.offsetLeft;
            var e = element.parentNode;
            while (e) {
                left -= e.offsetLeft;

                if (e === parent) {
                    break;
                }
                e = e.parentNode;
            }

            return left;
        },

        getRelativeTop: function (element, parent) {
            /// <signature helpKeyword="TVJS.Utilities.getRelativeTop">
            /// <summary locid="TVJS.Utilities.getRelativeTop">
            /// Gets the top coordinate of the element relative to the specified parent.
            /// </summary>
            /// <param name="element" domElement="true" locid="TVJS.Utilities.getRelativeTop_p:element">
            /// The element.
            /// </param>
            /// <param name="parent" domElement="true" locid="TVJS.Utilities.getRelativeTop_p:parent">
            /// The parent element.
            /// </param>
            /// <returns type="Number" locid="TVJS.Utilities.getRelativeTop_returnValue">
            /// The relative top coordinate.
            /// </returns>
            /// </signature>
            if (!element) {
                return 0;
            }

            var top = element.offsetTop;
            var e = element.parentNode;
            while (e) {
                top -= e.offsetTop;

                if (e === parent) {
                    break;
                }
                e = e.parentNode;
            }

            return top;
        },

        getScrollPosition: getScrollPosition,

        setScrollPosition: setScrollPosition,

        empty: function (element) {
            /// <signature helpKeyword="TVJS.Utilities.empty">
            /// <summary locid="TVJS.Utilities.empty">
            /// Removes all the child nodes from the specified element.
            /// </summary>
            /// <param name="element" type="HTMLElement" domElement="true" locid="TVJS.Utilities.empty_p:element">
            /// The element.
            /// </param>
            /// <returns type="HTMLElement" locid="TVJS.Utilities.empty_returnValue">
            /// The element.
            /// </returns>
            /// </signature>
            if (element.childNodes && element.childNodes.length > 0) {
                for (var i = element.childNodes.length - 1; i >= 0; i--) {
                    element.removeChild(element.childNodes.item(i));
                }
            }
            return element;
        },

        _isDOMElement: function (element) {
            return element &&
                typeof element === "object" &&
                typeof element.tagName === "string";
        },

        getContentWidth: function (element) {
            /// <signature helpKeyword="TVJS.Utilities.getContentWidth">
            /// <summary locid="TVJS.Utilities.getContentWidth">
            /// Gets the width of the content of the specified element. The content width does not include borders or padding.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.getContentWidth_p:element">
            /// The element.
            /// </param>
            /// <returns type="Number" locid="TVJS.Utilities.getContentWidth_returnValue">
            /// The content width of the element.
            /// </returns>
            /// </signature>
            var border = getDimension(element, "borderLeftWidth") + getDimension(element, "borderRightWidth"),
                padding = getDimension(element, "paddingLeft") + getDimension(element, "paddingRight");
            return element.offsetWidth - border - padding;
        },
        _getPreciseContentWidth: function (element) {
            var border = _getPreciseDimension(element, "borderLeftWidth") + _getPreciseDimension(element, "borderRightWidth"),
                padding = _getPreciseDimension(element, "paddingLeft") + _getPreciseDimension(element, "paddingRight");
            return element.offsetWidth - border - padding;
        },

        getTotalWidth: function (element) {
            /// <signature helpKeyword="TVJS.Utilities.getTotalWidth">
            /// <summary locid="TVJS.Utilities.getTotalWidth">
            /// Gets the width of the element, including margins.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.getTotalWidth_p:element">
            /// The element.
            /// </param>
            /// <returns type="Number" locid="TVJS.Utilities.getTotalWidth_returnValue">
            /// The width of the element including margins.
            /// </returns>
            /// </signature>
            var margin = getDimension(element, "marginLeft") + getDimension(element, "marginRight");
            return element.offsetWidth + margin;
        },
        _getPreciseTotalWidth: function (element) {
            var margin = _getPreciseDimension(element, "marginLeft") + _getPreciseDimension(element, "marginRight");
            return element.offsetWidth + margin;
        },

        getContentHeight: function (element) {
            /// <signature helpKeyword="TVJS.Utilities.getContentHeight">
            /// <summary locid="TVJS.Utilities.getContentHeight">
            /// Gets the height of the content of the specified element. The content height does not include borders or padding.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.getContentHeight_p:element">
            /// The element.
            /// </param>
            /// <returns type="Number" integer="true" locid="TVJS.Utilities.getContentHeight_returnValue">
            /// The content height of the element.
            /// </returns>
            /// </signature>
            var border = getDimension(element, "borderTopWidth") + getDimension(element, "borderBottomWidth"),
                padding = getDimension(element, "paddingTop") + getDimension(element, "paddingBottom");
            return element.offsetHeight - border - padding;
        },
        _getPreciseContentHeight: function (element) {
            var border = _getPreciseDimension(element, "borderTopWidth") + _getPreciseDimension(element, "borderBottomWidth"),
                padding = _getPreciseDimension(element, "paddingTop") + _getPreciseDimension(element, "paddingBottom");
            return element.offsetHeight - border - padding;
        },

        getTotalHeight: function (element) {
            /// <signature helpKeyword="TVJS.Utilities.getTotalHeight">
            /// <summary locid="TVJS.Utilities.getTotalHeight">
            /// Gets the height of the element, including its margins.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.getTotalHeight_p:element">
            /// The element.
            /// </param>
            /// <returns type="Number" locid="TVJS.Utilities.getTotalHeight_returnValue">
            /// The height of the element including margins.
            /// </returns>
            /// </signature>
            var margin = getDimension(element, "marginTop") + getDimension(element, "marginBottom");
            return element.offsetHeight + margin;
        },
        _getPreciseTotalHeight: function (element) {
            var margin = _getPreciseDimension(element, "marginTop") + _getPreciseDimension(element, "marginBottom");
            return element.offsetHeight + margin;
        },

        getPosition: function (element) {
            /// <signature helpKeyword="TVJS.Utilities.getPosition">
            /// <summary locid="TVJS.Utilities.getPosition">
            /// Gets the position of the specified element.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.getPosition_p:element">
            /// The element.
            /// </param>
            /// <returns type="Object" locid="TVJS.Utilities.getPosition_returnValue">
            /// An object that contains the left, top, width and height properties of the element.
            /// </returns>
            /// </signature>
            return exports._getPositionRelativeTo(element, null);
        },

        getTabIndex: function (element) {
            /// <signature helpKeyword="TVJS.Utilities.getTabIndex">
            /// <summary locid="TVJS.Utilities.getTabIndex">
            /// Gets the tabIndex of the specified element.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.getTabIndex_p:element">
            /// The element.
            /// </param>
            /// <returns type="Number" locid="TVJS.Utilities.getTabIndex_returnValue">
            /// The tabIndex of the element. Returns -1 if the element cannot be tabbed to
            /// </returns>
            /// </signature>
            // For reference: http://www.w3.org/html/wg/drafts/html/master/single-page.html#specially-focusable
            var tabbableElementsRE = /BUTTON|COMMAND|MENUITEM|OBJECT|SELECT|TEXTAREA/;
            if (element.disabled) {
                return -1;
            }
            var tabIndex = element.getAttribute("tabindex");
            if (tabIndex === null || tabIndex === undefined) {
                var name = element.tagName;
                if (tabbableElementsRE.test(name) ||
                    (element.href && (name === "A" || name === "AREA" || name === "LINK")) ||
                    (name === "INPUT" && element.type !== "hidden") ||
                    (name === "TH" && element.sorted)) {
                    return 0;
                }
                return -1;
            }
            return parseInt(tabIndex, 10);
        },

        convertToPixels: convertToPixels,
        _convertToPrecisePixels: _convertToPrecisePixels,
        _getPreciseMargins: _getPreciseMargins,


        eventWithinElement: function (element, event) {
            /// <signature helpKeyword="TVJS.Utilities.eventWithinElement">
            /// <summary locid="TVJS.Utilities.eventWithinElement">
            /// Determines whether the specified event occurred within the specified element.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.eventWithinElement_p:element">
            /// The element.
            /// </param>
            /// <param name="event" type="Event" locid="TVJS.Utilities.eventWithinElement_p:event">
            /// The event.
            /// </param>
            /// <returns type="Boolean" locid="TVJS.Utilities.eventWithinElement_returnValue">
            /// true if the event occurred within the element; otherwise, false.
            /// </returns>
            /// </signature>
            var related = event.relatedTarget;
            if (related && related !== element) {
                return element.contains(related);
            }

            return false;
        },

        //UI Utilities
        _deprecated: function (message) {
            _Global.console && _Global.console.warn(message);
        },

        // Take a renderer which may be a function (signature: (data) => element) or a TVJS.Binding.Template
        //  and return a function with a unified synchronous contract which is:
        //
        //  (data, container) => element
        //
        // Where:
        //
        //  1) if you pass container the content will be rendered into the container and the
        //     container will be returned.
        //
        //  2) if you don't pass a container the content will be rendered and returned.
        //
        _syncRenderer: function (renderer, tagName) {
            tagName = tagName || "div";
            if (typeof renderer === "function") {
                return function (data, container) {
                    if (container) {
                        container.appendChild(renderer(data));
                        return container;
                    } else {
                        return renderer(data);
                    }
                };
            }

            var template;
            if (typeof renderer.render === "function") {
                template = renderer;
            } else if (renderer.winControl && typeof renderer.winControl.render === "function") {
                template = renderer.winControl;
            }

            return function (data, container) {
                var host = container || _Global.document.createElement(tagName);
                template.render(data, host);
                if (container) {
                    return container;
                } else {
                    // The expectation is that the creation of the DOM elements happens synchronously
                    //  and as such we steal the first child and make it the root element.
                    //
                    var element = host.firstElementChild;

                    // Because we have changed the "root" we may need to move the dispose method
                    //  created by the template to the child and do a little switcheroo on dispose.
                    //
                    if (element && host.dispose) {
                        var prev = element.dispose;
                        element.dispose = function () {
                            element.dispose = prev;
                            host.appendChild(element);
                            host.dispose();
                        };
                    }
                    return element;
                }
            };
        },

        _getPositionRelativeTo: function Utilities_getPositionRelativeTo(element, ancestor) {
            var fromElement = element,
                offsetParent = element.offsetParent,
                top = element.offsetTop,
                left = element.offsetLeft;

            while ((element = element.parentNode) &&
                    element !== ancestor &&
                    element !== _Global.document.body &&
                    element !== _Global.document.documentElement) {
                top -= element.scrollTop;
                var dir = _getComputedStyle(element, null).direction;
                left -= dir !== "rtl" ? element.scrollLeft : -getAdjustedScrollPosition(element).scrollLeft;

                if (element === offsetParent) {
                    top += element.offsetTop;
                    left += element.offsetLeft;
                    offsetParent = element.offsetParent;
                }
            }

            return {
                left: left,
                top: top,
                width: fromElement.offsetWidth,
                height: fromElement.offsetHeight
            };
        },

        // *element* is not included in the tabIndex search
        _getHighAndLowTabIndices: function Utilities_getHighAndLowTabIndices(element) {
            var descendants = element.getElementsByTagName("*");
            var lowestTabIndex = 0;
            var highestTabIndex = 0;
            // tabIndex=0 is the highest (considered higher than positive tab indices) so
            // we can stop searching for a higher tab index once we find tabIndex=0.
            var foundTabIndex0 = false;
            for (var i = 0, len = descendants.length; i < len; i++) {
                var tabIndexStr = descendants[i].getAttribute("tabIndex");
                if (tabIndexStr !== null && tabIndexStr !== undefined) {
                    var tabIndex = parseInt(tabIndexStr, 10);
                    // Update lowest
                    if (tabIndex > 0 && (tabIndex < lowestTabIndex || lowestTabIndex === 0)) {
                        lowestTabIndex = tabIndex;
                    }
                    // Update highest
                    if (!foundTabIndex0) {
                        if (tabIndex === 0) {
                            foundTabIndex0 = true;
                            highestTabIndex = 0;
                        } else if (tabIndex > highestTabIndex) {
                            highestTabIndex = tabIndex;
                        }
                    }
                }
            }

            return {
                highest: highestTabIndex,
                lowest: lowestTabIndex
            };
        },

        _getLowestTabIndexInList: function Utilities_getLowestTabIndexInList(elements) {
            // Returns the lowest positive tabIndex in a list of elements.
            // Returns 0 if there are no positive tabIndices.
            var lowestTabIndex = 0;
            var elmTabIndex;
            for (var i = 0; i < elements.length; i++) {
                elmTabIndex = parseInt(elements[i].getAttribute("tabIndex"), 10);
                if ((0 < elmTabIndex)
                 && ((elmTabIndex < lowestTabIndex) || !lowestTabIndex)) {
                    lowestTabIndex = elmTabIndex;
                }
            }

            return lowestTabIndex;
        },

        _getHighestTabIndexInList: function Utilities_getHighestTabIndexInList(elements) {
            // Returns 0 if any element is explicitly set to 0. (0 is the highest tabIndex)
            // Returns the highest tabIndex in the list of elements.
            // Returns 0 if there are no positive tabIndices.
            var highestTabIndex = 0;
            var elmTabIndex;
            for (var i = 0; i < elements.length; i++) {
                elmTabIndex = parseInt(elements[i].getAttribute("tabIndex"), 10);
                if (elmTabIndex === 0) {
                    return elmTabIndex;
                } else if (highestTabIndex < elmTabIndex) {
                    highestTabIndex = elmTabIndex;
                }
            }

            return highestTabIndex;
        },

        _hasCursorKeysBehaviors: function Utilities_hasCursorKeysBehaviors(element) {
            if (element.tagName === "SELECT" ||
                element.tagName === "TEXTAREA") {
                return true;
            }
            if (element.tagName === "INPUT") {
                return element.type === "" ||
                    element.type === "date" ||
                    element.type === "datetime" ||
                    element.type === "datetime-local" ||
                    element.type === "email" ||
                    element.type === "month" ||
                    element.type === "number" ||
                    element.type === "password" ||
                    element.type === "range" ||
                    element.type === "search" ||
                    element.type === "tel" ||
                    element.type === "text" ||
                    element.type === "time" ||
                    element.type === "url" ||
                    element.type === "week";
            }
            return false;
        },

        _reparentChildren: function (originalParent, destinationParent) {
            var child = originalParent.firstChild;
            while (child) {
                var sibling = child.nextSibling;
                destinationParent.appendChild(child);
                child = sibling;
            }
        },

        // Ensures that the same element has focus before and after *callback* is
        // called. Useful if moving focus is an unintentional side effect of *callback*.
        // For example, this could happen if *callback* removes and reinserts elements
        // to the DOM.
        _maintainFocus: function ElementUtilities_maintainFocus(callback) {
            var focusedElement = _Global.document.activeElement;
            callback();
            exports._trySetActiveOnAnyElement(focusedElement);
        },
        
        // Tries to give focus to an element (even if its tabIndex is -1) via setActive.
        _trySetActiveOnAnyElement: function Utilities_trySetActiveOnAnyElement(element, scroller) {
            return exports._tryFocusOnAnyElement(element, true, scroller);
        },
        
        // Tries to give focus to an element (even if its tabIndex is -1).
        _tryFocusOnAnyElement: function Utilities_tryFocusOnAnyElement(element, useSetActive, scroller) {
            var previousActiveElement = _Global.document.activeElement;

            if (element === previousActiveElement) {
                return true;
            }
            
            if (useSetActive) {
                exports._setActive(element, scroller);
            } else {
                element.focus();
            }
            
            return previousActiveElement !== _Global.document.activeElement;
        },
        
        // Tries to give focus to an element which is a tabstop (i.e. tabIndex >= 0)
        // via setActive.
        _trySetActive: function Utilities_trySetActive(elem, scroller) {
            return this._tryFocus(elem, true, scroller);
        },
        
        // Tries to give focus to an element which is a tabstop (i.e. tabIndex >= 0).
        _tryFocus: function Utilities_tryFocus(elem, useSetActive, scroller) {
            var previousActiveElement = _Global.document.activeElement;

            if (elem === previousActiveElement) {
                return true;
            }

            var simpleLogicForValidTabStop = (exports.getTabIndex(elem) >= 0);
            if (!simpleLogicForValidTabStop) {
                return false;
            }

            if (useSetActive) {
                exports._setActive(elem, scroller);
            } else {
                elem.focus();
            }

            if (previousActiveElement !== _Global.document.activeElement) {
                return true;
            }
            return false;
        },

        _setActiveFirstFocusableElement: function Utilities_setActiveFirstFocusableElement(rootEl, scroller) {
            return this._focusFirstFocusableElement(rootEl, true, scroller);
        },

        _focusFirstFocusableElement: function Utilities_focusFirstFocusableElement(rootEl, useSetActive, scroller) {
            var _elms = rootEl.getElementsByTagName("*");

            // Get the tabIndex set to the firstDiv (which is the lowest)
            var _lowestTabIndex = this._getLowestTabIndexInList(_elms);
            var _nextLowestTabIndex = 0;

            // If there are positive tabIndices, set focus to the element with the lowest tabIndex.
            // Keep trying with the next lowest tabIndex until all tabIndices have been exhausted.
            // Otherwise set focus to the first focusable element in DOM order.
            var i;
            while (_lowestTabIndex) {
                for (i = 0; i < _elms.length; i++) {
                    if (_elms[i].tabIndex === _lowestTabIndex) {
                        if (this._tryFocus(_elms[i], useSetActive, scroller)) {
                            return true;
                        }
                    } else if ((_lowestTabIndex < _elms[i].tabIndex)
                            && ((_elms[i].tabIndex < _nextLowestTabIndex) || (_nextLowestTabIndex === 0))) {
                        // Here if _lowestTabIndex < _elms[i].tabIndex < _nextLowestTabIndex
                        _nextLowestTabIndex = _elms[i].tabIndex;
                    }
                }

                // We weren't able to set focus to anything at that tabIndex
                // If we found a higher valid tabIndex, try that now
                _lowestTabIndex = _nextLowestTabIndex;
                _nextLowestTabIndex = 0;
            }

            // Wasn't able to set focus to anything with a positive tabIndex, try everything now.
            // This is where things with tabIndex of 0 will be tried.
            for (i = 0; i < _elms.length; i++) {
                if (this._tryFocus(_elms[i], useSetActive, scroller)) {
                    return true;
                }
            }

            return false;
        },

        _setActiveLastFocusableElement: function Utilities_setActiveLastFocusableElement(rootEl, scroller) {
            return this._focusLastFocusableElement(rootEl, true, scroller);
        },

        _focusLastFocusableElement: function Utilities_focusLastFocusableElement(rootEl, useSetActive, scroller) {
            var _elms = rootEl.getElementsByTagName("*");
            // Get the tabIndex set to the finalDiv (which is the highest)
            var _highestTabIndex = this._getHighestTabIndexInList(_elms);
            var _nextHighestTabIndex = 0;

            // Try all tabIndex 0 first. After this conditional the _highestTabIndex
            // should be equal to the highest positive tabIndex.
            var i;
            if (_highestTabIndex === 0) {
                for (i = _elms.length - 1; i >= 0; i--) {
                    if (_elms[i].tabIndex === _highestTabIndex) {
                        if (this._tryFocus(_elms[i], useSetActive, scroller)) {
                            return true;
                        }
                    } else if (_nextHighestTabIndex < _elms[i].tabIndex) {
                        _nextHighestTabIndex = _elms[i].tabIndex;
                    }
                }

                _highestTabIndex = _nextHighestTabIndex;
                _nextHighestTabIndex = 0;
            }

            // If there are positive tabIndices, set focus to the element with the highest tabIndex.
            // Keep trying with the next highest tabIndex until all tabIndices have been exhausted.
            // Otherwise set focus to the last focusable element in DOM order.
            while (_highestTabIndex) {
                for (i = _elms.length - 1; i >= 0; i--) {
                    if (_elms[i].tabIndex === _highestTabIndex) {
                        if (this._tryFocus(_elms[i], useSetActive, scroller)) {
                            return true;
                        }
                    } else if ((_nextHighestTabIndex < _elms[i].tabIndex) && (_elms[i].tabIndex < _highestTabIndex)) {
                        // Here if _nextHighestTabIndex < _elms[i].tabIndex < _highestTabIndex
                        _nextHighestTabIndex = _elms[i].tabIndex;
                    }
                }

                // We weren't able to set focus to anything at that tabIndex
                // If we found a lower valid tabIndex, try that now
                _highestTabIndex = _nextHighestTabIndex;
                _nextHighestTabIndex = 0;
            }

            // Wasn't able to set focus to anything with a tabIndex, try everything now
            for (i = _elms.length - 2; i > 0; i--) {
                if (this._tryFocus(_elms[i], useSetActive, scroller)) {
                    return true;
                }
            }

            return false;
        }
    });
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_Dispose',[
    'exports',
    '../Core/_Base',
    './_ElementUtilities'
    ], function (exports, _Base, _ElementUtilities) {
    "use strict";

    function markDisposable(element, disposeImpl) {
            /// <signature helpKeyword="TVJS.Utilities.markDisposable">
            /// <summary locid="TVJS.Utilities.markDisposable">
            /// Adds the specified dispose implementation to the specified element and marks it as disposable.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.markDisposable_p:element">
            /// The element to mark as disposable.
            /// </param>
            /// <param name="disposeImpl" type="Function" locid="TVJS.Utilities.markDisposable_p:disposeImpl">
            /// The function containing the element-specific dispose logic that will be called by the dispose function.
            /// </param>
            /// </signature>
            var disposed = false;
            _ElementUtilities.addClass(element, "tv-disposable");

            var disposable = element.winControl || element;
            disposable.dispose = function () {
                if (disposed) {
                    return;
                }

                disposed = true;
                disposeSubTree(element);
                if (disposeImpl) {
                    disposeImpl();
                }
            };
        }

    function disposeSubTree(element) {
        /// <signature helpKeyword="TVJS.Utilities.disposeSubTree">
        /// <summary locid="TVJS.Utilities.disposeSubTree">
        /// Disposes all first-generation disposable elements that are descendents of the specified element.
        /// The specified element itself is not disposed.
        /// </summary>
        /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.disposeSubTree_p:element">
        /// The root element whose sub-tree is to be disposed.
        /// </param>
        /// </signature>
        if (!element) {
            return;
        }

        var query = element.querySelectorAll(".tv-disposable");

        var index = 0;
        var length = query.length;
        while (index < length) {
            var disposable = query[index];
            if (disposable.winControl && disposable.winControl.dispose) {
                disposable.winControl.dispose();
            }
            if (disposable.dispose) {
                disposable.dispose();
            }

            // Skip over disposable's descendants since they are this disposable's responsibility to clean up.
            index += disposable.querySelectorAll(".tv-disposable").length + 1;
        }
    }

    function _disposeElement(element) {
        // This helper should only be used for supporting dispose scenarios predating the dispose pattern.
        // The specified element should be well enough defined so we don't have to check whether it
        // a) has a disposable winControl,
        // b) is disposable itself,
        // or has disposable descendants in which case either a) or b) must have been true when designed correctly.
        if (!element) {
            return;
        }

        var disposed = false;
        if (element.winControl && element.winControl.dispose) {
            element.winControl.dispose();
            disposed = true;
        }
        if (element.dispose) {
            element.dispose();
            disposed = true;
        }

        if (!disposed) {
            disposeSubTree(element);
        }
    }

    _Base.Namespace._moduleDefine(exports, "TVJS.Utilities", {

        markDisposable: markDisposable,

        disposeSubTree: disposeSubTree,

        _disposeElement: _disposeElement
    });
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/ControlProcessor',[
    'exports',
    './Core/_Global',
    './Core/_Base',
    './Core/_BaseUtils',
    './Core/_Log',
    './Core/_Resources',
    './Promise',
    './Utilities/_ElementUtilities'
    ], function declarativeControlsInit(exports, _Global, _Base, _BaseUtils, _Log, _Resources, Promise, _ElementUtilities) {
    "use strict";

    // not supported in WebWorker
    if (!_Global.document) {
        return;
    }

    var strings = {
        get errorActivatingControl() { return "Error activating control: {0}"; },
    };

    var markSupportedForProcessing = _BaseUtils.markSupportedForProcessing;
    var requireSupportedForProcessing = _BaseUtils.requireSupportedForProcessing;
    var processedAllCalled = false;

    function createSelect(element) {
        var result = function select(selector) {
            /// <signature helpKeyword="TVJS.UI.select.createSelect">
            /// <summary locid="TVJS.UI.select.createSelect">
            /// Walks the DOM tree from the given  element to the root of the document, whenever
            /// a selector scope is encountered select performs a lookup within that scope for
            /// the given selector string. The first matching element is returned.
            /// </summary>
            /// <param name="selector" type="String" locid="TVJS.UI.select.createSelect_p:selector">The selector string.</param>
            /// <returns type="HTMLElement" domElement="true" locid="TVJS.UI.select.createSelect_returnValue">The target element, if found.</returns>
            /// </signature>
            var current = element;
            var selected;
            while (current) {
                if (current.msParentSelectorScope) {
                    var scope = current.parentNode;
                    if (scope) {
                        selected = _ElementUtilities._matchesSelector(scope, selector) ? scope : scope.querySelector(selector);
                        if (selected) {
                            break;
                        }
                    }
                }
                current = current.parentNode;
            }

            return selected || _Global.document.querySelector(selector);
        };
        return markSupportedForProcessing(result);
    };

    function activate(element, Handler) {
        return new Promise(function activate2(complete, error) {
            try {
                var options;
                var optionsAttribute = element.getAttribute("data-tv-options");
                if (optionsAttribute) {
                    options = _OptionsParser.optionsParser(optionsAttribute, _Global, {
                        select: createSelect(element)
                    });
                }

                var ctl;
                var count = 1;

                // handler is required to call complete if it takes that parameter
                //
                if (Handler.length > 2) {
                    count++;
                }
                var checkComplete = function checkComplete() {
                    count--;
                    if (count === 0) {
                        element.winControl = element.winControl || ctl;
                        complete(ctl);
                    }
                };

                // async exceptions from the handler get dropped on the floor...
                //
                ctl = new Handler(element, options, checkComplete);
                checkComplete();
            }
            catch (err) {
                _Log.log && _Log.log(_Resources._formatString(strings.errorActivatingControl, err && err.message), "TVJS controls", "error");
                error(err);
            }
        });
    };

    function processAllImpl(rootElement, skipRootElement) {
        return new Promise(function processAllImpl2(complete, error) {
            rootElement = rootElement || _Global.document.body;
            var pending = 0;
            var selector = "[data-tv-control]";
            var allElements = rootElement.querySelectorAll(selector);
            var elements = [];
            if (!skipRootElement && getControlHandler(rootElement)) {
                elements.push(rootElement);
            }
            for (var i = 0, len = allElements.length; i < len; i++) {
                elements.push(allElements[i]);
            }

            // bail early if there is nothing to process
            //
            if (elements.length === 0) {
                complete(rootElement);
                return;
            }

            var checkAllComplete = function () {
                pending = pending - 1;
                if (pending < 0) {
                    complete(rootElement);
                }
            };

            // First go through and determine which elements to activate
            //
            var controls = new Array(elements.length);
            for (var i = 0, len = elements.length; i < len; i++) {
                var element = elements[i];
                var control;
                var instance = element.winControl;
                if (instance) {
                    control = instance.constructor;
                    // already activated, don't need to add to controls array
                } else {
                    controls[i] = control = getControlHandler(element);
                }
                if (control && control.isDeclarativeControlContainer) {
                    i += element.querySelectorAll(selector).length;
                }
            }

            // Now go through and activate those
            //
            for (var i = 0, len = elements.length; i < len; i++) {
                var ctl = controls[i];
                var element = elements[i];
                if (ctl && !element.winControl) {
                    pending++;
                    activate(element, ctl).then(checkAllComplete, function (e) {
                        error(e);
                    });

                    if (ctl.isDeclarativeControlContainer && typeof ctl.isDeclarativeControlContainer === "function") {
                        var idcc = requireSupportedForProcessing(ctl.isDeclarativeControlContainer);
                        idcc(element.winControl, processAll);
                    }
                }
            }

            checkAllComplete();
        });
    };

    function getControlHandler(element) {
        if (element.getAttribute) {
            var evaluator = element.getAttribute("data-tv-control");
            if (evaluator) {
                return _BaseUtils._getMemberFiltered(evaluator.trim(), _Global, requireSupportedForProcessing);
            }
        }
    };

    function scopedSelect(selector, element) {
        /// <signature helpKeyword="TVJS.UI.scopedSelect">
        /// <summary locid="TVJS.UI.scopedSelect">
        /// Walks the DOM tree from the given  element to the root of the document, whenever
        /// a selector scope is encountered select performs a lookup within that scope for
        /// the given selector string. The first matching element is returned.
        /// </summary>
        /// <param name="selector" type="String" locid="TVJS.UI.scopedSelect_p:selector">The selector string.</param>
        /// <returns type="HTMLElement" domElement="true" locid="TVJS.UI.scopedSelect_returnValue">The target element, if found.</returns>
        /// </signature>
        return createSelect(element)(selector);
    };

    function processAll(rootElement, skipRoot) {
        /// <signature helpKeyword="TVJS.UI.processAll">
        /// <summary locid="TVJS.UI.processAll">
        /// Applies declarative control binding to all elements, starting at the specified root element.
        /// </summary>
        /// <param name="rootElement" type="Object" domElement="true" locid="TVJS.UI.processAll_p:rootElement">
        /// The element at which to start applying the binding. If this parameter is not specified, the binding is applied to the entire document.
        /// </param>
        /// <param name="skipRoot" type="Boolean" optional="true" locid="TVJS.UI.processAll_p:skipRoot">
        /// If true, the elements to be bound skip the specified root element and include only the children.
        /// </param>
        /// <returns type="TVJS.Promise" locid="TVJS.UI.processAll_returnValue">
        /// A promise that is fulfilled when binding has been applied to all the controls.
        /// </returns>
        /// </signature>
        if (!processedAllCalled) {
            return _BaseUtils.ready().then(function () {
                processedAllCalled = true;
                return processAllImpl(rootElement, skipRoot);
            });
        } else {
            return processAllImpl(rootElement, skipRoot);
        }
    };

    function process(element) {
        /// <signature helpKeyword="TVJS.UI.process">
        /// <summary locid="TVJS.UI.process">
        /// Applies declarative control binding to the specified element.
        /// </summary>
        /// <param name="element" type="Object" domElement="true" locid="TVJS.UI.process_p:element">
        /// The element to bind.
        /// </param>
        /// <returns type="TVJS.Promise" locid="TVJS.UI.process_returnValue">
        /// A promise that is fulfilled after the control is activated. The value of the
        /// promise is the control that is attached to element.
        /// </returns>
        /// </signature>

        if (element && element.winControl) {
            return Promise.as(element.winControl);
        }
        var handler = getControlHandler(element);
        if (!handler) {
            return Promise.as(); // undefined, no handler
        } else {
            return activate(element, handler);
        }
    };

    _Base.Namespace._moduleDefine(exports, "TVJS.UI", {
        scopedSelect: scopedSelect,
        processAll: processAll,
        process: process
    });
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_ElementListUtilities',[
    'exports',
    '../Core/_Global',
    '../Core/_Base',
    '../ControlProcessor',
    '../Promise',
    '../Utilities/_Control',
    '../Utilities/_ElementUtilities'
    ], function elementListUtilities(exports, _Global, _Base, ControlProcessor, Promise, _Control, _ElementUtilities) {
    "use strict";

    // not supported in WebWorker
    if (!_Global.document) {
        return;
    }

    _Base.Namespace._moduleDefine(exports, "TVJS.Utilities", {
        QueryCollection: _Base.Class.derive(Array, function (items) {
            /// <signature helpKeyword="TVJS.Utilities.QueryCollection">
            /// <summary locid="TVJS.Utilities.QueryCollection">
            /// Represents the result of a query selector, and provides
            /// various operations that perform actions over the elements of
            /// the collection.
            /// </summary>
            /// <param name="items" locid="TVJS.Utilities.QueryCollection_p:items">
            /// The items resulting from the query.
            /// </param>
            /// </signature>
            if (items) {
                this.include(items);
            }
        }, {
            forEach: function (callbackFn, thisArg) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.forEach">
                /// <summary locid="TVJS.Utilities.QueryCollection.forEach">
                /// Performs an action on each item in the QueryCollection
                /// </summary>
                /// <param name="callbackFn" type="function(value, Number index, traversedObject)" locid="TVJS.Utilities.QueryCollection.forEach_p:callbackFn">
                /// Action to perform on each item.
                /// </param>
                /// <param name="thisArg" isOptional="true" type="function(value, Number index, traversedObject)" locid="TVJS.Utilities.QueryCollection.forEach_p:thisArg">
                /// Argument to bind to callbackFn
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.forEach_returnValue">
                /// Returns the QueryCollection
                /// </returns>
                /// </signature>
                Array.prototype.forEach.apply(this, [callbackFn, thisArg]);
                return this;
            },
            get: function (index) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.get">
                /// <summary locid="TVJS.Utilities.QueryCollection.get">
                /// Gets an item from the QueryCollection.
                /// </summary>
                /// <param name="index" type="Number" locid="TVJS.Utilities.QueryCollection.get_p:index">
                /// The index of the item to return.
                /// </param>
                /// <returns type="Object" locid="TVJS.Utilities.QueryCollection.get_returnValue">
                /// A single item from the collection.
                /// </returns>
                /// </signature>
                return this[index];
            },
            setAttribute: function (name, value) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.setAttribute">
                /// <summary locid="TVJS.Utilities.QueryCollection.setAttribute">
                /// Sets an attribute value on all the items in the collection.
                /// </summary>
                /// <param name="name" type="String" locid="TVJS.Utilities.QueryCollection.setAttribute_p:name">
                /// The name of the attribute to be set.
                /// </param>
                /// <param name="value" type="String" locid="TVJS.Utilities.QueryCollection.setAttribute_p:value">
                /// The value of the attribute to be set.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.setAttribute_returnValue">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>
                this.forEach(function (item) {
                    item.setAttribute(name, value);
                });
                return this;
            },
            getAttribute: function (name) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.getAttribute">
                /// <summary locid="TVJS.Utilities.QueryCollection.getAttribute">
                /// Gets an attribute value from the first element in the collection.
                /// </summary>
                /// <param name="name" type="String" locid="TVJS.Utilities.QueryCollection.getAttribute_p:name">
                /// The name of the attribute.
                /// </param>
                /// <returns type="String" locid="TVJS.Utilities.QueryCollection.getAttribute_returnValue">
                /// The value of the attribute.
                /// </returns>
                /// </signature>
                if (this.length > 0) {
                    return this[0].getAttribute(name);
                }
            },
            addClass: function (name) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.addClass">
                /// <summary locid="TVJS.Utilities.QueryCollection.addClass">
                /// Adds the specified class to all the elements in the collection.
                /// </summary>
                /// <param name="name" type="String" locid="TVJS.Utilities.QueryCollection.addClass_p:name">
                /// The name of the class to add.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.addClass_returnValue">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>
                this.forEach(function (item) {
                    _ElementUtilities.addClass(item, name);
                });
                return this;
            },
            hasClass: function (name) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.hasClass">
                /// <summary locid="TVJS.Utilities.QueryCollection.hasClass">
                /// Determines whether the specified class exists on the first element of the collection.
                /// </summary>
                /// <param name="name" type="String" locid="TVJS.Utilities.QueryCollection.hasClass_p:name">
                /// The name of the class.
                /// </param>
                /// <returns type="Boolean" locid="TVJS.Utilities.QueryCollection.hasClass_returnValue">
                /// true if the element has the specified class; otherwise, false.
                /// </returns>
                /// </signature>
                if (this.length > 0) {
                    return _ElementUtilities.hasClass(this[0], name);
                }
                return false;
            },
            removeClass: function (name) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.removeClass">
                /// <summary locid="TVJS.Utilities.QueryCollection.removeClass">
                /// Removes the specified class from all the elements in the collection.
                /// </summary>
                /// <param name="name" type="String" locid="TVJS.Utilities.QueryCollection.removeClass_p:name">
                /// The name of the class to be removed.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.removeClass_returnValue">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>
                this.forEach(function (item) {
                    _ElementUtilities.removeClass(item, name);
                });
                return this;
            },
            toggleClass: function (name) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.toggleClass">
                /// <summary locid="TVJS.Utilities.QueryCollection.toggleClass">
                /// Toggles (adds or removes) the specified class on all the elements in the collection.
                /// If the class is present, it is removed; if it is absent, it is added.
                /// </summary>
                /// <param name="name" type="String" locid="TVJS.Utilities.QueryCollection.toggleClass_p:name">
                /// The name of the class to be toggled.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.toggleClass_returnValue">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>
                this.forEach(function (item) {
                    _ElementUtilities.toggleClass(item, name);
                });
                return this;
            },
            listen: function (eventType, listener, capture) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.listen">
                /// <summary locid="TVJS.Utilities.QueryCollection.listen">
                /// Registers the listener for the specified event on all the elements in the collection.
                /// </summary>
                /// <param name="eventType" type="String" locid="TVJS.Utilities.QueryCollection.listen_p:eventType">
                /// The name of the event.
                /// </param>
                /// <param name="listener" type="Function" locid="TVJS.Utilities.QueryCollection.listen_p:listener">
                /// The event handler function to be called when the event occurs.
                /// </param>
                /// <param name="capture" type="Boolean" locid="TVJS.Utilities.QueryCollection.listen_p:capture">
                /// true if capture == true is to be passed to addEventListener; otherwise, false.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.listen_returnValue">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>
                this.forEach(function (item) {
                    item.addEventListener(eventType, listener, capture);
                });
                return this;
            },
            removeEventListener: function (eventType, listener, capture) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.removeEventListener">
                /// <summary locid="TVJS.Utilities.QueryCollection.removeEventListener">
                /// Unregisters the listener for the specified event on all the elements in the collection.
                /// </summary>
                /// <param name="eventType" type="String" locid="TVJS.Utilities.QueryCollection.removeEventListener_p:eventType">
                /// The name of the event.
                /// </param>
                /// <param name="listener" type="Function" locid="TVJS.Utilities.QueryCollection.removeEventListener_p:listener">
                /// The event handler function.
                /// </param>
                /// <param name="capture" type="Boolean" locid="TVJS.Utilities.QueryCollection.removeEventListener_p:capture">
                /// true if capture == true; otherwise, false.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.removeEventListener_returnValue">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>
                this.forEach(function (item) {
                    item.removeEventListener(eventType, listener, capture);
                });
                return this;
            },
            setStyle: function (name, value) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.setStyle">
                /// <summary locid="TVJS.Utilities.QueryCollection.setStyle">
                /// Sets the specified style property for all the elements in the collection.
                /// </summary>
                /// <param name="name" type="String" locid="TVJS.Utilities.QueryCollection.setStyle_p:name">
                /// The name of the style property.
                /// </param>
                /// <param name="value" type="String" locid="TVJS.Utilities.QueryCollection.setStyle_p:value">
                /// The value for the property.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.setStyle_returnValue">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>
                this.forEach(function (item) {
                    item.style[name] = value;
                });
                return this;
            },
            clearStyle: function (name) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.clearStyle">
                /// <summary locid="TVJS.Utilities.QueryCollection.clearStyle">
                /// Clears the specified style property for all the elements in the collection.
                /// </summary>
                /// <param name="name" type="String" locid="TVJS.Utilities.QueryCollection.clearStyle_p:name">
                /// The name of the style property to be cleared.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.clearStyle_returnValue">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>
                this.forEach(function (item) {
                    item.style[name] = "";
                });
                return this;
            },
            query: function (query) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.query">
                /// <summary locid="TVJS.Utilities.QueryCollection.query">
                /// Executes a query selector on all the elements in the collection
                /// and aggregates the result into a QueryCollection.
                /// </summary>
                /// <param name="query" type="String" locid="TVJS.Utilities.QueryCollection.query_p:query">
                /// The query selector string.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.query_returnValue">
                /// A QueryCollection object containing the aggregate results of
                /// executing the query on all the elements in the collection.
                /// </returns>
                /// </signature>
                var newCollection = new exports.QueryCollection();
                this.forEach(function (item) {
                    newCollection.include(item.querySelectorAll(query));
                });
                return newCollection;
            },
            include: function (items) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.include">
                /// <summary locid="TVJS.Utilities.QueryCollection.include">
                /// Adds a set of items to this QueryCollection.
                /// </summary>
                /// <param name="items" locid="TVJS.Utilities.QueryCollection.include_p:items">
                /// The items to add to the QueryCollection. This may be an
                /// array-like object, a document fragment, or a single item.
                /// </param>
                /// </signature>
                if (typeof items.length === "number") {
                    for (var i = 0; i < items.length; i++) {
                        this.push(items[i]);
                    }
                } else if (items.DOCUMENT_FRAGMENT_NODE && items.nodeType === items.DOCUMENT_FRAGMENT_NODE) {
                    this.include(items.childNodes);
                } else {
                    this.push(items);
                }
            },
            control: function (Ctor, options) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.control">
                /// <summary locid="TVJS.Utilities.QueryCollection.control">
                /// Creates controls that are attached to the elements in this QueryCollection.
                /// </summary>
                /// <param name='Ctor' locid="TVJS.Utilities.QueryCollection.control_p:ctor">
                /// A constructor function that is used to create controls to attach to the elements.
                /// </param>
                /// <param name='options' locid="TVJS.Utilities.QueryCollection.control_p:options">
                /// The options passed to the newly-created controls.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.control_returnValue">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>
                /// <signature>
                /// <summary locid="TVJS.Utilities.QueryCollection.control2">
                /// Configures the controls that are attached to the elements in this QueryCollection.
                /// </summary>
                /// <param name='ctor' locid="TVJS.Utilities.QueryCollection.control_p:ctor2">
                /// The options passed to the controls.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.control_returnValue2">
                /// This QueryCollection object.
                /// </returns>
                /// </signature>

                if (Ctor && typeof (Ctor) === "function") {
                    this.forEach(function (element) {
                        element.winControl = new Ctor(element, options);
                    });
                } else {
                    options = Ctor;
                    this.forEach(function (element) {
                        ControlProcessor.process(element).done(function (control) {
                            control && _Control.setOptions(control, options);
                        });
                    });
                }
                return this;
            },
            template: function (templateElement, data, renderDonePromiseCallback) {
                /// <signature helpKeyword="TVJS.Utilities.QueryCollection.template">
                /// <summary locid="TVJS.Utilities.QueryCollection.template">
                /// Renders a template that is bound to the given data
                /// and parented to the elements included in the QueryCollection.
                /// If the QueryCollection contains multiple elements, the template
                /// is rendered multiple times, once at each element in the QueryCollection
                /// per item of data passed.
                /// </summary>
                /// <param name="templateElement" type="DOMElement" locid="TVJS.Utilities.QueryCollection.template_p:templateElement">
                /// The DOM element to which the template control is attached to.
                /// </param>
                /// <param name="data" type="Object" locid="TVJS.Utilities.QueryCollection.template_p:data">
                /// The data to render. If the data is an array (or any other object
                /// that has a forEach method) then the template is rendered
                /// multiple times, once for each item in the collection.
                /// </param>
                /// <param name="renderDonePromiseCallback" type="Function" locid="TVJS.Utilities.QueryCollection.template_p:renderDonePromiseCallback">
                /// If supplied, this function is called
                /// each time the template gets rendered, and is passed a promise
                /// that is fulfilled when the template rendering is complete.
                /// </param>
                /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.QueryCollection.template_returnValue">
                /// The QueryCollection.
                /// </returns>
                /// </signature>
                if (templateElement instanceof exports.QueryCollection) {
                    templateElement = templateElement[0];
                }
                var template = templateElement.winControl;

                if (data === null || data === undefined || !data.forEach) {
                    data = [data];
                }

                renderDonePromiseCallback = renderDonePromiseCallback || function () { };

                var that = this;
                var donePromises = [];
                data.forEach(function (datum) {
                    that.forEach(function (element) {
                        donePromises.push(template.render(datum, element));
                    });
                });
                renderDonePromiseCallback(Promise.join(donePromises));

                return this;
            }
        }, {
            supportedForProcessing: false,
        }),

        query: function (query, element) {
            /// <signature helpKeyword="TVJS.Utilities.query">
            /// <summary locid="TVJS.Utilities.query">
            /// Executes a query selector on the specified element or the entire document.
            /// </summary>
            /// <param name="query" type="String" locid="TVJS.Utilities.query_p:query">
            /// The query selector to be executed.
            /// </param>
            /// <param name="element" optional="true" type="HTMLElement" locid="TVJS.Utilities.query_p:element">
            /// The element on which to execute the query. If this parameter is not specified, the
            /// query is executed on the entire document.
            /// </param>
            /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.query_returnValue">
            /// The QueryCollection that contains the results of the query.
            /// </returns>
            /// </signature>
            return new exports.QueryCollection((element || _Global.document).querySelectorAll(query));
        },

        id: function (id) {
            /// <signature helpKeyword="TVJS.Utilities.id">
            /// <summary locid="TVJS.Utilities.id">
            /// Looks up an element by ID and wraps the result in a QueryCollection.
            /// </summary>
            /// <param name="id" type="String" locid="TVJS.Utilities.id_p:id">
            /// The ID of the element.
            /// </param>
            /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.id_returnValue">
            /// A QueryCollection that contains the element, if it is found.
            /// </returns>
            /// </signature>
            var e = _Global.document.getElementById(id);
            return new exports.QueryCollection(e ? [e] : []);
        },

        children: function (element) {
            /// <signature helpKeyword="TVJS.Utilities.children">
            /// <summary locid="TVJS.Utilities.children">
            /// Creates a QueryCollection that contains the children of the specified parent element.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.children_p:element">
            /// The parent element.
            /// </param>
            /// <returns type="TVJS.Utilities.QueryCollection" locid="TVJS.Utilities.children_returnValue">
            /// The QueryCollection that contains the children of the element.
            /// </returns>
            /// </signature>
            return new exports.QueryCollection(element.children);
        }
    });
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_Hoverable',[
    'exports',
    '../Core/_Global'
], function hoverable(exports, _Global) {
    "use strict";

    // not supported in WebWorker
    if (!_Global.document) {
        return;
    }

    _Global.document.documentElement.classList.add("tv-hoverable");
    exports.isHoverable = true;

    if (!_Global.MSPointerEvent) {
        var touchStartHandler = function () {
            _Global.document.removeEventListener("touchstart", touchStartHandler);
            // Remove tv-hoverable CSS class fromstartt . <html> to avoid :hover styles in webkit when there is
            // touch support.
            _Global.document.documentElement.classList.remove("tv-hoverable");
            exports.isHoverable = false;
        };

        _Global.document.addEventListener("touchstart", touchStartHandler);
    }
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_KeyboardBehavior',[
    'exports',
    '../Core/_Global',
    '../Core/_Base',
    './_Control',
    './_ElementUtilities'
], function KeyboardBehaviorInit(exports, _Global, _Base, _Control, _ElementUtilities) {
    "use strict";

    // not supported in WebWorker
    if (!_Global.document) {
        return;
    }
    
    var InputTypes = {
        touch: "touch",
        pen: "pen",
        mouse: "mouse",
        keyboard: "keyboard"
    };
    var _lastInputType = InputTypes.mouse;
    
    // Keys should be the same as the values for a PointerEvent's pointerType.
    var pointerTypeToInputType = {
        // IE 10 uses numbers for its pointerType
        2: InputTypes.touch,
        3: InputTypes.pen,
        4: InputTypes.mouse,
        
        // Others use strings for their pointerTypes
        touch: InputTypes.touch,
        pen: InputTypes.pen,
        mouse: InputTypes.mouse
    };

    _ElementUtilities._addEventListener(_Global, "pointerdown", function (eventObject) {
        _lastInputType = pointerTypeToInputType[eventObject.pointerType] || InputTypes.mouse;
    }, true);

    _Global.addEventListener("keydown", function () {
        _lastInputType = InputTypes.keyboard;
    }, true);

    _Base.Namespace._moduleDefine(exports, "TVJS.UI", {
        _keyboardSeenLast: {
            get: function _keyboardSeenLast_get() {
                return _lastInputType === InputTypes.keyboard;
            },
            set: function _keyboardSeenLast_set(value) {
                _lastInputType = (value ? InputTypes.keyboard : InputTypes.mouse);
            }
        },
        _lastInputType: {
            get: function _lastInputType_get() {
                return _lastInputType;
            },
            set: function _lastInputType_set(value) {
                if (InputTypes[value]) {
                    _lastInputType = value;
                }
            }
        },
        _InputTypes: InputTypes,
        _WinKeyboard: function (element) {
            // Win Keyboard behavior is a solution that would be similar to -ms-keyboard-focus.
            // It monitors the last input (keyboard/mouse) and adds/removes a tv-keyboard class
            // so that you can style .foo.tv-keyboard:focus vs .foo:focus to add a keyboard rect
            // on an item only when the last input method was keyboard.
            // Reminder: Touch edgy does not count as an input method.
            _ElementUtilities._addEventListener(element, "pointerdown", function (ev) {
                // In case pointer down came on the active element.
                _ElementUtilities.removeClass(ev.target, "tv-keyboard");
            }, true);
            element.addEventListener("keydown", function (ev) {
                _ElementUtilities.addClass(ev.target, "tv-keyboard");
            }, true);
            _ElementUtilities._addEventListener(element, "focusin", function (ev) {
                exports._keyboardSeenLast && _ElementUtilities.addClass(ev.target, "tv-keyboard");
            }, false);
            _ElementUtilities._addEventListener(element, "focusout", function (ev) {
                _ElementUtilities.removeClass(ev.target, "tv-keyboard");
            }, false);
        },
        _KeyboardBehavior: _Base.Namespace._lazy(function () {
            var Key = _ElementUtilities.Key;

            var _KeyboardBehavior = _Base.Class.define(function KeyboardBehavior_ctor(element, options) {
                // KeyboardBehavior allows you to easily convert a bunch of tabable elements into a single tab stop with
                // navigation replaced by keyboard arrow (Up/Down/Left/Right) + Home + End + Custom keys.
                //
                // Example use cases:
                //
                // 1 Dimensional list: FixedDirection = height and FixedSize = 1;
                // [1] [ 2 ] [  3  ] [4] [  5  ]...
                //
                // 2 Dimensional list: FixedDirection = height and FixedSize = 2;
                // [1] [3] [5] [7] ...
                // [2] [4] [6] [8]
                //
                // 1 Dimensional list: FixedDirection = width and FixedSize = 1;
                // [ 1 ]
                // -   -
                // |   |
                // | 2 |
                // |   |
                // -   -
                // [ 3 ]
                // [ 4 ]
                //  ...
                //
                // 2 Dimensional list: FixedDirection = width and FixedSize = 2;
                // [1][2]
                // [3][4]
                // [5][6]
                // ...
                //
                // Currently it is a "behavior" instead of a "control" so it can be attached to the same element as a
                // winControl. The main scenario for this would be to attach it to the same element as a repeater.
                //
                // It also blocks "Portaling" where you go off the end of one column and wrap around to the other
                // column. It also blocks "Carousel" where you go from the end of the list to the beginning.
                //
                // Keyboarding behavior supports nesting. It supports your tab stops having sub tab stops. If you want
                // an interactive element within the tab stop you need to use the tv-interactive classname or during the
                // keydown event stop propogation so that the event is skipped.
                //
                // If you have custom keyboarding the getAdjacent API is provided. This can be used to enable keyboarding
                // in multisize 2d lists or custom keyboard commands. PageDown and PageUp are the most common since this
                // behavior does not detect scrollers.
                //
                // It also allows developers to show/hide keyboard focus rectangles themselves.
                //
                // It has an API called currentIndex so that Tab (or Shift+Tab) or a developer imitating Tab will result in
                // the correct item having focus.
                //
                // It also allows an element to be represented as 2 arrow stops (commonly used for a split button) by calling
                // the _getFocusInto API on the child element's winControl if it exists.

                element = element || _Global.document.createElement("DIV");
                options = options || {};

                element._keyboardBehavior = this;
                this._element = element;

                this._fixedDirection = _KeyboardBehavior.FixedDirection.width;
                this._fixedSize = 1;
                this._currentIndex = 0;

                _Control.setOptions(this, options);

                // If there's a scroller, the TabContainer can't be inside of the scroller. Otherwise, tabbing into the
                // TabContainer will cause the scroller to scroll.
                this._tabContainer = new _TabContainer.TabContainer(this.scroller || this._element);
                this._tabContainer.tabIndex = 0;
                if (this._element.children.length > 0) {
                    this._tabContainer.childFocus = this._getFocusInto(this._element.children[0]);
                }

                this._element.addEventListener('keydown', this._keyDownHandler.bind(this));
                _ElementUtilities._addEventListener(this._element, 'pointerdown', this._MSPointerDownHandler.bind(this));
            }, {
                element: {
                    get: function () {
                        return this._element;
                    }
                },

                fixedDirection: {
                    get: function () {
                        return this._fixedDirection;
                    },
                    set: function (value) {
                        this._fixedDirection = value;
                    }
                },

                fixedSize: {
                    get: function () {
                        return this._fixedSize;
                    },
                    set: function (value) {
                        if (+value === value) {
                            value = Math.max(1, value);
                            this._fixedSize = value;
                        }
                    }
                },

                currentIndex: {
                    get: function () {
                        if (this._element.children.length > 0) {
                            return this._currentIndex;
                        }
                        return -1;
                    },
                    set: function (value) {
                        if (+value === value) {
                            var length = this._element.children.length;
                            value = Math.max(0, Math.min(length - 1, value));
                            this._currentIndex = value;
                            this._tabContainer.childFocus = this._getFocusInto(this._element.children[value]);
                        }
                    }
                },

                getAdjacent: {
                    get: function () {
                        return this._getAdjacent;
                    },
                    set: function (value) {
                        this._getAdjacent = value;
                    }
                },

                // If set, KeyboardBehavior will prevent *scroller* from scrolling when moving focus
                scroller: {
                    get: function () {
                        return this._scroller;
                    },
                    set: function (value) {
                        this._scroller = value;
                    }
                },

                _keyDownHandler: function _KeyboardBehavior_keyDownHandler(ev) {
                    if (!ev.altKey) {
                        if (_ElementUtilities._matchesSelector(ev.target, ".tv-interactive, .tv-interactive *")) {
                            return;
                        }
                        var newIndex = this.currentIndex;
                        var maxIndex = this._element.children.length - 1;

                        var rtl = _ElementUtilities._getComputedStyle(this._element).direction === "rtl";
                        var leftStr = rtl ? Key.rightArrow : Key.leftArrow;
                        var rightStr = rtl ? Key.leftArrow : Key.rightArrow;

                        var targetIndex = this.getAdjacent && this.getAdjacent(newIndex, ev.keyCode);
                        if (+targetIndex === targetIndex) {
                            newIndex = targetIndex;
                        } else {
                            var modFixedSize = newIndex % this.fixedSize;

                            if (ev.keyCode === leftStr) {
                                if (this.fixedDirection === _KeyboardBehavior.FixedDirection.width) {
                                    if (modFixedSize !== 0) {
                                        newIndex--;
                                    }
                                } else {
                                    if (newIndex >= this.fixedSize) {
                                        newIndex -= this.fixedSize;
                                    }
                                }
                            } else if (ev.keyCode === rightStr) {
                                if (this.fixedDirection === _KeyboardBehavior.FixedDirection.width) {
                                    if (modFixedSize !== this.fixedSize - 1) {
                                        newIndex++;
                                    }
                                } else {
                                    if (newIndex + this.fixedSize - modFixedSize <= maxIndex) {
                                        newIndex += this.fixedSize;
                                    }
                                }
                            } else if (ev.keyCode === Key.upArrow) {
                                if (this.fixedDirection === _KeyboardBehavior.FixedDirection.height) {
                                    if (modFixedSize !== 0) {
                                        newIndex--;
                                    }
                                } else {
                                    if (newIndex >= this.fixedSize) {
                                        newIndex -= this.fixedSize;
                                    }
                                }
                            } else if (ev.keyCode === Key.downArrow) {
                                if (this.fixedDirection === _KeyboardBehavior.FixedDirection.height) {
                                    if (modFixedSize !== this.fixedSize - 1) {
                                        newIndex++;
                                    }
                                } else {
                                    if (newIndex + this.fixedSize - modFixedSize <= maxIndex) {
                                        newIndex += this.fixedSize;
                                    }
                                }
                            } else if (ev.keyCode === Key.home) {
                                newIndex = 0;
                            } else if (ev.keyCode === Key.end) {
                                newIndex = this._element.children.length - 1;
                            }
                        }

                        newIndex = Math.max(0, Math.min(this._element.children.length - 1, newIndex));

                        if (newIndex !== this.currentIndex) {
                            this._focus(newIndex, ev.keyCode);

                            // Allow KeyboardBehavior to be nested
                            if (ev.keyCode === leftStr || ev.keyCode === rightStr || ev.keyCode === Key.upArrow || ev.keyCode === Key.downArrow) {
                                ev.stopPropagation();
                            }

                            ev.preventDefault();
                        }
                    }
                },

                _getFocusInto: function _KeyboardBehavior_getFocusInto(elementToFocus, keyCode) {
                    return elementToFocus && elementToFocus.winControl && elementToFocus.winControl._getFocusInto ?
                        elementToFocus.winControl._getFocusInto(keyCode) :
                        elementToFocus;
                },

                _focus: function _KeyboardBehavior_focus(index, keyCode) {
                    index = (+index === index) ? index : this.currentIndex;

                    var elementToFocus = this._element.children[index];
                    if (elementToFocus) {
                        elementToFocus = this._getFocusInto(elementToFocus, keyCode);

                        this.currentIndex = index;

                        _ElementUtilities._setActive(elementToFocus, this.scroller);
                    }
                },

                _MSPointerDownHandler: function _KeyboardBehavior_MSPointerDownHandler(ev) {
                    var srcElement = ev.target;
                    if (srcElement === this.element) {
                        return;
                    }

                    while (srcElement.parentNode !== this.element) {
                        srcElement = srcElement.parentNode;
                    }

                    var index = -1;
                    while (srcElement) {
                        index++;
                        srcElement = srcElement.previousElementSibling;
                    }

                    this.currentIndex = index;
                }
            }, {
                FixedDirection: {
                    height: "height",
                    width: "width"
                }
            });

            return _KeyboardBehavior;
        })
    });

});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_SafeHtml',[
    'exports',
    '../Core/_TVJS',
    '../Core/_Global',
    '../Core/_Base',
    '../Core/_ErrorFromName',
    '../Core/_Resources'
    ], function safeHTMLInit(exports, _TVJS, _Global, _Base, _ErrorFromName, _Resources) {
    "use strict";


    var setInnerHTML,
        setInnerHTMLUnsafe,
        setOuterHTML,
        setOuterHTMLUnsafe,
        insertAdjacentHTML,
        insertAdjacentHTMLUnsafe;

    var strings = {
        get nonStaticHTML() { return "Unable to add dynamic content. A script attempted to inject dynamic content, or elements previously modified dynamically, that might be unsafe. For example, using the innerHTML property or the document.write method to add a script element will generate this exception. If the content is safe and from a trusted source, use a method to explicitly manipulate elements and attributes, such as createElement, or use setInnerHTMLUnsafe (or other unsafe method)."; },
    };

    setInnerHTML = setInnerHTMLUnsafe = function (element, text) {
        /// <signature helpKeyword="TVJS.Utilities.setInnerHTML">
        /// <summary locid="TVJS.Utilities.setInnerHTML">
        /// Sets the innerHTML property of the specified element to the specified text.
        /// </summary>
        /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.setInnerHTML_p:element">
        /// The element on which the innerHTML property is to be set.
        /// </param>
        /// <param name="text" type="String" locid="TVJS.Utilities.setInnerHTML_p:text">
        /// The value to be set to the innerHTML property.
        /// </param>
        /// </signature>
        element.innerHTML = text;
    };
    setOuterHTML = setOuterHTMLUnsafe = function (element, text) {
        /// <signature helpKeyword="TVJS.Utilities.setOuterHTML">
        /// <summary locid="TVJS.Utilities.setOuterHTML">
        /// Sets the outerHTML property of the specified element to the specified text.
        /// </summary>
        /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.setOuterHTML_p:element">
        /// The element on which the outerHTML property is to be set.
        /// </param>
        /// <param name="text" type="String" locid="TVJS.Utilities.setOuterHTML_p:text">
        /// The value to be set to the outerHTML property.
        /// </param>
        /// </signature>
        element.outerHTML = text;
    };
    insertAdjacentHTML = insertAdjacentHTMLUnsafe = function (element, position, text) {
        /// <signature helpKeyword="TVJS.Utilities.insertAdjacentHTML">
        /// <summary locid="TVJS.Utilities.insertAdjacentHTML">
        /// Calls insertAdjacentHTML on the specified element.
        /// </summary>
        /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.insertAdjacentHTML_p:element">
        /// The element on which insertAdjacentHTML is to be called.
        /// </param>
        /// <param name="position" type="String" locid="TVJS.Utilities.insertAdjacentHTML_p:position">
        /// The position relative to the element at which to insert the HTML.
        /// </param>
        /// <param name="text" type="String" locid="TVJS.Utilities.insertAdjacentHTML_p:text">
        /// The value to be provided to insertAdjacentHTML.
        /// </param>
        /// </signature>
        element.insertAdjacentHTML(position, text);
    };

    var msApp = _Global.MSApp;
    if (msApp && msApp.execUnsafeLocalFunction) {
        setInnerHTMLUnsafe = function (element, text) {
            /// <signature helpKeyword="TVJS.Utilities.setInnerHTMLUnsafe">
            /// <summary locid="TVJS.Utilities.setInnerHTMLUnsafe">
            /// Sets the innerHTML property of the specified element to the specified text.
            /// </summary>
            /// <param name='element' type='HTMLElement' locid="TVJS.Utilities.setInnerHTMLUnsafe_p:element">
            /// The element on which the innerHTML property is to be set.
            /// </param>
            /// <param name='text' type="String" locid="TVJS.Utilities.setInnerHTMLUnsafe_p:text">
            /// The value to be set to the innerHTML property.
            /// </param>
            /// </signature>
            msApp.execUnsafeLocalFunction(function () {
                try {
                    _TVJS._execUnsafe = true;
                    element.innerHTML = text;
                } finally {
                    _TVJS._execUnsafe = false;
                }
            });
        };
        setOuterHTMLUnsafe = function (element, text) {
            /// <signature helpKeyword="TVJS.Utilities.setOuterHTMLUnsafe">
            /// <summary locid="TVJS.Utilities.setOuterHTMLUnsafe">
            /// Sets the outerHTML property of the specified element to the specified text
            /// in the context of msWWA.execUnsafeLocalFunction.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.setOuterHTMLUnsafe_p:element">
            /// The element on which the outerHTML property is to be set.
            /// </param>
            /// <param name="text" type="String" locid="TVJS.Utilities.setOuterHTMLUnsafe_p:text">
            /// The value to be set to the outerHTML property.
            /// </param>
            /// </signature>
            msApp.execUnsafeLocalFunction(function () {
                try {
                    _TVJS._execUnsafe = true;
                    element.outerHTML = text;
                } finally {
                    _TVJS._execUnsafe = false;
                }
            });
        };
        insertAdjacentHTMLUnsafe = function (element, position, text) {
            /// <signature helpKeyword="TVJS.Utilities.insertAdjacentHTMLUnsafe">
            /// <summary locid="TVJS.Utilities.insertAdjacentHTMLUnsafe">
            /// Calls insertAdjacentHTML on the specified element in the context
            /// of msWWA.execUnsafeLocalFunction.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.insertAdjacentHTMLUnsafe_p:element">
            /// The element on which insertAdjacentHTML is to be called.
            /// </param>
            /// <param name="position" type="String" locid="TVJS.Utilities.insertAdjacentHTMLUnsafe_p:position">
            /// The position relative to the element at which to insert the HTML.
            /// </param>
            /// <param name="text" type="String" locid="TVJS.Utilities.insertAdjacentHTMLUnsafe_p:text">
            /// Value to be provided to insertAdjacentHTML.
            /// </param>
            /// </signature>
            msApp.execUnsafeLocalFunction(function () {
                try {
                    _TVJS._execUnsafe = true;
                    element.insertAdjacentHTML(position, text);
                } finally {
                    _TVJS._execUnsafe = false;
                }
            });
        };
    } else if (_Global.msIsStaticHTML) {
        var check = function (str) {
            if (!_Global.msIsStaticHTML(str)) {
                throw new _ErrorFromName("TVJS.Utitilies.NonStaticHTML", strings.nonStaticHTML);
            }
        };
        // If we ever get isStaticHTML we can attempt to recreate the behavior we have in the local
        // compartment, in the mean-time all we can do is sanitize the input.
        //
        setInnerHTML = function (element, text) {
            /// <signature helpKeyword="TVJS.Utilities.setInnerHTML">
            /// <summary locid="TVJS.Utilities.msIsStaticHTML.setInnerHTML">
            /// Sets the innerHTML property of a element to the specified text
            /// if it passes a msIsStaticHTML check.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.msIsStaticHTML.setInnerHTML_p:element">
            /// The element on which the innerHTML property is to be set.
            /// </param>
            /// <param name="text" type="String" locid="TVJS.Utilities.msIsStaticHTML.setInnerHTML_p:text">
            /// The value to be set to the innerHTML property.
            /// </param>
            /// </signature>
            check(text);
            element.innerHTML = text;
        };
        setOuterHTML = function (element, text) {
            /// <signature helpKeyword="TVJS.Utilities.setOuterHTML">
            /// <summary locid="TVJS.Utilities.msIsStaticHTML.setOuterHTML">
            /// Sets the outerHTML property of a element to the specified text
            /// if it passes a msIsStaticHTML check.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.msIsStaticHTML.setOuterHTML_p:element">
            /// The element on which the outerHTML property is to be set.
            /// </param>
            /// <param name="text" type="String" locid="TVJS.Utilities.msIsStaticHTML.setOuterHTML_p:text">
            /// The value to be set to the outerHTML property.
            /// </param>
            /// </signature>
            check(text);
            element.outerHTML = text;
        };
        insertAdjacentHTML = function (element, position, text) {
            /// <signature helpKeyword="TVJS.Utilities.insertAdjacentHTML">
            /// <summary locid="TVJS.Utilities.msIsStaticHTML.insertAdjacentHTML">
            /// Calls insertAdjacentHTML on the element if it passes
            /// a msIsStaticHTML check.
            /// </summary>
            /// <param name="element" type="HTMLElement" locid="TVJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:element">
            /// The element on which insertAdjacentHTML is to be called.
            /// </param>
            /// <param name="position" type="String" locid="TVJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:position">
            /// The position relative to the element at which to insert the HTML.
            /// </param>
            /// <param name="text" type="String" locid="TVJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:text">
            /// The value to be provided to insertAdjacentHTML.
            /// </param>
            /// </signature>
            check(text);
            element.insertAdjacentHTML(position, text);
        };
    }

    _Base.Namespace._moduleDefine(exports, "TVJS.Utilities", {
        setInnerHTML: setInnerHTML,
        setInnerHTMLUnsafe: setInnerHTMLUnsafe,
        setOuterHTML: setOuterHTML,
        setOuterHTMLUnsafe: setOuterHTMLUnsafe,
        insertAdjacentHTML: insertAdjacentHTML,
        insertAdjacentHTMLUnsafe: insertAdjacentHTMLUnsafe
    });

});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_Select',[
    'exports',
    '../Core/_Base',
    './_SafeHtml'
    ], function selectInit(exports, _Base, _SafeHtml) {
    "use strict";

    _Base.Namespace._moduleDefine(exports, "TVJS.UI", {
        _Select: _Base.Namespace._lazy(function () {
            var encodeHtmlRegEx = /[&<>'"]/g;
            var encodeHtmlEscapeMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "'": "&#39;",
                '"': "&quot;"
            };
            var stringDirectionRegEx = /[\u200e\u200f]/g;
            function encodeHtml(str) {
                return str.replace(encodeHtmlRegEx, function (m) {
                    return encodeHtmlEscapeMap[m] || "";
                });
            }
            function stripDirectionMarker(str) {
                return str.replace(stringDirectionRegEx, "");
            }
            function stockGetValue(index) {
                /*jshint validthis: true */
                return this[index];
            }
            function stockGetLength() {
                /*jshint validthis: true */
                return this.length;
            }
            function fixDataSource(dataSource) {
                if (!dataSource.getValue) {
                    dataSource.getValue = stockGetValue;
                }

                if (!dataSource.getLength) {
                    dataSource.getLength = stockGetLength;
                }
                return dataSource;
            }

            return _Base.Class.define(function _Select_ctor(element, options) {
                // This is an implementation detail of the TimePicker and DatePicker, designed
                // to provide a primitive "data bound" select control. This is not designed to
                // be used outside of the TimePicker and DatePicker controls.
                //

                this._dataSource = fixDataSource(options.dataSource);
                this._index = options.index || 0;

                this._domElement = element;
                // Mark this as a tab stop
                this._domElement.tabIndex = 0;

                if (options.disabled) {
                    this.setDisabled(options.disabled);
                }

                var that = this;
                this._domElement.addEventListener("change", function () {
                    //Should be set to _index to prevent events from firing twice
                    that._index = that._domElement.selectedIndex;
                }, false);

                //update runtime accessibility value after initialization
                this._createSelectElement();
            }, {
                _index: 0,
                _dataSource: null,

                dataSource: {
                    get: function () { return this._dataSource; },
                    set: function (value) {
                        this._dataSource = fixDataSource(value);

                        //Update layout as data source change
                        if (this._domElement) {
                            this._createSelectElement();
                        }
                    }
                },

                setDisabled: function (disabled) {
                    if (disabled) {
                        this._domElement.setAttribute("disabled", "disabled");
                    } else {
                        this._domElement.removeAttribute("disabled");
                    }
                },

                _createSelectElement: function () {
                    var dataSourceLength = this._dataSource.getLength();
                    var text = "";
                    for (var i = 0; i < dataSourceLength; i++) {
                        var value = "" + this._dataSource.getValue(i);
                        var escaped = encodeHtml(value);
                        // WinRT localization often tags the strings with reading direction. We want this
                        // for display text (escaped), but don't want this in the value space, as it
                        // only present for display.
                        //
                        var stripped = stripDirectionMarker(escaped);
                        text += "<option value='" + stripped + "'>" + escaped + "</option>";
                    }
                    _SafeHtml.setInnerHTMLUnsafe(this._domElement, text);
                    this._domElement.selectedIndex = this._index;
                },

                index: {
                    get: function () {
                        return Math.max(0, Math.min(this._index, this._dataSource.getLength() - 1));
                    },
                    set: function (value) {
                        if (this._index !== value) {
                            this._index = value;

                            var d = this._domElement;
                            if (d && d.selectedIndex !== value) {
                                d.selectedIndex = value;
                            }
                        }
                    }
                },

                value: {
                    get: function () {
                        return this._dataSource.getValue(this.index);
                    }
                }
            });
        })
    });
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_Telemetry',[
    'exports'
    ], function telemetryInit(exports) {
    "use strict";

    /// NOTE: This file should be included when NOT building
    /// Microsoft TVJS Framework Package which will be available in Windows Store.

    exports.send = function (name, params) {
    /// <signature helpKeyword="TVJS._Telemetry.send">
    /// <summary locid="TVJS._Telemetry.send">
    /// Formatter to upload the name/value pair to Asimov in the correct format.
    /// This will result in no-op when built outside of Microsoft Framework Package.
    /// </summary>
    /// <param name="params" type="Object" locid="TVJS._Telemetry.send_p:params">
    /// Object of name/value pair items that need to be logged. They can be of type,
    /// bool, int32, string.  Any other type will be ignored.
    /// </param>
    /// </signature>
        /* empty */
    };
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_UI',[
    'exports',
    '../Core/_BaseCoreUtils',
    '../Core/_Base'
    ], function uiInit(exports, _BaseCoreUtils, _Base) {
    "use strict";

    _Base.Namespace._moduleDefine(exports, "TVJS.UI", {
        eventHandler: function (handler) {
            /// <signature helpKeyword="TVJS.UI.eventHandler">
            /// <summary locid="TVJS.UI.eventHandler">
            /// Marks a event handler function as being compatible with declarative processing.
            /// </summary>
            /// <param name="handler" type="Object" locid="TVJS.UI.eventHandler_p:handler">
            /// The handler to be marked as compatible with declarative processing.
            /// </param>
            /// <returns type="Object" locid="TVJS.UI.eventHandler_returnValue">
            /// The input handler.
            /// </returns>
            /// </signature>
            return _BaseCoreUtils.markSupportedForProcessing(handler);
        },
        /// <field locid="TVJS.UI.Orientation" helpKeyword="TVJS.UI.Orientation">
        /// Orientation options for a control's property
        /// </field>
        Orientation: {
            /// <field locid="TVJS.UI.Orientation.horizontal" helpKeyword="TVJS.UI.Orientation.horizontal">
            /// Horizontal
            /// </field>
            horizontal: "horizontal",
            /// <field locid="TVJS.UI.Orientation.vertical" helpKeyword="TVJS.UI.Orientation.vertical">
            /// Vertical
            /// </field>
            vertical: "vertical"
        },

        CountResult: {
            unknown: "unknown"
        },

        CountError: {
            noResponse: "noResponse"
        },

        DataSourceStatus: {
            ready: "ready",
            waiting: "waiting",
            failure: "failure"
        },

        FetchError: {
            noResponse: "noResponse",
            doesNotExist: "doesNotExist"
        },

        EditError: {
            noResponse: "noResponse",
            canceled: "canceled",
            notPermitted: "notPermitted",
            noLongerMeaningful: "noLongerMeaningful"
        },

        /// <field locid="TVJS.UI.ListView.ObjectType" helpKeyword="TVJS.UI.ObjectType">
        /// Specifies the type of an IListViewEntity.
        /// </field>
        ObjectType: {
            /// <field locid="TVJS.UI.ListView.ObjectType.item" helpKeyword="TVJS.UI.ObjectType.item">
            /// This value represents a ListView item.
            /// </field>
            item: "item",
            /// <field locid="TVJS.UI.ListView.ObjectType.groupHeader" helpKeyword="TVJS.UI.ObjectType.groupHeader">
            /// This value represents a ListView group header.
            /// </field>
            groupHeader: "groupHeader",
            /// <field locid="TVJS.UI.ListView.ObjectType.header" helpKeyword="TVJS.UI.ObjectType.header">
            /// This value represents the ListView's header.
            /// </field>
            header: "header",
            /// <field locid="TVJS.UI.ListView.ObjectType.footer" helpKeyword="TVJS.UI.ObjectType.footer">
            /// This value represents the ListView's footer.
            /// </field>
            footer: "footer",
        },

        /// <field locid="TVJS.UI.ListView.SelectionMode" helpKeyword="TVJS.UI.SelectionMode">
        /// Specifies the selection mode for a ListView.
        /// </field>
        SelectionMode: {
            /// <field locid="TVJS.UI.ListView.SelectionMode.none" helpKeyword="TVJS.UI.SelectionMode.none">
            /// Items cannot be selected.
            /// </field>
            none: "none",
            /// <field locid="TVJS.UI.ListView.SelectionMode.single" helpKeyword="TVJS.UI.SelectionMode.single">
            /// A single item may be selected.
            /// <compatibleWith platform="Windows" minVersion="8.0"/>
            /// </field>
            single: "single",
            /// <field locid="TVJS.UI.ListView.SelectionMode.multi" helpKeyword="TVJS.UI.SelectionMode.multi">
            /// Multiple items may be selected.
            /// </field>
            multi: "multi"
        },

        /// <field locid="TVJS.UI.TapBehavior" helpKeyword="TVJS.UI.TapBehavior">
        /// Specifies how an ItemContainer or items in a ListView respond to the tap interaction.
        /// </field>
        TapBehavior: {
            /// <field locid="TVJS.UI.TapBehavior.directSelect" helpKeyword="TVJS.UI.TapBehavior.directSelect">
            /// Tapping the item invokes it and selects it. Navigating to the item with the keyboard changes the
            /// the selection so that the focused item is the only item that is selected.
            /// <compatibleWith platform="Windows" minVersion="8.0"/>
            /// </field>
            directSelect: "directSelect",
            /// <field locid="TVJS.UI.TapBehavior.toggleSelect" helpKeyword="TVJS.UI.TapBehavior.toggleSelect">
            /// Tapping the item invokes it. If the item was selected, tapping it clears the selection. If the item wasn't
            /// selected, tapping the item selects it.
            /// Navigating to the item with the keyboard does not select or invoke it.
            /// </field>
            toggleSelect: "toggleSelect",
            /// <field locid="TVJS.UI.TapBehavior.invokeOnly" helpKeyword="TVJS.UI.TapBehavior.invokeOnly">
            /// Tapping the item invokes it. Navigating to the item with keyboard does not select it or invoke it.
            /// </field>
            invokeOnly: "invokeOnly",
            /// <field locid="TVJS.UI.TapBehavior.none" helpKeyword="TVJS.UI.TapBehavior.none">
            /// Nothing happens.
            /// </field>
            none: "none"
        },

        /// <field locid="TVJS.UI.SwipeBehavior" helpKeyword="TVJS.UI.SwipeBehavior">
        /// Specifies whether items are selected when the user performs a swipe interaction.
        /// <compatibleWith platform="Windows" minVersion="8.0"/>
        /// </field>
        SwipeBehavior: {
            /// <field locid="TVJS.UI.SwipeBehavior.select" helpKeyword="TVJS.UI.SwipeBehavior.select">
            /// The swipe interaction selects the items touched by the swipe.
            /// </field>
            select: "select",
            /// <field locid="TVJS.UI.SwipeBehavior.none" helpKeyword="TVJS.UI.SwipeBehavior.none">
            /// The swipe interaction does not change which items are selected.
            /// </field>
            none: "none"
        },

        /// <field locid="TVJS.UI.GroupHeaderTapBehavior" helpKeyword="TVJS.UI.GroupHeaderTapBehavior">
        /// Specifies how group headers in a ListView respond to the tap interaction.
        /// </field>
        GroupHeaderTapBehavior: {
            /// <field locid="TVJS.UI.GroupHeaderTapBehavior.invoke" helpKeyword="TVJS.UI.GroupHeaderTapBehavior.invoke">
            /// Tapping the group header invokes it.
            /// </field>
            invoke: "invoke",
            /// <field locid="TVJS.UI.GroupHeaderTapBehavior.none" helpKeyword="TVJS.UI.GroupHeaderTapBehavior.none">
            /// Nothing happens.
            /// </field>
            none: "none"
        }

    });

});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities/_Xhr',[
    '../Core/_Global',
    '../Core/_Base',
    '../Promise',
    ], function xhrInit(_Global, _Base, Promise) {
    "use strict";

    function schedule(f, arg, priority) {
        setImmediate(function xhr_callback() {
            f(arg);
        });
    }

    function noop() {
    }

    var schemeRegex = /^(\w+)\:\/\//;

    function xhr(options) {
        /// <signature helpKeyword="TVJS.xhr">
        /// <summary locid="TVJS.xhr">
        /// Wraps calls to XMLHttpRequest in a promise.
        /// </summary>
        /// <param name="options" type="Object" locid="TVJS.xhr_p:options">
        /// The options that are applied to the XMLHttpRequest object. They are: type,
        /// url, user, password, headers, responseType, data, and customRequestInitializer.
        /// </param>
        /// <returns type="TVJS.Promise" locid="TVJS.xhr_returnValue">
        /// A promise that returns the XMLHttpRequest object when it completes.
        /// </returns>
        /// </signature>
        var req;
        return new Promise(
            function (c, e, p) {
                /// <returns value="c(new XMLHttpRequest())" locid="TVJS.xhr.constructor._returnValue" />
                req = new _Global.XMLHttpRequest();

                var isLocalRequest = false;
                var schemeMatch = schemeRegex.exec(options.url.toLowerCase());
                if (schemeMatch) {
                    if (schemeMatch[1] === 'file') {
                        isLocalRequest = true;
                    }
                } else if (_Global.location.protocol === 'file:'){
                    isLocalRequest = true;
                }


                req.onreadystatechange = function () {
                    if (req._canceled) {
                        req.onreadystatechange = noop;
                        return;
                    }

                    if (req.readyState === 4) {
                        if ((req.status >= 200 && req.status < 300) || (isLocalRequest && req.status === 0)) {
                            setImmediate(function () {
                                c(req);
                            });
                        } else {
                            setImmediate(function () {
                                e(req) 
                            });
                        }
                        req.onreadystatechange = noop;
                    } else {
                        setImmediate(function () { 
                            p(req);
                        });
                    }
                };

                req.open(
                    options.type || "GET",
                    options.url,
                    // Promise based XHR does not support sync.
                    //
                    true,
                    options.user,
                    options.password
                );
                req.responseType = options.responseType || "";

                Object.keys(options.headers || {}).forEach(function (k) {
                    req.setRequestHeader(k, options.headers[k]);
                });

                if (options.customRequestInitializer) {
                    options.customRequestInitializer(req);
                }

                if (options.data === undefined) {
                    req.send();
                } else {
                    req.send(options.data);
                }
            },
            function () {
                req.onreadystatechange = noop;
                req._canceled = true;
                req.abort();
            }
        );
    }

    _Base.Namespace.define("TVJS", {
        xhr: xhr
    });

    return xhr;

});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Utilities',[
    './Utilities/_Control',
    './Utilities/_Dispose',
    './Utilities/_ElementListUtilities',
    './Utilities/_ElementUtilities',
    './Utilities/_Hoverable',
    './Utilities/_KeyboardBehavior',
    './Utilities/_SafeHtml',
    './Utilities/_Select',
    './Utilities/_Telemetry',
    './Utilities/_UI',
    './Utilities/_Xhr' ], function () {

    //wrapper module
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Application/_State',[
    'exports',
    '../Core/_Global',
    '../Core/_WinRT',
    '../Core/_Base',
    '../Core/_BaseUtils',
    '../Promise'
    ], function stateInit(exports, _Global, _WinRT, _Base, _BaseUtils, Promise) {
    "use strict";

    function initWithWinRT() {
        var local, temp, roaming;

        var IOHelper = _Base.Class.define(
        function IOHelper_ctor(folder) {
            this.folder = folder;
            this._path = folder.path;
            if (folder.tryGetItemAsync) {
                this._tryGetItemAsync = folder.tryGetItemAsync.bind(folder);
            }
        }, {
            _tryGetItemAsync: function (fileName) {
                return this.folder.getFileAsync(fileName).then(null, function () { return false; });
            },

            exists: function (fileName) {
                /// <signature helpKeyword="TVJS.Application.IOHelper.exists">
                /// <summary locid="TVJS.Application.IOHelper.exists">
                /// Determines if the specified file exists in the container
                /// </summary>
                /// <param name="fileName" type="String" locid="TVJS.Application.IOHelper.exists_p:fileName">
                /// The file which may exist within this folder
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Application.IOHelper.exists_returnValue">
                /// Promise with either true (file exists) or false.
                /// </returns>
                /// </signature>
                return this._tryGetItemAsync(fileName).then(function (fileItem) {
                    return fileItem ? true : false;
                });
            },
            remove: function (fileName) {
                /// <signature helpKeyword="TVJS.Application.IOHelper.remove">
                /// <summary locid="TVJS.Application.IOHelper.remove">
                /// Delets a file in the container
                /// </summary>
                /// <param name="fileName" type="String" locid="TVJS.Application.IOHelper.remove_p:fileName">
                /// The file to be deleted
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Application.IOHelper.remove_returnValue">
                /// Promise which is fulfilled when the file has been deleted
                /// </returns>
                /// </signature>
                return this._tryGetItemAsync(fileName).then(function (fileItem) {
                    return fileItem ? fileItem.deleteAsync() : false;
                }).then(null, function () { return false; });
            },
            writeText: function (fileName, str) {
                /// <signature helpKeyword="TVJS.Application.IOHelper.writeText">
                /// <summary locid="TVJS.Application.IOHelper.writeText">
                /// Writes a file to the container with the specified text
                /// </summary>
                /// <param name="fileName" type="String" locid="TVJS.Application.IOHelper.writeText_p:fileName">
                /// The file to write to
                /// </param>
                /// <param name="str" type="String" locid="TVJS.Application.IOHelper.writeText_p:str">
                /// Content to be written to the file
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Application.IOHelper.writeText_returnValue">
                /// Promise which is fulfilled when the file has been written
                /// </returns>
                /// </signature>
                var sto = _WinRT.Windows.Storage;
                var that = this;
                return that.folder.createFileAsync(fileName, sto.CreationCollisionOption.openIfExists).
                    then(function (fileItem) {
                        return sto.FileIO.writeTextAsync(fileItem, str);
                    });
            },

            readText: function (fileName, def) {
                /// <signature helpKeyword="TVJS.Application.IOHelper.readText">
                /// <summary locid="TVJS.Application.IOHelper.readText">
                /// Reads the contents of a file from the container, if the file
                /// doesn't exist, def is returned.
                /// </summary>
                /// <param name="fileName" type="String" locid="TVJS.Application.IOHelper.readText_p:fileName">
                /// The file to read from
                /// </param>
                /// <param name="def" type="String" locid="TVJS.Application.IOHelper.readText_p:def">
                /// Default value to be returned if the file failed to open
                /// </param>
                /// <returns type="TVJS.Promise" locid="TVJS.Application.IOHelper.readText_returnValue">
                /// Promise containing the contents of the file, or def.
                /// </returns>
                /// </signature>
                var sto = _WinRT.Windows.Storage;
                return this._tryGetItemAsync(fileName).then(function (fileItem) {
                    return fileItem ? sto.FileIO.readTextAsync(fileItem) : def;
                }).then(null, function () { return def; });
            }

        }, {
            supportedForProcessing: false,
        });

        _Base.Namespace._moduleDefine(exports, "TVJS.Application", {
            /// <field type="Object" helpKeyword="TVJS.Application.local" locid="TVJS.Application.local">
            /// Allows access to create files in the application local storage, which is preserved across runs
            /// of an application and does not roam.
            /// </field>
            local: {
                get: function () {
                    if (!local) {
                        local = new IOHelper(_WinRT.Windows.Storage.ApplicationData.current.localFolder);
                    }
                    return local;
                }
            },
            /// <field type="Object" helpKeyword="TVJS.Application.temp" locid="TVJS.Application.temp">
            /// Allows access to create files in the application temp storage, which may be reclaimed
            /// by the system between application runs.
            /// </field>
            temp: {
                get: function () {
                    if (!temp) {
                        temp = new IOHelper(_WinRT.Windows.Storage.ApplicationData.current.temporaryFolder);
                    }
                    return temp;
                }
            },
            /// <field type="Object" helpKeyword="TVJS.Application.roaming" locid="TVJS.Application.roaming">
            /// Allows access to create files in the application roaming storage, which is preserved across runs
            /// of an application and roams with the user across multiple machines.
            /// </field>
            roaming: {
                get: function () {
                    if (!roaming) {
                        roaming = new IOHelper(_WinRT.Windows.Storage.ApplicationData.current.roamingFolder);
                    }
                    return roaming;
                }
            }
        });
    }

    function initWithStub() {
        var InMemoryHelper = _Base.Class.define(
            function InMemoryHelper_ctor() {
                this.storage = {};
            }, {
                exists: function (fileName) {
                    /// <signature helpKeyword="TVJS.Application.InMemoryHelper.exists">
                    /// <summary locid="TVJS.Application.InMemoryHelper.exists">
                    /// Determines if the specified file exists in the container
                    /// </summary>
                    /// <param name="fileName" type="String" locid="TVJS.Application.InMemoryHelper.exists_p:fileName">
                    /// The filename which may exist within this folder
                    /// </param>
                    /// <returns type="TVJS.Promise" locid="TVJS.Application.InMemoryHelper.exists_returnValue">
                    /// Promise with either true (file exists) or false.
                    /// </returns>
                    /// </signature>
                    // force conversion to boolean
                    //
                    return Promise.as(this.storage[fileName] !== undefined);
                },
                remove: function (fileName) {
                    /// <signature helpKeyword="TVJS.Application.InMemoryHelper.remove">
                    /// <summary locid="TVJS.Application.InMemoryHelper.remove">
                    /// Deletes a file in the container
                    /// </summary>
                    /// <param name="fileName" type="String" locid="TVJS.Application.InMemoryHelper.remove_p:fileName">
                    /// The file to be deleted
                    /// </param>
                    /// <returns type="TVJS.Promise" locid="TVJS.Application.InMemoryHelper.remove_returnValue">
                    /// Promise which is fulfilled when the file has been deleted
                    /// </returns>
                    /// </signature>
                    delete this.storage[fileName];
                    return Promise.as();
                },
                writeText: function (fileName, str) {
                    /// <signature helpKeyword="TVJS.Application.InMemoryHelper.writeText">
                    /// <summary locid="TVJS.Application.InMemoryHelper.writeText">
                    /// Writes a file to the container with the specified text
                    /// </summary>
                    /// <param name="fileName" type="String" locid="TVJS.Application.InMemoryHelper.writeText_p:fileName">
                    /// The filename to write to
                    /// </param>
                    /// <param name="str" type="String" locid="TVJS.Application.InMemoryHelper.writeText_p:str">
                    /// Content to be written to the file
                    /// </param>
                    /// <returns type="TVJS.Promise" locid="TVJS.Application.InMemoryHelper.writeText_returnValue">
                    /// Promise which is fulfilled when the file has been written
                    /// </returns>
                    /// </signature>
                    this.storage[fileName] = str;
                    return Promise.as(str.length);
                },
                readText: function (fileName, def) {
                    /// <signature helpKeyword="TVJS.Application.InMemoryHelper.readText">
                    /// <summary locid="TVJS.Application.InMemoryHelper.readText">
                    /// Reads the contents of a file from the container, if the file
                    /// doesn't exist, def is returned.
                    /// </summary>
                    /// <param name="fileName" type="String" locid="TVJS.Application.InMemoryHelper.readText_p:fileName">
                    /// The filename to read from
                    /// </param>
                    /// <param name="def" type="String" locid="TVJS.Application.InMemoryHelper.readText_p:def">
                    /// Default value to be returned if the file failed to open
                    /// </param>
                    /// <returns type="TVJS.Promise" locid="TVJS.Application.InMemoryHelper.readText_returnValue">
                    /// Promise containing the contents of the file, or def.
                    /// </returns>
                    /// </signature>
                    var result = this.storage[fileName];
                    return Promise.as(typeof result === "string" ? result : def);
                }
            }, {
                supportedForProcessing: false,
            }
        );

        _Base.Namespace._moduleDefine(exports, "TVJS.Application", {
            /// <field type="Object" helpKeyword="TVJS.Application.local" locid="TVJS.Application.local">
            /// Allows access to create files in the application local storage, which is preserved across runs
            /// of an application and does not roam.
            /// </field>
            local: new InMemoryHelper(),
            /// <field type="Object" helpKeyword="TVJS.Application.temp" locid="TVJS.Application.temp">
            /// Allows access to create files in the application temp storage, which may be reclaimed
            /// by the system between application runs.
            /// </field>
            temp: new InMemoryHelper(),
            /// <field type="Object" helpKeyword="TVJS.Application.roaming" locid="TVJS.Application.roaming">
            /// Allows access to create files in the application roaming storage, which is preserved across runs
            /// of an application and roams with the user across multiple machines.
            /// </field>
            roaming: new InMemoryHelper()
        });
    }

    if (_WinRT.Windows.Storage.FileIO && _WinRT.Windows.Storage.ApplicationData && _WinRT.Windows.Storage.CreationCollisionOption) {
        initWithWinRT();
    } else {
        initWithStub();
    }

    var sessionState = {};

    _Base.Namespace._moduleDefine(exports, "TVJS.Application", {
        sessionState: {
            get: function () {
                return sessionState;
            },
            set: function (value) {
                sessionState = value;
            }
        },
        _loadState: function (e) {
            // we only restore state if we are coming back from a clear termination from PLM
            //
            if (e.previousExecutionState === 3 /* ApplicationExecutionState.Terminated */) {
                return exports.local.readText("_sessionState.json", "{}").
                    then(function (str) {
                        var sessionState = JSON.parse(str);
                        if (sessionState && Object.keys(sessionState).length > 0) {
                            exports._sessionStateLoaded = true;
                        }
                        exports.sessionState = sessionState;
                    }).
                    then(null, function () {
                        exports.sessionState = {};
                    });
            } else {
                return Promise.as();
            }
        },
        _oncheckpoint: function (event, Application) {
            if (_Global.MSApp && _Global.MSApp.getViewOpener && _Global.MSApp.getViewOpener()) {
                // don't save state in child windows.
                return;
            }
            var sessionState = exports.sessionState;
            if ((sessionState && Object.keys(sessionState).length > 0) || exports._sessionStateLoaded) {
                var stateString;
                try {
                    stateString = JSON.stringify(sessionState);
                } catch (e) {
                    stateString = "";
                    Application.queueEvent({ type: "error", detail: e });
                }
                event.setPromise(
                    exports.local.writeText("_sessionState.json", stateString).
                        then(null, function (err) {
                            Application.queueEvent({ type: "error", detail: err });
                        })
                );
            }
        }
    });
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Application',[
    'exports',
    './Core/_Global',
    './Core/_WinRT',
    './Core/_Base',
    './Core/_Events',
    './Core/_Log',
    './Application/_State',
    './Promise',
    './_Signal',
    './Utilities/_ElementUtilities'
], function applicationInit(exports, _Global, _WinRT, _Base, _Events, _Log, _State, Promise, _Signal, _ElementUtilities) {
    "use strict";

    _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);

    var checkpointET = "checkpoint",
        unloadET = "unload",
        activatedET = "activated",
        loadedET = "loaded",
        readyET = "ready",
        errorET = "error",
        settingsET = "settings",
        backClickET = "backclick",
        beforeRequestingFocusOnKeyboardInputET = "beforerequestingfocusonkeyboardinput",
        requestingFocusOnKeyboardInputET = "requestingfocusonkeyboardinput",
        edgyStartingET = "edgystarting",
        edgyCompletedET = "edgycompleted",
        edgyCanceledET = "edgycanceled";

    var outstandingPromiseErrors;
    var eventQueue = [];
    var eventQueueJob = null;
    var eventQueuedSignal = null;
    var running = false;
    var registered = false;

    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /* empty */ }, { supportedForProcessing: false }), _Events.eventMixin);
    var listeners = new ListenerType();
    var createEvent = _Events._createEventProperty;
    var pendingDeferrals = {};
    var pendingDeferralID = 0;
    var TypeToSearch = {
        _registered: false,

        updateRegistration: function Application_TypeToSearch_updateRegistration() {
            var ls = listeners._listeners && listeners._listeners[requestingFocusOnKeyboardInputET] || [];
            if (!TypeToSearch._registered && ls.length > 0) {
                TypeToSearch._updateKeydownCaptureListeners(_Global.top, true /*add*/);
                TypeToSearch._registered = true;
            }
            if (TypeToSearch._registered && ls.length === 0) {
                TypeToSearch._updateKeydownCaptureListeners(_Global.top, false /*add*/);
                TypeToSearch._registered = false;
            }
        },

        _keydownCaptureHandler: function Application_TypeToSearch_keydownCaptureHandler(event) {
            if (TypeToSearch._registered && TypeToSearch._shouldKeyTriggerTypeToSearch(event)) {
                requestingFocusOnKeyboardInput();
            }
        },

        _frameLoadCaptureHandler: function Application_TypeToSearch_frameLoadCaptureHandler(event) {
            if (TypeToSearch._registered) {
                TypeToSearch._updateKeydownCaptureListeners(event.target.contentWindow, true /*add*/);
            }
        },

        _updateKeydownCaptureListeners: function Application_TypeToSearch_updateKeydownCaptureListeners(win, add) {
            if (!win) {
                // This occurs when this handler gets called from an IFrame event that is no longer in the DOM
                // and therefore does not have a valid contentWindow object.
                return;
            }

            // Register for child frame keydown events in order to support FocusOnKeyboardInput
            // when focus is in a child frame.  Also register for child frame load events so
            // it still works after frame navigations.
            // Note: This won't catch iframes added programmatically later, but that can be worked
            // around by toggling FocusOnKeyboardInput off/on after the new iframe is added.
            try {
                if (add) {
                    win.document.addEventListener('keydown', TypeToSearch._keydownCaptureHandler, true);
                } else {
                    win.document.removeEventListener('keydown', TypeToSearch._keydownCaptureHandler, true);
                }
            } catch (e) { // if the IFrame crosses domains, we'll get a permission denied error
            }

            if (win.frames) {
                for (var i = 0, l = win.frames.length; i < l; i++) {
                    var childWin = win.frames[i];
                    TypeToSearch._updateKeydownCaptureListeners(childWin, add);

                    try {
                        if (add) {
                            if (childWin.frameElement) {
                                childWin.frameElement.addEventListener('load', TypeToSearch._frameLoadCaptureHandler, true);
                            }
                        } else {
                            if (childWin.frameElement) {
                                childWin.frameElement.removeEventListener('load', TypeToSearch._frameLoadCaptureHandler, true);
                            }
                        }
                    } catch (e) { // if the IFrame crosses domains, we'll get a permission denied error
                    }
                }
            }
        },

        _shouldKeyTriggerTypeToSearch: function Application_TypeToSearch_shouldKeyTriggerTypeToSearch(event) {
            var shouldTrigger = false;
            // First, check if a metaKey is pressed (only applies to MacOS). If so, do nothing here.
            if (!event.metaKey) {
                // We also don't handle CTRL/ALT combinations, unless ALTGR is also set. Since there is no shortcut for checking AltGR,
                // we need to use getModifierState, however, Safari currently doesn't support this.
                if ((!event.ctrlKey && !event.altKey) || (event.getModifierState && event.getModifierState("AltGraph"))) {
                    // Show on most keys for visible characters like letters, numbers, etc.
                    switch (event.keyCode) {
                        case 0x30:  //0x30 0 key
                        case 0x31:  //0x31 1 key
                        case 0x32:  //0x32 2 key
                        case 0x33:  //0x33 3 key
                        case 0x34:  //0x34 4 key
                        case 0x35:  //0x35 5 key
                        case 0x36:  //0x36 6 key
                        case 0x37:  //0x37 7 key
                        case 0x38:  //0x38 8 key
                        case 0x39:  //0x39 9 key

                        case 0x41:  //0x41 A key
                        case 0x42:  //0x42 B key
                        case 0x43:  //0x43 C key
                        case 0x44:  //0x44 D key
                        case 0x45:  //0x45 E key
                        case 0x46:  //0x46 F key
                        case 0x47:  //0x47 G key
                        case 0x48:  //0x48 H key
                        case 0x49:  //0x49 I key
                        case 0x4A:  //0x4A J key
                        case 0x4B:  //0x4B K key
                        case 0x4C:  //0x4C L key
                        case 0x4D:  //0x4D M key
                        case 0x4E:  //0x4E N key
                        case 0x4F:  //0x4F O key
                        case 0x50:  //0x50 P key
                        case 0x51:  //0x51 Q key
                        case 0x52:  //0x52 R key
                        case 0x53:  //0x53 S key
                        case 0x54:  //0x54 T key
                        case 0x55:  //0x55 U key
                        case 0x56:  //0x56 V key
                        case 0x57:  //0x57 W key
                        case 0x58:  //0x58 X key
                        case 0x59:  //0x59 Y key
                        case 0x5A:  //0x5A Z key

                        case 0x60:  // VK_NUMPAD0,             //0x60 Numeric keypad 0 key
                        case 0x61:  // VK_NUMPAD1,             //0x61 Numeric keypad 1 key
                        case 0x62:  // VK_NUMPAD2,             //0x62 Numeric keypad 2 key
                        case 0x63:  // VK_NUMPAD3,             //0x63 Numeric keypad 3 key
                        case 0x64:  // VK_NUMPAD4,             //0x64 Numeric keypad 4 key
                        case 0x65:  // VK_NUMPAD5,             //0x65 Numeric keypad 5 key
                        case 0x66:  // VK_NUMPAD6,             //0x66 Numeric keypad 6 key
                        case 0x67:  // VK_NUMPAD7,             //0x67 Numeric keypad 7 key
                        case 0x68:  // VK_NUMPAD8,             //0x68 Numeric keypad 8 key
                        case 0x69:  // VK_NUMPAD9,             //0x69 Numeric keypad 9 key
                        case 0x6A:  // VK_MULTIPLY,            //0x6A Multiply key
                        case 0x6B:  // VK_ADD,                 //0x6B Add key
                        case 0x6C:  // VK_SEPARATOR,           //0x6C Separator key
                        case 0x6D:  // VK_SUBTRACT,            //0x6D Subtract key
                        case 0x6E:  // VK_DECIMAL,             //0x6E Decimal key
                        case 0x6F:  // VK_DIVIDE,              //0x6F Divide key

                        case 0xBA:  // VK_OEM_1,               //0xBA Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the ';:' key
                        case 0xBB:  // VK_OEM_PLUS,            //0xBB For any country/region, the '+' key
                        case 0xBC:  // VK_OEM_COMMA,           //0xBC For any country/region, the ',' key
                        case 0xBD:  // VK_OEM_MINUS,           //0xBD For any country/region, the '-' key
                        case 0xBE:  // VK_OEM_PERIOD,          //0xBE For any country/region, the '.' key
                        case 0xBF:  // VK_OEM_2,               //0xBF Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '/?' key
                        case 0xC0:  // VK_OEM_3,               //0xC0 Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '`~' key

                        case 0xDB:  // VK_OEM_4,               //0xDB Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '[{' key
                        case 0xDC:  // VK_OEM_5,               //0xDC Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '\|' key
                        case 0xDD:  // VK_OEM_6,               //0xDD Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the ']}' key
                        case 0xDE:  // VK_OEM_7,               //0xDE Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the 'single-quote/double-quote' key
                        case 0xDF:  // VK_OEM_8,               //0xDF Used for miscellaneous characters; it can vary by keyboard.

                        case 0xE2:  // VK_OEM_102,             //0xE2 Either the angle bracket key or the backslash key on the RT 102-key keyboard

                        case 0xE5:  // VK_PROCESSKEY,          //0xE5 IME PROCESS key

                        case 0xE7:  // VK_PACKET,              //0xE7 Used to pass Unicode characters as if they were keystrokes. The VK_PACKET key is the low word of a 32-bit Virtual Key value used for non-keyboard input methods. For more information, see Remark in KEYBDINPUT, SendInput, WM_KEYDOWN, and WM_KEYUP
                            shouldTrigger = true;
                            break;
                    }
                }
            }
            return shouldTrigger;
        }
    };

    function safeSerialize(obj) {
        var str;
        try {
            var seenObjects = [];
            str = JSON.stringify(obj, function (key, value) {
                if (value === _Global) {
                    return "[window]";
                } else if (value instanceof _Global.HTMLElement) {
                    return "[HTMLElement]";
                } else if (typeof value === "function") {
                    return "[function]";
                } else if (typeof value === "object") {
                    if (value === null) {
                        return value;
                    } else if (seenObjects.indexOf(value) === -1) {
                        seenObjects.push(value);
                        return value;
                    } else {
                        return "[circular]";
                    }
                } else {
                    return value;
                }

            });
        }
        catch (err) {
            // primitives, undefined, null, etc, all get serialized fine. In the
            // case that stringify fails (typically due to circular graphs) we
            // just show "[object]". While we may be able to tighten the condition
            // for the exception, we never way this serialize to fail.
            //
            // Note: we make this be a JSON string, so that consumers of the log
            // can always call JSON.parse.
            str = JSON.stringify("[object]");
        }
        return str;
    }

    function fatalErrorHandler(e) {
        _Log.log && _Log.log(safeSerialize(e), "TVJS", "error");

        if (_Global.document && exports._terminateApp) {
            var data = e.detail;
            var number = data && (data.number || (data.exception && (data.exception.number || data.exception.code)) || (data.error && data.error.number) || data.errorCode || 0);
            var terminateData = {
                description: safeSerialize(data),
                // note: because of how we listen to events, we rarely get a stack
                stack: data && (data.stack || (data.exception && (data.exception.stack || data.exception.message)) || (data.error && data.error.stack) || null),
                errorNumber: number,
                number: number
            };
            exports._terminateApp(terminateData, e);
        }
    }

    function defaultTerminateAppHandler(data, e) {
        /*jshint unused: false*/
        // This is the unhandled exception handler in TVJS. This handler is invoked whenever a promise
        // has an exception occur that is not handled (via an error handler passed to then() or a call to done()).
        //
        // To see the original exception stack, look at data.stack.
        // For more information on debugging and exception handling go to http://go.microsoft.com/fwlink/p/?LinkId=253583.

        debugger; // jshint ignore:line
        if (_Global.MSApp) {
            _Global.MSApp.terminateApp(data);
        }
    }

    var terminateAppHandler = defaultTerminateAppHandler;

    function captureDeferral(obj) {
        var id = "def" + (pendingDeferralID++);
        return { deferral: pendingDeferrals[id] = obj.getDeferral(), id: id };
    }
    function completeDeferral(deferral, deferralID) {
        // If we have a deferralID we our table to find the
        // deferral. Since we remove it on completion, this
        // ensures that we never double notify a deferral
        // in the case of a user call "Application.stop" in
        // the middle of processing an event
        //
        if (deferralID) {
            deferral = pendingDeferrals[deferralID];
            delete pendingDeferrals[deferralID];
        }
        if (deferral) {
            deferral.complete();
        }
    }
    function cleanupAllPendingDeferrals() {
        if (pendingDeferrals) {
            Object.keys(pendingDeferrals).forEach(function (k) {
                pendingDeferrals[k].complete();
            });
            pendingDeferrals = {};
        }
    }

    function dispatchEvent(eventRecord) {
        var waitForPromise = Promise.as();
        eventRecord.setPromise = function (promise) {
            /// <signature helpKeyword="TVJS.Application.eventRecord.setPromise">
            /// <summary locid="TVJS.Application.event.setPromise">
            /// Used to inform the application object that asynchronous work is being performed, and that this
            /// event handler should not be considered complete until the promise completes.
            /// </summary>
            /// <param name="promise" type="TVJS.Promise" locid="TVJS.Application.eventRecord.setPromise_p:promise">
            /// The promise to wait for.
            /// </param>
            /// </signature>
            waitForPromise = waitForPromise.then(function () { return promise; });
        };
        eventRecord._stoppedImmediatePropagation = false;
        eventRecord.stopImmediatePropagation = function () {
            eventRecord._stoppedImmediatePropagation = true;
        };
        eventRecord.detail = eventRecord.detail || {};
        if (typeof (eventRecord.detail) === "object") {
            eventRecord.detail.setPromise = eventRecord.setPromise;
        }

        try {
            if (listeners._listeners) {
                var handled = false;
                l = listeners._listeners[eventRecord.type];
                if (l) {
                    for (var i = 0, len = l.length; i < len && !eventRecord._stoppedImmediatePropagation; i++) {
                        handled = l[i].listener(eventRecord) || handled;
                    }
                }
            }

            // Fire built in listeners last, for checkpoint this is important
            // as it lets our built in serialization see any mutations to
            // app.sessionState
            //
            var l = builtInListeners[eventRecord.type];
            if (l) {
                l.forEach(function dispatchOne(e) { e(eventRecord, handled); });
            }
        }
        catch (err) {
            if (eventRecord.type === errorET) {
                fatalErrorHandler(eventRecord);
            } else {
                queueEvent({ type: errorET, detail: err });
            }
        }


        function cleanup(r) {
            if (eventRecord._deferral) {
                completeDeferral(eventRecord._deferral, eventRecord._deferralID);
            }
            return r;
        }

        return waitForPromise.then(cleanup, function (r) {
            r = cleanup(r);
            if (r && r.name === "Canceled") {
                return;
            }
            return Promise.wrapError(r);
        });
    }

    function createEventQueuedSignal() {
        if (!eventQueuedSignal) {
            eventQueuedSignal = new _Signal();
            eventQueuedSignal.promise.done(function () {
                eventQueuedSignal = null;
            }, function () {
                eventQueuedSignal = null;
            });
        }
        return eventQueuedSignal;
    }

    function drainOneEvent(queue) {
        function drainError(err) {
            queueEvent({ type: errorET, detail: err });
        }

        if (queue.length === 0) {
            return createEventQueuedSignal().promise;
        } else {
            return dispatchEvent(queue.shift()).then(null, drainError);
        }
    }

    // Drains the event queue via the scheduler
    //
    function drainQueue(jobInfo) {
        function drainNext() {
            return drainQueue;
        }

        var queue = jobInfo.job._queue;

        if (queue.length === 0 && eventQueue.length > 0) {
            queue = jobInfo.job._queue = copyAndClearQueue();
        }

        jobInfo.setPromise(drainOneEvent(queue).then(drainNext, drainNext));
    }

    function startEventQueue() {
        function markSync() {
            sync = true;
        }

        var queue = [];
        var sync = true;
        var promise;

        // Drain the queue as long as there are events and they complete synchronously
        //
        while (sync) {
            if (queue.length === 0 && eventQueue.length > 0) {
                queue = copyAndClearQueue();
            }

            sync = false;
            promise = drainOneEvent(queue);
            promise.done(markSync, markSync);
        }

        // Schedule a job which will be responsible for draining events for the
        //  lifetime of the application.
        //
        //eventQueueJob = setImmediate(function Application_pumpEventQueue(jobInfo) {
        //    function drainNext() {
        //        return drainQueue;
        //    }
        //    jobInfo.setPromise(promise.then(drainNext, drainNext));
        //});
        //eventQueueJob._queue = queue;
    }

    function queueEvent(eventRecord) {
        /// <signature helpKeyword="TVJS.Application.queueEvent">
        /// <summary locid="TVJS.Application.queueEvent">
        /// Queues an event to be processed by the TVJS.Application event queue.
        /// </summary>
        /// <param name="eventRecord" type="Object" locid="TVJS.Application.queueEvent_p:eventRecord">
        /// The event object is expected to have a type property that is
        /// used as the event name when dispatching on the TVJS.Application
        /// event queue. The entire object is provided to event listeners
        /// in the detail property of the event.
        /// </param>
        /// </signature>
        eventQueue.push(eventRecord);
        if (running && eventQueuedSignal) {
            eventQueuedSignal.complete(drainQueue);
        }
    }

    function copyAndClearQueue() {
        var queue = eventQueue;
        eventQueue = [];
        return queue;
    }

    var builtInListeners = {
        activated: [
            function Application_activatedHandler() {
                queueEvent({ type: readyET });
            }
        ],
        checkpoint: [
            function Application_checkpointHandler(e) {
                _State._oncheckpoint(e, exports);
            }
        ],
        error: [
            function Application_errorHandler(e, handled) {
                if (handled) {
                    return;
                }
                fatalErrorHandler(e);
            }
        ],
        backclick: [
            function Application_backClickHandler(e, handled) {
                if (handled) {
                    e._winRTBackPressedEvent.handled = true;
                } else if (Navigation.canGoBack) {
                    Navigation.back();
                    e._winRTBackPressedEvent.handled = true;
                }
            }
        ],
        beforerequestingfocusonkeyboardinput: [
            function Application_beforeRequestingFocusOnKeyboardInputHandler(e, handled) {
                if (!handled) {
                    dispatchEvent({ type: requestingFocusOnKeyboardInputET });
                }
            }
        ]
    };

    // loaded == DOMContentLoaded
    // activated == after WinRT Activated
    // ready == after all of the above
    //
    function activatedHandler(e) {
        var def = captureDeferral(e.activatedOperation);
        _State._loadState(e).then(function () {
            queueEvent({ type: activatedET, detail: e, _deferral: def.deferral, _deferralID: def.id });
        });
    }
    function suspendingHandler(e) {
        var def = captureDeferral(e.suspendingOperation);
        queueEvent({ type: checkpointET, _deferral: def.deferral, _deferralID: def.id });
    }
    function domContentLoadedHandler() {
        queueEvent({ type: loadedET });
        if (!(_Global.document && _WinRT.Windows.UI.WebUI.WebUIApplication)) {
            var activatedArgs = {
                arguments: "",
                kind: "Windows.Launch",
                previousExecutionState: 0 //_WinRT.Windows.ApplicationModel.Activation.ApplicationExecutionState.NotRunning
            };
            _State._loadState(activatedArgs).then(function () {
                queueEvent({ type: activatedET, detail: activatedArgs });
            });
        }
    }
    function beforeUnloadHandler() {
        cleanupAllPendingDeferrals();
        queueEvent({ type: unloadET });
    }
    function errorHandler(e) {
        var flattenedError = {};
        for (var key in e) {
            flattenedError[key] = e[key];
        }
        var data;
        var handled = true;
        var prev = exports._terminateApp;
        try {
            exports._terminateApp = function (d, e) {
                handled = false;
                data = d;
                if (prev !== defaultTerminateAppHandler) {
                    prev(d, e);
                }
            };
            dispatchEvent({
                type: errorET,
                detail: {
                    error: flattenedError,
                    errorLine: e.lineno,
                    errorCharacter: e.colno,
                    errorUrl: e.filename,
                    errorMessage: e.message
                }
            });
        } finally {
            exports._terminateApp = prev;
        }
        return handled;
    }
    function promiseErrorHandler(e) {
        //
        // e.detail looks like: { exception, error, promise, handler, id, parent }
        //
        var details = e.detail;
        var id = details.id;

        // If the error has a parent promise then this is not the origination of the
        //  error so we check if it has a handler, and if so we mark that the error
        //  was handled by removing it from outstandingPromiseErrors
        //
        if (details.parent) {
            if (details.handler && outstandingPromiseErrors) {
                delete outstandingPromiseErrors[id];
            }
            return;
        }

        // Work around browsers that don't serialize exceptions
        if (details.exception instanceof Error) {
            var error = {
                stack: details.exception.stack,
                message: details.exception.message
            };
            details.exception = error;
        }

        // If this is the first promise error to occur in this period we need to schedule
        //  a helper to come along after a setImmediate that propagates any remaining
        //  errors to the application's queue.
        //
        var shouldScheduleErrors = !outstandingPromiseErrors;

        // Indicate that this error was orignated and needs to be handled
        //
        outstandingPromiseErrors = outstandingPromiseErrors || [];
        outstandingPromiseErrors[id] = details;

        if (shouldScheduleErrors) {
            setImmediate(function Application_async_promiseErrorHandler() {
                var errors = outstandingPromiseErrors;
                outstandingPromiseErrors = null;
                errors.forEach(function (error) {
                    queueEvent({ type: errorET, detail: error });
                });
            });
        }
    }

    // capture this early
    //
    if (_Global.document) {
        _Global.document.addEventListener("DOMContentLoaded", domContentLoadedHandler, false);
    }

    function commandsRequested(e) {
        var event = { e: e, applicationcommands: undefined };
        listeners.dispatchEvent(settingsET, event);
    }

    function hardwareButtonBackPressed(winRTBackPressedEvent) {
        // Fire TVJS.Application 'backclick' event. If the winRTBackPressedEvent is not handled, the app will get suspended.
        var eventRecord = { type: backClickET };
        Object.defineProperty(eventRecord, "_winRTBackPressedEvent", {
            value: winRTBackPressedEvent,
            enumerable: false
        });
        dispatchEvent(eventRecord);
    }

    function requestingFocusOnKeyboardInput() {
        // Built in listener for beforeRequestingFocusOnKeyboardInputET will trigger
        // requestingFocusOnKeyboardInputET if it wasn't handled.
        dispatchEvent({ type: beforeRequestingFocusOnKeyboardInputET });
    }

    function edgyStarting(eventObject) {
        dispatchEvent({ type: edgyStartingET, kind: eventObject.kind });
    }

    function edgyCompleted(eventObject) {
        dispatchEvent({ type: edgyCompletedET, kind: eventObject.kind });
    }

    function edgyCanceled(eventObject) {
        dispatchEvent({ type: edgyCanceledET, kind: eventObject.kind });
    }

    function register() {
        if (!registered) {
            registered = true;
            _Global.addEventListener("beforeunload", beforeUnloadHandler, false);

            // None of these are enabled in web worker
            if (_Global.document) {
                _Global.addEventListener("error", errorHandler, false);
                if (_WinRT.Windows.UI.WebUI.WebUIApplication) {

                    var wui = _WinRT.Windows.UI.WebUI.WebUIApplication;
                    wui.addEventListener("activated", activatedHandler, false);
                    wui.addEventListener("suspending", suspendingHandler, false);
                }

                if (_WinRT.Windows.UI.ApplicationSettings.SettingsPane) {
                    var settingsPane = _WinRT.Windows.UI.ApplicationSettings.SettingsPane.getForCurrentView();
                    settingsPane.addEventListener("commandsrequested", commandsRequested);
                }

                // This integrates TVJS.Application into the hardware or OS-provided back button.
                if (_WinRT.Windows.UI.Core.SystemNavigationManager) {
                    // On Win10 this accomodates hardware buttons (phone), 
                    // the taskbar's tablet mode button, and the optional window frame back button.
                    var navManager = _WinRT.Windows.UI.Core.SystemNavigationManager.getForCurrentView();
                    navManager.addEventListener("backrequested", hardwareButtonBackPressed);
                } else if (_WinRT.Windows.Phone.UI.Input.HardwareButtons) {
                    // For WP 8.1
                    _WinRT.Windows.Phone.UI.Input.HardwareButtons.addEventListener("backpressed", hardwareButtonBackPressed);
                }

                if (_WinRT.Windows.UI.Input.EdgeGesture) {
                    var edgy = _WinRT.Windows.UI.Input.EdgeGesture.getForCurrentView();
                    edgy.addEventListener("starting", edgyStarting);
                    edgy.addEventListener("completed", edgyCompleted);
                    edgy.addEventListener("canceled", edgyCanceled);
                }
            }

            Promise.addEventListener("error", promiseErrorHandler);
        }
    }
    function unregister() {
        if (registered) {
            registered = false;
            _Global.removeEventListener("beforeunload", beforeUnloadHandler, false);

            // None of these are enabled in web worker
            if (_Global.document) {
                if (_WinRT.Windows.UI.WebUI.WebUIApplication) {
                    _Global.removeEventListener("error", errorHandler, false);

                    var wui = _WinRT.Windows.UI.WebUI.WebUIApplication;
                    wui.removeEventListener("activated", activatedHandler, false);
                    wui.removeEventListener("suspending", suspendingHandler, false);
                }

                if (_WinRT.Windows.UI.ApplicationSettings.SettingsPane) {
                    var settingsPane = _WinRT.Windows.UI.ApplicationSettings.SettingsPane.getForCurrentView();
                    settingsPane.removeEventListener("commandsrequested", commandsRequested);
                }

                if (_WinRT.Windows.UI.Core.SystemNavigationManager) {
                    var navManager = _WinRT.Windows.UI.Core.SystemNavigationManager.getForCurrentView();
                    navManager.removeEventListener("backrequested", hardwareButtonBackPressed);
                } else if (_WinRT.Windows.Phone.UI.Input.HardwareButtons) {
                    _WinRT.Windows.Phone.UI.Input.HardwareButtons.removeEventListener("backpressed", hardwareButtonBackPressed);
                }

                if (_WinRT.Windows.UI.Input.EdgeGesture) {
                    var edgy = _WinRT.Windows.UI.Input.EdgeGesture.getForCurrentView();
                    edgy.removeEventListener("starting", edgyStarting);
                    edgy.removeEventListener("completed", edgyCompleted);
                    edgy.removeEventListener("canceled", edgyCanceled);
                }
            }

            Promise.removeEventListener("error", promiseErrorHandler);
        }
    }

    var publicNS = _Base.Namespace._moduleDefine(exports, "TVJS.Application", {
        stop: function Application_stop() {
            /// <signature helpKeyword="TVJS.Application.stop">
            /// <summary locid="TVJS.Application.stop">
            /// Stops application event processing and resets TVJS.Application
            /// to its initial state.
            /// </summary>
            /// </signature>

            // Need to clear out the event properties explicitly to clear their backing
            //  state.
            //
            publicNS.onactivated = null;
            publicNS.oncheckpoint = null;
            publicNS.onerror = null;
            publicNS.onloaded = null;
            publicNS.onready = null;
            publicNS.onsettings = null;
            publicNS.onunload = null;
            publicNS.onbackclick = null;
            listeners = new ListenerType();
            _State.sessionState = {};
            running = false;
            copyAndClearQueue();
            eventQueueJob && eventQueueJob.cancel();
            eventQueueJob = null;
            eventQueuedSignal = null;
            unregister();
            TypeToSearch.updateRegistration();
            cleanupAllPendingDeferrals();
        },

        addEventListener: function Application_addEventListener(eventType, listener, capture) {
            /// <signature helpKeyword="TVJS.Application.addEventListener">
            /// <summary locid="TVJS.Application.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="eventType" locid="TVJS.Application.addEventListener_p:eventType">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="TVJS.Application.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="capture" locid="TVJS.Application.addEventListener_p:capture">
            /// true to initiate capture; otherwise, false.
            /// </param>
            /// </signature>
            listeners.addEventListener(eventType, listener, capture);
            if (eventType === requestingFocusOnKeyboardInputET) {
                TypeToSearch.updateRegistration();
            }
        },
        removeEventListener: function Application_removeEventListener(eventType, listener, capture) {
            /// <signature helpKeyword="TVJS.Application.removeEventListener">
            /// <summary locid="TVJS.Application.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="eventType" locid="TVJS.Application.removeEventListener_p:eventType">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="TVJS.Application.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="capture" locid="TVJS.Application.removeEventListener_p:capture">
            /// Specifies whether or not to initiate capture.
            /// </param>
            /// </signature>
            listeners.removeEventListener(eventType, listener, capture);
            if (eventType === requestingFocusOnKeyboardInputET) {
                TypeToSearch.updateRegistration();
            }
        },

        checkpoint: function Application_checkpoint() {
            /// <signature helpKeyword="TVJS.Application.checkpoint">
            /// <summary locid="TVJS.Application.checkpoint">
            /// Queues a checkpoint event.
            /// </summary>
            /// </signature>
            queueEvent({ type: checkpointET });
        },

        start: function Application_start() {
            /// <signature helpKeyword="TVJS.Application.start">
            /// <summary locid="TVJS.Application.start">
            /// Starts processing events in the TVJS.Application event queue.
            /// </summary>
            /// </signature>
            register();
            running = true;
            startEventQueue();
        },

        queueEvent: queueEvent,

        // Like queueEvent but fires the event synchronously. Useful in tests.
        _dispatchEvent: dispatchEvent,

        _terminateApp: {
            get: function Application_terminateApp_get() {
                return terminateAppHandler;
            },
            set: function Application_terminateApp_set(value) {
                terminateAppHandler = value;
            }
        },

        _applicationListener: _Base.Namespace._lazy(function () {
            // Use _lazy because publicNS can't be referenced in its own definition
            return new _ElementUtilities._GenericListener("Application", publicNS);
        }),

        /// <field type="Function" locid="TVJS.Application.oncheckpoint" helpKeyword="TVJS.Application.oncheckpoint">
        /// Occurs when receiving Process Lifetime Management (PLM) notification or when the checkpoint function is called.
        /// </field>
        oncheckpoint: createEvent(checkpointET),
        /// <field type="Function" locid="TVJS.Application.onunload" helpKeyword="TVJS.Application.onunload">
        /// Occurs when the application is about to be unloaded.
        /// </field>
        onunload: createEvent(unloadET),
        /// <field type="Function" locid="TVJS.Application.onactivated" helpKeyword="TVJS.Application.onactivated">
        /// Occurs when Windows Runtime activation has occurred.
        /// The name of this event is "activated" (and also "mainwindowactivated".)
        /// This event occurs after the loaded event and before the ready event.
        /// </field>
        onactivated: createEvent(activatedET),
        /// <field type="Function" locid="TVJS.Application.onloaded" helpKeyword="TVJS.Application.onloaded">
        /// Occurs after the DOMContentLoaded event, which fires after the page has been parsed but before all the resources are loaded.
        /// This event occurs before the activated event and the ready event.
        /// </field>
        onloaded: createEvent(loadedET),
        /// <field type="Function" locid="TVJS.Application.onready" helpKeyword="TVJS.Application.onready">
        /// Occurs when the application is ready. This event occurs after the onloaded event and the onactivated event.
        /// </field>
        onready: createEvent(readyET),
        /// <field type="Function" locid="TVJS.Application.onsettings" helpKeyword="TVJS.Application.onsettings">
        /// Occurs when the settings charm is invoked.
        /// </field>
        onsettings: createEvent(settingsET),
        /// <field type="Function" locid="TVJS.Application.onerror" helpKeyword="TVJS.Application.onerror">
        /// Occurs when an unhandled error has been raised.
        /// </field>
        onerror: createEvent(errorET),
        /// <field type="Function" locid="TVJS.Application.onbackclick" helpKeyword="TVJS.Application.onbackclick">
        /// Raised when the users clicks the hardware back button.
        /// </field>
        onbackclick: createEvent(backClickET)


    });
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Animations/_Constants',[
    'exports',
    '../Core/_Base'
    ], function animationsConstantsInit(exports, _Base) {
    "use strict";

    _Base.Namespace._moduleDefine(exports, "TVJS.UI", {
        /// <field locid="TVJS.UI.PageNavigationAnimation" helpKeyword="TVJS.UI.PageNavigationAnimation">
        /// Specifies what animation type should be returned by TVJS.UI.Animation.createPageNavigationAnimations.
        /// </field>
        PageNavigationAnimation: {
            /// <field locid="TVJS.UI.PageNavigationAnimation.turnstile" helpKeyword="TVJS.UI.PageNavigationAnimation.turnstile">
            /// The pages will exit and enter using a turnstile animation.
            /// </field>
            turnstile: "turnstile",
            /// <field locid="TVJS.UI.PageNavigationAnimation.slide" helpKeyword="TVJS.UI.PageNavigationAnimation.slide">
            /// The pages will exit and enter using an animation that slides up/down.
            /// </field>
            slide: "slide",
            /// <field locid="TVJS.UI.PageNavigationAnimation.enterPage" helpKeyword="TVJS.UI.PageNavigationAnimation.enterPage">
            /// The pages will enter using an enterPage animation, and exit with no animation.
            /// </field>
            enterPage: "enterPage",
            /// <field locid="TVJS.UI.PageNavigationAnimation.continuum" helpKeyword="TVJS.UI.PageNavigationAnimation.continuum">
            /// The pages will exit and enter using a continuum animation.
            /// </field>
            continuum: "continuum"
        }
    });

});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Animations/_TransitionAnimation',[
    'exports',
    '../Core/_Global',
    '../Core/_WinRT',
    '../Core/_Base',
    '../Core/_BaseUtils',
    '../Promise',
    '../Utilities/_ElementUtilities'
    ], function transitionAnimationInit(exports, _Global, _WinRT, _Base, _BaseUtils, Promise, _ElementUtilities) {
    "use strict";

    // not supported in WebWorker
    if (!_Global.document) {
        return;
    }

    var browserStyleEquivalents = _BaseUtils._browserStyleEquivalents;

    function makeArray(elements) {
        if (Array.isArray(elements) || elements instanceof _Global.NodeList || elements instanceof _Global.HTMLCollection) {
            return elements;
        } else if (elements) {
            return [elements];
        } else {
            return [];
        }
    }

    var keyframeCounter = 0;
    function getUniqueKeyframeName() {
        ++keyframeCounter;
        return "TVJSUIAnimation" + keyframeCounter;
    }
    function isUniqueKeyframeName(s) {
        return "TVJSUIAnimation" === s.substring(0, 16);
    }

    function resolveStyles(elem) {
        _ElementUtilities._getComputedStyle(elem, null).opacity;
    }

    function copyWithEvaluation(iElem, elem) {
        return function (obj) {
            var newObj = {};
            for (var p in obj) {
                var v = obj[p];
                if (typeof v === "function") {
                    v = v(iElem, elem);
                }
                newObj[p] = v;
            }
            if (!newObj.exactTiming) {
                newObj.delay += exports._libraryDelay;
            }
            return newObj;
        };
    }

    var activeActions = [];

    var reason_interrupted = 1;
    var reason_canceled = 2;

    function stopExistingAction(id, prop) {
        var key = id + "|" + prop;
        var finish = activeActions[key];
        if (finish) {
            finish(reason_interrupted);
        }
    }

    function registerAction(id, prop, finish) {
        activeActions[id + "|" + prop] = finish;
    }

    function unregisterAction(id, prop) {
        delete activeActions[id + "|" + prop];
    }

    var StyleCache = _Base.Class.define(
        // Constructor
        function StyleCache_ctor(id, desc, style) {
            this.cref = 0;
            this.id = id;
            this.desc = desc;
            this.removed = {};
            this.prevStyles = desc.props.map(function (p) { return style[p[0]]; });
            this.prevNames = this.names = style[desc.nameProp];
            desc.styleCaches[id] = this;
        }, {
            // Members
            destroy: function StyleCache_destroy(style, skipStylesReset) {
                var desc = this.desc;
                delete desc.styleCaches[this.id];
                if (!skipStylesReset) {
                    if (this.prevNames === "" &&
                        this.prevStyles.every(function (s) { return s === ""; })) {
                        style[desc.shorthandProp] = "";
                    } else {
                        desc.props.forEach(function (p, i) {
                            style[p[0]] = this.prevStyles[i];
                        }, this);
                        style[desc.nameProp] = this.prevNames;
                    }
                }
            },
            removeName: function StyleCache_removeName(style, name, elem, skipStylesReset) {
                var nameValue = this.names;
                var names = nameValue.split(", ");
                var index = names.lastIndexOf(name);
                if (index >= 0) {
                    names.splice(index, 1);
                    this.names = nameValue = names.join(", ");
                    if (nameValue === "" && this.desc.isTransition) {
                        nameValue = "none";
                    }
                }
                if (--this.cref) {
                    style[this.desc.nameProp] = nameValue;
                    if (!isUniqueKeyframeName(name)) {
                        this.removed[name] = true;
                    }
                } else {
                    if (elem && nameValue === "none") {
                        style[this.desc.nameProp] = nameValue;
                        resolveStyles(elem);
                    }
                    this.destroy(style, skipStylesReset);
                }
            }
        });

    function setTemporaryStyles(elem, id, style, actions, desc) {
        var styleCache = desc.styleCaches[id] ||
                         new StyleCache(id, desc, style);
        styleCache.cref += actions.length;

        actions.forEach(function (action) {
            stopExistingAction(id, action.property);
        });

        if (desc.isTransition ||
            actions.some(function (action) {
                return styleCache.removed[action[desc.nameField]];
        })) {
            resolveStyles(elem);
            styleCache.removed = {};
        }

        var newShorthand = actions.map(function (action) {
            return action[desc.nameField] + " " +
                desc.props.map(function (p) {
                    return (p[1] ? action[p[1]] : "") + p[2];
                }).join(" ");
        }).join(", ");

        var newNames = actions.map(function (action) {
            return action[desc.nameField];
        }).join(", ");
        if (styleCache.names !== "") {
            newShorthand = styleCache.names + ", " + newShorthand;
            newNames = styleCache.names + ", " + newNames;
        }

        style[desc.shorthandProp] = newShorthand;
        styleCache.names = newNames;
        return styleCache;
    }

    var elementTransitionProperties = {
        shorthandProp: browserStyleEquivalents["transition"].scriptName,
        nameProp: browserStyleEquivalents["transition-property"].scriptName,
        nameField: "property",
        props: [
            [browserStyleEquivalents["transition-duration"].scriptName, "duration", "ms"],
            [browserStyleEquivalents["transition-timing-function"].scriptName, "timing", ""],
            [browserStyleEquivalents["transition-delay"].scriptName, "delay", "ms"]
        ],
        isTransition: true,
        styleCaches: []
    };

    function completePromise(c, synchronous) {
        if (synchronous) {
            c();
        } else {
            setImmediate(function _Animation_completeAnimationPromise() {
                c();
            });
        }
    }

    var uniformizeStyle;
    function executeElementTransition(elem, index, transitions, promises, animate) {
        if (transitions.length > 0) {
            var style = elem.style;
            var id = _ElementUtilities._uniqueID(elem);
            if (!uniformizeStyle) {
                uniformizeStyle = _Global.document.createElement("DIV").style;
            }
            transitions = transitions.map(copyWithEvaluation(index, elem));
            transitions.forEach(function (transition) {
                var scriptNameOfProperty = _BaseUtils._getCamelCasedName(transition.property);
                if (transition.hasOwnProperty("from")) {
                    style[scriptNameOfProperty] = transition.from;
                }
                uniformizeStyle[scriptNameOfProperty] = transition.to;
                transition.to = uniformizeStyle[scriptNameOfProperty];
                transition.propertyScriptName = scriptNameOfProperty;
            });

            if (animate) {
                var styleCache = setTemporaryStyles(elem, id, style, transitions, elementTransitionProperties);
                var listener = elem.disabled ? _Global.document : elem;

                transitions.forEach(function (transition) {
                    var finish;
                    promises.push(new Promise(function (c) {
                        finish = function (reason) {
                            if (onTransitionEnd) {
                                listener.removeEventListener(_BaseUtils._browserEventEquivalents["transitionEnd"], onTransitionEnd, false);
                                unregisterAction(id, transition.property);
                                styleCache.removeName(style, transition.propertyScriptName, reason ? elem : null, transition.skipStylesReset);
                                _Global.clearTimeout(timeoutId);
                                onTransitionEnd = null;
                            }
                            completePromise(c, reason === reason_canceled);
                        };

                        var onTransitionEnd = function (event) {
                            if (event.target === elem && event.propertyName === transition.property) {
                                finish();
                            }
                        };

                        registerAction(id, transition.property, finish);
                        listener.addEventListener(_BaseUtils._browserEventEquivalents["transitionEnd"], onTransitionEnd, false);

                        var padding = 0;
                        if (style[transition.propertyScriptName] !== transition.to) {
                            style[transition.propertyScriptName] = transition.to;
                            padding = 50;
                        }
                        var timeoutId = _Global.setTimeout(function () {
                            timeoutId = _Global.setTimeout(finish, transition.delay + transition.duration);
                        }, padding);
                    }, function () { finish(reason_canceled); }));
                });
            } else {
                transitions.forEach(function (transition) {
                    style[transition.propertyScriptName] = transition.to;
                });
            }
        }
    }

    var elementAnimationProperties = {
        shorthandProp: browserStyleEquivalents["animation"].scriptName,
        nameProp: browserStyleEquivalents["animation-name"].scriptName,
        nameField: "keyframe",
        props: [
            [browserStyleEquivalents["animation-duration"].scriptName, "duration", "ms"],
            [browserStyleEquivalents["animation-timing-function"].scriptName, "timing", ""],
            [browserStyleEquivalents["animation-delay"].scriptName, "delay", "ms"],
            [browserStyleEquivalents["animation-iteration-count"].scriptName, "", "1"],
            [browserStyleEquivalents["animation-direction"].scriptName, "", "normal"],
            [browserStyleEquivalents["animation-fill-mode"].scriptName, "", "both"]
        ],
        isTransition: false,
        styleCaches: []
    };

    function executeElementAnimation(elem, index, anims, promises, animate) {
        if (animate && anims.length > 0) {
            var style = elem.style;
            var id = _ElementUtilities._uniqueID(elem);
            anims = anims.map(copyWithEvaluation(index, elem));
            var styleElem;
            var listener = elem.disabled ? _Global.document : elem;
            anims.forEach(function (anim) {
                if (!anim.keyframe) {
                    if (!styleElem) {
                        styleElem = _Global.document.createElement("STYLE");
                        _Global.document.documentElement.appendChild(styleElem);
                    }
                    anim.keyframe = getUniqueKeyframeName();
                    var kf = "@" + browserStyleEquivalents["keyframes"] + " " + anim.keyframe + " { from {" + anim.property + ":" + anim.from + ";} to {" + anim.property + ":" + anim.to + ";}}";
                    styleElem.sheet.insertRule(kf, 0);
                } else {
                    anim.keyframe = browserStyleEquivalents.animationPrefix + anim.keyframe;
                }
            });
            var styleCache = setTemporaryStyles(elem, id, style, anims, elementAnimationProperties),
                animationsToCleanUp = [],
                animationPromises = [];
            anims.forEach(function (anim) {
                var finish;
                animationPromises.push(new Promise(function (c) {
                    finish = function (reason) {
                        if (onAnimationEnd) {
                            listener.removeEventListener(_BaseUtils._browserEventEquivalents["animationEnd"], onAnimationEnd, false);
                            _Global.clearTimeout(timeoutId);
                            onAnimationEnd = null;
                        }
                        completePromise(c, reason === reason_canceled);
                    };

                    var onAnimationEnd = function (event) {
                        if (event.target === elem && event.animationName === anim.keyframe) {
                            finish();
                        }
                    };

                    registerAction(id, anim.property, finish);
                    // Firefox will stop all animations if we clean up that animation's properties when there're other CSS animations still running
                    // on an element. To work around this, we delay animation style cleanup until all parts of an animation finish.
                    animationsToCleanUp.push({
                        id: id,
                        property: anim.property,
                        style: style,
                        keyframe: anim.keyframe
                    });
                    var timeoutId = _Global.setTimeout(function () {
                        timeoutId = _Global.setTimeout(finish, anim.delay + anim.duration);
                    }, 50);
                    listener.addEventListener(_BaseUtils._browserEventEquivalents["animationEnd"], onAnimationEnd, false);
                }, function () { finish(reason_canceled); }));
            });
            if (styleElem) {
                _Global.setTimeout(function () {
                    var parentElement = styleElem.parentElement;
                    if (parentElement) {
                        parentElement.removeChild(styleElem);
                    }
                }, 50);
            }

            var cleanupAnimations = function () {
                for (var i = 0; i < animationsToCleanUp.length; i++) {
                    var anim = animationsToCleanUp[i];
                    unregisterAction(anim.id, anim.property);
                    styleCache.removeName(anim.style, anim.keyframe);
                }
            };
            promises.push(Promise.join(animationPromises).then(cleanupAnimations, cleanupAnimations));
        }
    }

    var enableCount = 0;
    var animationSettings;
    function initAnimations() {
        if (!animationSettings) {
            if (_WinRT.Windows.UI.ViewManagement.UISettings) {
                animationSettings = new _WinRT.Windows.UI.ViewManagement.UISettings();
            } else {
                animationSettings = { animationsEnabled: true };
            }
        }
    }

    var isAnimationEnabled = function isAnimationEnabledImpl() {
        /// <signature helpKeyword="TVJS.UI.isAnimationEnabled">
        /// <summary locid="TVJS.UI.isAnimationEnabled">
        /// Determines whether the TVJS Animation Library will perform animations.
        /// </summary>
        /// <returns type="Boolean" locid="TVJS.UI.isAnimationEnabled_returnValue">
        /// true if TVJS animations will be performed.
        /// false if TVJS animations are suppressed.
        /// </returns>
        /// </signature>
        initAnimations();
        return enableCount + animationSettings.animationsEnabled > 0;
    };

    function applyAction(element, action, execAction) {
        try {
            var animate = exports.isAnimationEnabled();
            var elems = makeArray(element);
            var actions = makeArray(action);

            var promises = [];

            for (var i = 0; i < elems.length; i++) {
                if (Array.isArray(elems[i])) {
                    for (var j = 0; j < elems[i].length; j++) {
                        execAction(elems[i][j], i, actions, promises, animate);
                    }
                } else {
                    execAction(elems[i], i, actions, promises, animate);
                }
            }

            if (promises.length) {
                return Promise.join(promises);
            } else {
                return setImmediate(function () {
                    // Convert a cancelation to the success path
                });
            }
        } catch (e) {
            return Promise.wrapError(e);
        }
    }

    function adjustAnimationTime(animation) {
        if (Array.isArray(animation)) {
            return animation.map(function (animation) {
                return adjustAnimationTime(animation);
            });
        } else if (animation) {
            animation.delay = animationTimeAdjustment(animation.delay);
            animation.duration = animationTimeAdjustment(animation.duration);
            return animation;
        } else {
            return;
        }
    }

    function animationAdjustment(animation) {
        if (animationFactor === 1) {
            return animation;
        } else {
            return adjustAnimationTime(animation);
        }
    }

    var animationTimeAdjustment = function _animationTimeAdjustmentImpl(v) {
        return v * animationFactor;
    };

    var animationFactor = 1;
    var libraryDelay = 0;

    _Base.Namespace._moduleDefine(exports, "TVJS.UI", {
        disableAnimations: function () {
            /// <signature helpKeyword="TVJS.UI.disableAnimations">
            /// <summary locid="TVJS.UI.disableAnimations">
            /// Disables animations in the TVJS Animation Library
            /// by decrementing the animation enable count.
            /// </summary>
            /// </signature>
            enableCount--;
        },

        enableAnimations: function () {
            /// <signature helpKeyword="TVJS.UI.enableAnimations">
            /// <summary locid="TVJS.UI.enableAnimations">
            /// Enables animations in the TVJS Animation Library
            /// by incrementing the animation enable count.
            /// </summary>
            /// </signature>
            enableCount++;
        },

        isAnimationEnabled: {
            get: function () {
                return isAnimationEnabled;
            },
            set: function (value) {
                isAnimationEnabled = value;
            }
        },

        _libraryDelay: {
            get: function () {
                return libraryDelay;
            },
            set: function (value) {
                libraryDelay = value;
            }
        },

        executeAnimation: function (element, animation) {
            /// <signature helpKeyword="TVJS.UI.executeAnimation">
            /// <summary locid="TVJS.UI.executeAnimation">
            /// Perform a CSS animation that can coexist with other
            /// Animation Library animations. Applications are not expected
            /// to call this function directly; they should prefer to use
            /// the high-level animations in the Animation Library.
            /// </summary>
            /// <param name="element" locid="TVJS.UI.executeAnimation_p:element">
            /// Single element or collection of elements on which
            /// to perform a CSS animation.
            /// </param>
            /// <param name="animation" locid="TVJS.UI.executeAnimation_p:animation">
            /// Single animation description or array of animation descriptions.
            /// </param>
            /// <returns type="TVJS.Promise" locid="TVJS.UI.executeAnimation_returnValue">
            /// Promise object that completes when the CSS animation is complete.
            /// </returns>
            /// </signature>
            return applyAction(element, animationAdjustment(animation), executeElementAnimation);
        },

        executeTransition: function (element, transition) {
            /// <signature helpKeyword="TVJS.UI.executeTransition">
            /// <summary locid="TVJS.UI.executeTransition">
            /// Perform a CSS transition that can coexist with other
            /// Animation Library animations. Applications are not expected
            /// to call this function directly; they should prefer to use
            /// the high-level animations in the Animation Library.
            /// </summary>
            /// <param name="element" locid="TVJS.UI.executeTransition_p:element">
            /// Single element or collection of elements on which
            /// to perform a CSS transition.
            /// </param>
            /// <param name="transition" locid="TVJS.UI.executeTransition_p:transition">
            /// Single transition description or array of transition descriptions.
            /// </param>
            /// <returns type="TVJS.Promise" locid="TVJS.UI.executeTransition_returnValue">
            /// Promise object that completes when the CSS transition is complete.
            /// </returns>
            /// </signature>
            return applyAction(element, animationAdjustment(transition), executeElementTransition);
        },

        _animationTimeAdjustment: {
            get: function () {
                return animationTimeAdjustment;
            },
            set: function (value) {
                animationTimeAdjustment = value;
            }
        }

    });

    _Base.Namespace._moduleDefine(exports, "TVJS.Utilities", {
        _fastAnimations: {
            get: function () {
                return animationFactor === 1/20;
            },
            set: function (value) {
                animationFactor = value ? 1/20 : 1;
            }
        },
        _slowAnimations: {
            get: function () {
                return animationFactor === 3;
            },
            set: function (value) {
                animationFactor = value ? 3 : 1;
            }
        },
        _animationFactor: {
            get: function () {
                return animationFactor;
            },
            set: function (value) {
                animationFactor = value;
            }
        },
    });

});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Animations',[
    'exports',
    './Core/_Global',
    './Core/_Base',
    './Core/_BaseUtils',
    './Utilities/_ElementUtilities',
    './Animations/_Constants',
    './Animations/_TransitionAnimation',
    './Promise'
], function animationsInit(exports, _Global, _Base, _BaseUtils, _ElementUtilities, _Constants, _TransitionAnimation, Promise) {
    "use strict";

    var transformNames = _BaseUtils._browserStyleEquivalents["transform"];

    // Default to 11 pixel from the left (or right if RTL)
    var defaultOffset = [{ top: "0px", left: "11px", rtlflip: true }];

    var OffsetArray = _Base.Class.define(function OffsetArray_ctor(offset, keyframe, defOffset) {
        // Constructor
        defOffset = defOffset || defaultOffset;
        if (Array.isArray(offset) && offset.length > 0) {
            this.offsetArray = offset;
            if (offset.length === 1) {
                this.keyframe = checkKeyframe(offset[0], defOffset[0], keyframe);
            }
        } else if (offset && offset.hasOwnProperty("top") && offset.hasOwnProperty("left")) {
            this.offsetArray = [offset];
            this.keyframe = checkKeyframe(offset, defOffset[0], keyframe);
        } else {
            this.offsetArray = defOffset;
            this.keyframe = chooseKeyframe(defOffset[0], keyframe);
        }
    }, { // Public Members
        getOffset: function (i) {
            if (i >= this.offsetArray.length) {
                i = this.offsetArray.length - 1;
            }
            return this.offsetArray[i];
        }
    }, { // Static Members
        supportedForProcessing: false,
    });

    function checkKeyframe(offset, defOffset, keyframe) {
        if (offset.keyframe) {
            return offset.keyframe;
        }

        if (!keyframe ||
            offset.left !== defOffset.left ||
            offset.top !== defOffset.top ||
            (offset.rtlflip && !defOffset.rtlflip)) {
            return null;
        }

        if (!offset.rtlflip) {
            return keyframe;
        }

        return keyframeCallback(keyframe);
    }

    function chooseKeyframe(defOffset, keyframe) {
        if (!keyframe || !defOffset.rtlflip) {
            return keyframe;
        }

        return keyframeCallback(keyframe);
    }

    function keyframeCallback(keyframe) {
        var keyframeRtl = keyframe + "-rtl";
        return function (i, elem) {
            return _ElementUtilities._getComputedStyle(elem).direction === "ltr" ? keyframe : keyframeRtl;
        };
    }

    function makeArray(elements) {
        if (Array.isArray(elements) || elements instanceof _Global.NodeList || elements instanceof _Global.HTMLCollection) {
            return elements;
        } else if (elements) {
            return [elements];
        } else {
            return [];
        }
    }

    function collectOffsetArray(elemArray) {
        var offsetArray = [];
        for (var i = 0; i < elemArray.length; i++) {
            var offset = {
                top: elemArray[i].offsetTop,
                left: elemArray[i].offsetLeft
            };
            var matrix = _ElementUtilities._getComputedStyle(elemArray[i], null)[transformNames.scriptName].split(",");
            if (matrix.length === 6) {
                offset.left += parseFloat(matrix[4]);
                offset.top += parseFloat(matrix[5]);
            }
            offsetArray.push(offset);
        }
        return offsetArray;
    }

    function staggerDelay(initialDelay, extraDelay, delayFactor, delayCap) {
        return function (i) {
            var ret = initialDelay;
            for (var j = 0; j < i; j++) {
                extraDelay *= delayFactor;
                ret += extraDelay;
            }
            if (delayCap) {
                ret = Math.min(ret, delayCap);
            }
            return ret;
        };
    }

    function makeOffsetsRelative(elemArray, offsetArray) {
        for (var i = 0; i < offsetArray.length; i++) {
            offsetArray[i].top -= elemArray[i].offsetTop;
            offsetArray[i].left -= elemArray[i].offsetLeft;
        }
    }

    function animTranslate2DTransform(elemArray, offsetArray, transition) {
        makeOffsetsRelative(elemArray, offsetArray);
        for (var i = 0; i < elemArray.length; i++) {
            if (offsetArray[i].top !== 0 || offsetArray[i].left !== 0) {
                elemArray[i].style[transformNames.scriptName] = "translate(" + offsetArray[i].left + "px, " + offsetArray[i].top + "px)";
            }
        }
        return _TransitionAnimation.executeTransition(elemArray, transition);
    }

    function animStaggeredSlide(curve, start, end, fadeIn, page, first, second, third) {
        var elementArray = [],
            startOffsetArray = [],
            endOffsetArray = [];
        function prepareSlide(elements, start, end) {
            if (!elements) {
                return;
            }
            var startOffset = {
                left: start + "px",
                top: "0px"
            },
            endOffset = {
                left: end + "px",
                top: "0px"
            };
            if (+elements.length === elements.length) {
                for (var i = 0, len = elements.length; i < len; i++) {
                    elementArray.push(elements[i]);
                    startOffsetArray.push(startOffset);
                    endOffsetArray.push(endOffset);
                }
            } else {
                elementArray.push(elements);
                startOffsetArray.push(startOffset);
                endOffsetArray.push(endOffset);
            }
        }
        var horizontalOffset = 200,
            startOffset = (start !== 0 ? (start < 0 ? -horizontalOffset : horizontalOffset) : 0),
            endOffset = (end !== 0 ? (end < 0 ? -horizontalOffset : horizontalOffset) : 0);
        prepareSlide(page, start, end);
        prepareSlide(first, startOffset, endOffset);
        prepareSlide(second, startOffset * 2, endOffset * 2);
        prepareSlide(third, startOffset * 3, endOffset * 3);
        startOffsetArray = new OffsetArray(startOffsetArray);
        endOffsetArray = new OffsetArray(endOffsetArray);
        return _TransitionAnimation.executeTransition(
            elementArray,
            [{
                property: transformNames.cssName,
                delay: 0,
                duration: 350,
                timing: curve,
                from: translateCallback(startOffsetArray),
                to: translateCallback(endOffsetArray)
            },
            {
                property: "opacity",
                delay: 0,
                duration: 350,
                timing: fadeIn ? "steps(1, start)" : "steps(1, end)",
                from: fadeIn ? 0 : 1,
                to: fadeIn ? 1 : 0
            }]);
    }

    function animRotationTransform(elemArray, origins, transition) {
        elemArray = makeArray(elemArray);
        origins = makeArray(origins);
        for (var i = 0, len = elemArray.length; i < len; i++) {
            var rtl = _ElementUtilities._getComputedStyle(elemArray[i]).direction === "rtl";
            elemArray[i].style[_BaseUtils._browserStyleEquivalents["transform-origin"].scriptName] = origins[Math.min(origins.length - 1, i)][rtl ? "rtl" : "ltr"];
        }
        function onComplete() {
            clearAnimRotationTransform(elemArray);
        }
        return _TransitionAnimation.executeTransition(elemArray, transition).then(onComplete, onComplete);
    }

    function clearAnimRotationTransform(elemArray) {
        for (var i = 0, len = elemArray.length; i < len; i++) {
            elemArray[i].style[_BaseUtils._browserStyleEquivalents["transform-origin"].scriptName] = "";
            elemArray[i].style[transformNames.scriptName] = "";
            elemArray[i].style.opacity = "";
        }
    }

    function translateCallback(offsetArray, prefix) {
        prefix = prefix || "";
        return function (i, elem) {
            var offset = offsetArray.getOffset(i);
            var left = offset.left;
            if (offset.rtlflip && _ElementUtilities._getComputedStyle(elem).direction === "rtl") {
                left = left.toString();
                if (left.charAt(0) === "-") {
                    left = left.substring(1);
                } else {
                    left = "-" + left;
                }
            }
            return prefix + "translate(" + left + ", " + offset.top + ")";
        };
    }

    function translateCallbackAnimate(offsetArray, suffix) {
        suffix = suffix || "";
        return function (i) {
            var offset = offsetArray[i];
            return "translate(" + offset.left + "px, " + offset.top + "px) " + suffix;
        };
    }

    function keyframeCallbackAnimate(offsetArray, keyframe) {
        return function (i) {
            var offset = offsetArray[i];
            return (offset.left === 0 && offset.top === 0) ? keyframe : null;
        };
    }

    function layoutTransition(LayoutTransition, target, affected, extra) {
        var targetArray = makeArray(target);
        var affectedArray = makeArray(affected);
        var offsetArray = collectOffsetArray(affectedArray);
        return new LayoutTransition(targetArray, affectedArray, offsetArray, extra);
    }

    function collectTurnstileTransformOrigins(elements) {
        var origins = [];
        for (var i = 0, len = elements.length; i < len; i++) {
            var itemBoundingBox = elements[i].getBoundingClientRect();
            var offsetLeftLTR = -(40 + itemBoundingBox.left);
            var offsetLeftRTL = 40 + (_Global.innerWidth - itemBoundingBox.right);
            var totalOffsetY = ((_Global.innerHeight / 2) - itemBoundingBox.top);
            origins.push(
                {
                    ltr: offsetLeftLTR + "px " + totalOffsetY + "px",
                    rtl: offsetLeftRTL + "px " + totalOffsetY + "px"
                }
            );
        }

        return origins;
    }

    function writeAnimationProfilerMark(text) {
    }

    var ExpandAnimation = _Base.Class.define(function ExpandAnimation_ctor(revealedArray, affectedArray, offsetArray) {
        // Constructor
        this.revealedArray = revealedArray;
        this.affectedArray = affectedArray;
        this.offsetArray = offsetArray;
    }, { // Public Members
        execute: function () {
            writeAnimationProfilerMark("expandAnimation,StartTM");
            var promise1 = _TransitionAnimation.executeAnimation(
                this.revealedArray,
                {
                    keyframe: "TVJS-opacity-in",
                    property: "opacity",
                    delay: this.affectedArray.length > 0 ? 200 : 0,
                    duration: 167,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    from: 0,
                    to: 1
                });
            var promise2 = animTranslate2DTransform(
                this.affectedArray,
                this.offsetArray,
                {
                    property: transformNames.cssName,
                    delay: 0,
                    duration: 367,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    to: ""
                });
            return Promise.join([promise1, promise2])
                .then(function () { writeAnimationProfilerMark("expandAnimation,StopTM"); });
        }
    }, { // Static Members
        supportedForProcessing: false,
    });

    var CollapseAnimation = _Base.Class.define(function CollapseAnimation_ctor(hiddenArray, affectedArray, offsetArray) {
        // Constructor
        this.hiddenArray = hiddenArray;
        this.affectedArray = affectedArray;
        this.offsetArray = offsetArray;
    }, { // Public Members
        execute: function () {
            writeAnimationProfilerMark("collapseAnimation,StartTM");
            var promise1 = _TransitionAnimation.executeAnimation(
                this.hiddenArray,
                {
                    keyframe: "TVJS-opacity-out",
                    property: "opacity",
                    delay: 0,
                    duration: 167,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    from: 1,
                    to: 0
                });
            var promise2 = animTranslate2DTransform(
                this.affectedArray,
                this.offsetArray,
                {
                    property: transformNames.cssName,
                    delay: this.hiddenArray.length > 0 ? 167 : 0,
                    duration: 367,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    to: ""
                });
            return Promise.join([promise1, promise2])
                .then(function () { writeAnimationProfilerMark("collapseAnimation,StopTM"); });
        }
    }, { // Static Members
        supportedForProcessing: false,
    });

    var RepositionAnimation = _Base.Class.define(function RepositionAnimation_ctor(target, elementArray, offsetArray) {
        // Constructor
        this.elementArray = elementArray;
        this.offsetArray = offsetArray;
    }, { // Public Members
        execute: function () {
            writeAnimationProfilerMark("repositionAnimation,StartTM");
            return animTranslate2DTransform(
                this.elementArray,
                this.offsetArray,
                {
                    property: transformNames.cssName,
                    delay: staggerDelay(0, 33, 1, 250),
                    duration: 367,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    to: ""
                })
                .then(function () { writeAnimationProfilerMark("repositionAnimation,StopTM"); });
        }
    }, { // Static Members
        supportedForProcessing: false,
    });

    var AddToListAnimation = _Base.Class.define(function AddToListAnimation_ctor(addedArray, affectedArray, offsetArray) {
        // Constructor
        this.addedArray = addedArray;
        this.affectedArray = affectedArray;
        this.offsetArray = offsetArray;
    }, { // Public Members
        execute: function () {
            writeAnimationProfilerMark("addToListAnimation,StartTM");
            var delay = this.affectedArray.length > 0 ? 240 : 0;
            var promise1 = _TransitionAnimation.executeAnimation(
                this.addedArray,
                [{
                    keyframe: "TVJS-scale-up",
                    property: transformNames.cssName,
                    delay: delay,
                    duration: 120,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    from: "scale(0.85)",
                    to: "none"
                },
                {
                    keyframe: "TVJS-opacity-in",
                    property: "opacity",
                    delay: delay,
                    duration: 120,
                    timing: "linear",
                    from: 0,
                    to: 1
                }]
            );
            var promise2 = animTranslate2DTransform(
                this.affectedArray,
                this.offsetArray,
                {
                    property: transformNames.cssName,
                    delay: 0,
                    duration: 400,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    to: ""
                });
            return Promise.join([promise1, promise2])
                .then(function () { writeAnimationProfilerMark("addToListAnimation,StopTM"); });
        }
    }, { // Static Members
        supportedForProcessing: false,
    });

    var DeleteFromListAnimation = _Base.Class.define(function DeleteFromListAnimation_ctor(deletedArray, remainingArray, offsetArray) {
        // Constructor
        this.deletedArray = deletedArray;
        this.remainingArray = remainingArray;
        this.offsetArray = offsetArray;
    }, { // Public Members
        execute: function () {
            writeAnimationProfilerMark("deleteFromListAnimation,StartTM");
            var promise1 = _TransitionAnimation.executeAnimation(
                this.deletedArray,
                [{
                    keyframe: "TVJS-scale-down",
                    property: transformNames.cssName,
                    delay: 0,
                    duration: 120,
                    timing: "cubic-bezier(0.11, 0.5, 0.24, .96)",
                    from: "none",
                    to: "scale(0.85)"
                },
                {
                    keyframe: "TVJS-opacity-out",
                    property: "opacity",
                    delay: 0,
                    duration: 120,
                    timing: "linear",
                    from: 1,
                    to: 0
                }]);
            var promise2 = animTranslate2DTransform(
                this.remainingArray,
                this.offsetArray,
                {
                    property: transformNames.cssName,
                    delay: this.deletedArray.length > 0 ? 60 : 0,
                    duration: 400,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    to: ""
                });
            return Promise.join([promise1, promise2])
                .then(function () { writeAnimationProfilerMark("deleteFromListAnimation,StopTM"); });
        }
    }, { // Static Members
        supportedForProcessing: false,
    });

    var _UpdateListAnimation = _Base.Class.define(function _UpdateListAnimation_ctor(addedArray, affectedArray, offsetArray, deleted) {
        // Constructor
        this.addedArray = addedArray;
        this.affectedArray = affectedArray;
        this.offsetArray = offsetArray;
        var deletedArray = makeArray(deleted);
        this.deletedArray = deletedArray;
        this.deletedOffsetArray = collectOffsetArray(deletedArray);
    }, { // Public Members
        execute: function () {
            writeAnimationProfilerMark("_updateListAnimation,StartTM");
            makeOffsetsRelative(this.deletedArray, this.deletedOffsetArray);

            var delay = 0;
            var promise1 = _TransitionAnimation.executeAnimation(
                this.deletedArray,
                [{
                    keyframe: keyframeCallbackAnimate(this.deletedOffsetArray, "TVJS-scale-down"),
                    property: transformNames.cssName,
                    delay: 0,
                    duration: 120,
                    timing: "cubic-bezier(0.11, 0.5, 0.24, .96)",
                    from: translateCallbackAnimate(this.deletedOffsetArray),
                    to: translateCallbackAnimate(this.deletedOffsetArray, "scale(0.85)")
                },
                {
                    keyframe: "TVJS-opacity-out",
                    property: "opacity",
                    delay: 0,
                    duration: 120,
                    timing: "linear",
                    from: 1,
                    to: 0
                }]);

            if (this.deletedArray.length > 0) {
                delay += 60;
            }

            var promise2 = animTranslate2DTransform(
                this.affectedArray,
                this.offsetArray,
                {
                    property: transformNames.cssName,
                    delay: delay,
                    duration: 400,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    to: ""
                });

            if (this.affectedArray.length > 0) {
                delay += 240;
            } else if (delay) {
                delay += 60;
            }

            var promise3 = _TransitionAnimation.executeAnimation(
                this.addedArray,
                [{
                    keyframe: "TVJS-scale-up",
                    property: transformNames.cssName,
                    delay: delay,
                    duration: 120,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    from: "scale(0.85)",
                    to: "none"
                },
                {
                    keyframe: "TVJS-opacity-in",
                    property: "opacity",
                    delay: delay,
                    duration: 120,
                    timing: "linear",
                    from: 0,
                    to: 1
                }]
            );
            return Promise.join([promise1, promise2, promise3])
                .then(function () { writeAnimationProfilerMark("_updateListAnimation,StopTM"); });
        }
    }, { // Static Members
        supportedForProcessing: false,
    });


    var AddToSearchListAnimation = _Base.Class.define(function AddToSearchListAnimation_ctor(addedArray, affectedArray, offsetArray) {
        // Constructor
        this.addedArray = addedArray;
        this.affectedArray = affectedArray;
        this.offsetArray = offsetArray;
    }, { // Public Members
        execute: function () {
            writeAnimationProfilerMark("addToSearchListAnimation,StartTM");
            var promise1 = _TransitionAnimation.executeAnimation(
                this.addedArray,
                {
                    keyframe: "TVJS-opacity-in",
                    property: "opacity",
                    delay: this.affectedArray.length > 0 ? 240 : 0,
                    duration: 117,
                    timing: "linear",
                    from: 0,
                    to: 1
                });
            var promise2 = animTranslate2DTransform(
                this.affectedArray,
                this.offsetArray,
                {
                    property: transformNames.cssName,
                    delay: 0,
                    duration: 400,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    to: ""
                });
            return Promise.join([promise1, promise2])
                .then(function () { writeAnimationProfilerMark("addToSearchListAnimation,StopTM"); });
        }
    }, { // Static Members
        supportedForProcessing: false,
    });

    var DeleteFromSearchListAnimation = _Base.Class.define(function DeleteFromSearchListAnimation_ctor(deletedArray, remainingArray, offsetArray) {
        // Constructor
        this.deletedArray = deletedArray;
        this.remainingArray = remainingArray;
        this.offsetArray = offsetArray;
    }, { // Public Members
        execute: function () {
            writeAnimationProfilerMark("deleteFromSearchListAnimation,StartTM");
            var promise1 = _TransitionAnimation.executeAnimation(
                this.deletedArray,
                {
                    keyframe: "TVJS-opacity-out",
                    property: "opacity",
                    delay: 0,
                    duration: 93,
                    timing: "linear",
                    from: 1,
                    to: 0
                });
            var promise2 = animTranslate2DTransform(
                this.remainingArray,
                this.offsetArray,
                {
                    property: transformNames.cssName,
                    delay: this.deletedArray.length > 0 ? 60 : 0,
                    duration: 400,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    to: ""
                });
            return Promise.join([promise1, promise2])
                .then(function () { writeAnimationProfilerMark("deleteFromSearchListAnimation,StopTM"); });
        }
    }, { // Static Members
        supportedForProcessing: false,
    });

    var PeekAnimation = _Base.Class.define(function PeekAnimation_ctor(target, elementArray, offsetArray) {
        // Constructor
        this.elementArray = elementArray;
        this.offsetArray = offsetArray;
    }, { // Public Members
        execute: function () {
            writeAnimationProfilerMark("peekAnimation,StartTM");
            return animTranslate2DTransform(
                this.elementArray,
                this.offsetArray,
                {
                    property: transformNames.cssName,
                    delay: 0,
                    duration: 2000,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    to: ""
                })
                .then(function () { writeAnimationProfilerMark("peekAnimation,StopTM"); });
        }
    }, { // Static Members
        supportedForProcessing: false,
    });

    //
    // Resize animation
    //  The resize animation requires 2 animations to run simultaneously in sync with each other. It's implemented
    //  without PVL because PVL doesn't provide a way to guarantee that 2 animations will start at the same time.
    //
    function transformWithTransition(element, transition) {
        // transition's properties:
        // - duration: Number representing the duration of the animation in milliseconds.
        // - timing: String representing the CSS timing function that controls the progress of the animation.
        // - to: The value of *element*'s transform property after the animation.
        var duration = transition.duration * _TransitionAnimation._animationFactor;
        var transitionProperty = _BaseUtils._browserStyleEquivalents["transition"].scriptName;
        element.style[transitionProperty] = duration + "ms " + transformNames.cssName + " " + transition.timing;
        element.style[transformNames.scriptName] = transition.to;

        var finish;
        return new Promise(function (c) {
            var onTransitionEnd = function (eventObject) {
                if (eventObject.target === element && eventObject.propertyName === transformNames.cssName) {
                    finish();
                }
            };

            var didFinish = false;
            finish = function () {
                if (!didFinish) {
                    _Global.clearTimeout(timeoutId);
                    element.removeEventListener(_BaseUtils._browserEventEquivalents["transitionEnd"], onTransitionEnd);
                    element.style[transitionProperty] = "";
                    didFinish = true;
                }
                c();
            };

            // Watch dog timeout
            var timeoutId = _Global.setTimeout(function () {
                timeoutId = _Global.setTimeout(finish, duration);
            }, 50);

            element.addEventListener(_BaseUtils._browserEventEquivalents["transitionEnd"], onTransitionEnd);
        }, function () {
            finish(); // On cancelation, complete the promise successfully to match PVL
        });
    }

    function getResizeDefaultTransitions() {
        return {
            defaultResizeGrowTransition: {
                duration: 350,
                timing: "cubic-bezier(0.1, 0.9, 0.2, 1)"
            },

            defaultResizeShrinkTransition: {
                duration: 120,
                timing: "cubic-bezier(0.1, 0.9, 0.2, 1)"
            }
        };
    }

    // See _resizeTransition's comment for documentation on *args*.
    function resizeTransition(elementClipper, element, args) {
        var defaultTransition = getResizeDefaultTransitions()[(args.to > args.from ? "defaultResizeGrowTransition" : "defaultResizeShrinkTransition")];
        args = _BaseUtils._merge(args, {
            duration: args.duration === undefined ? defaultTransition.duration : args.duration,
            timing: args.timing === undefined ? defaultTransition.timing : args.timing
        });

        var start = args.actualSize - args.from;
        var end = args.actualSize - args.to;
        if (!args.anchorTrailingEdge) {
            start = -start;
            end = -end;
        }
        var translate = args.dimension === "width" ? "translateX" : "translateY";
        var transition = {
            duration: args.duration,
            timing: args.timing
        };

        // Set up
        elementClipper.style[transformNames.scriptName] = translate + "(" + start + "px)";
        element.style[transformNames.scriptName] = translate + "(" + -start + "px)";

        // Resolve styles
        _ElementUtilities._getComputedStyle(elementClipper).opacity;
        _ElementUtilities._getComputedStyle(element).opacity;

        // Merge the transitions, but don't animate yet
        var clipperTransition = _BaseUtils._merge(transition, { to: translate + "(" + end + "px)" });
        var elementTransition = _BaseUtils._merge(transition, { to: translate + "(" + -end + "px)" });

        // Return an array so that we can prepare any other animations before beginning everything (used by commanding surface open/close animations)
        return [
            { element: elementClipper, transition: clipperTransition },
            { element: element, transition: elementTransition }
        ];
    }

    _Base.Namespace._moduleDefine(exports, "TVJS.UI.Animation", {

        createExpandAnimation: function (revealed, affected) {
            /// <signature helpKeyword="TVJS.UI.Animation.createExpandAnimation">
            /// <summary locid="TVJS.UI.Animation.createExpandAnimation">
            /// Creates an expand animation.
            /// After creating the ExpandAnimation object,
            /// modify the document to move the elements to their new positions,
            /// then call the execute method on the ExpandAnimation object.
            /// </summary>
            /// <param name="revealed" locid="TVJS.UI.Animation.createExpandAnimation_p:revealed">
            /// Single element or collection of elements which were revealed.
            /// </param>
            /// <param name="affected" locid="TVJS.UI.Animation.createExpandAnimation_p:affected">
            /// Single element or collection of elements whose positions were
            /// affected by the expand.
            /// </param>
            /// <returns type="{ execute: Function }" locid="TVJS.UI.Animation.createExpandAnimation_returnValue">
            /// ExpandAnimation object whose execute method returns
            /// a Promise that completes when the animation is complete.
            /// </returns>
            /// </signature>
            return layoutTransition(ExpandAnimation, revealed, affected);
        },

        fadeIn: function (shown) {
            /// <signature helpKeyword="TVJS.UI.Animation.fadeIn">
            /// <summary locid="TVJS.UI.Animation.fadeIn">
            /// Execute a fade-in animation.
            /// </summary>
            /// <param name="shown" locid="TVJS.UI.Animation.fadeIn_p:element">
            /// Single element or collection of elements to fade in.
            /// At the end of the animation, the opacity of the elements is 1.
            /// </param>
            /// <returns type="TVJS.Promise" locid="TVJS.UI.Animation.fadeIn_returnValue">
            /// Promise object that completes when the animation is complete.
            /// </returns>
            /// </signature>
            writeAnimationProfilerMark("fadeIn,StartTM");

            return _TransitionAnimation.executeTransition(
                shown,
                {
                    property: "opacity",
                    delay: 0,
                    duration: 250,
                    timing: "linear",
                    from: 0,
                    to: 1
                })
                .then(function () { writeAnimationProfilerMark("fadeIn,StopTM"); });
        },

        fadeOut: function (hidden) {
            /// <signature helpKeyword="TVJS.UI.Animation.fadeOut">
            /// <summary locid="TVJS.UI.Animation.fadeOut">
            /// Execute a fade-out animation.
            /// </summary>
            /// <param name="hidden" locid="TVJS.UI.Animation.fadeOut_p:element">
            /// Single element or collection of elements to fade out.
            /// At the end of the animation, the opacity of the elements is 0.
            /// </param>
            /// <returns type="TVJS.Promise" locid="TVJS.UI.Animation.fadeOut_returnValue">
            /// Promise object that completes when the animation is complete.
            /// </returns>
            /// </signature>
            writeAnimationProfilerMark("fadeOut,StartTM");

            return _TransitionAnimation.executeTransition(
                hidden,
                {
                    property: "opacity",
                    delay: 0,
                    duration: 167,
                    timing: "linear",
                    to: 0
                })
                .then(function () { writeAnimationProfilerMark("fadeOut,StopTM"); });
        },

        createAddToListAnimation: function (added, affected) {
            /// <signature helpKeyword="TVJS.UI.Animation.createAddToListAnimation" >
            /// <summary locid="TVJS.UI.Animation.createAddToListAnimation">
            /// Creates an animation for adding to a list.
            /// After creating the AddToListAnimation object,
            /// modify the document to move the elements to their new positions,
            /// then call the execute method on the AddToListAnimation object.
            /// </summary>
            /// <param name="added" locid="TVJS.UI.Animation.createAddToListAnimation_p:added">
            /// Single element or collection of elements which were added.
            /// </param>
            /// <param name="affected" locid="TVJS.UI.Animation.createAddToListAnimation_p:affected">
            /// Single element or collection of elements whose positions were
            /// affected by the add.
            /// </param>
            /// <returns type="{ execute: Function }" locid="TVJS.UI.Animation.createAddToListAnimation_returnValue">
            /// AddToListAnimation object whose execute method returns
            /// a Promise that completes when the animation is complete.
            /// </returns>
            /// </signature>
            return layoutTransition(AddToListAnimation, added, affected);
        },

        createDeleteFromListAnimation: function (deleted, remaining) {
            /// <signature helpKeyword="TVJS.UI.Animation.createDeleteFromListAnimation">
            /// <summary locid="TVJS.UI.Animation.createDeleteFromListAnimation">
            /// Crestes an animation for deleting from a list.
            /// After creating the DeleteFromListAnimation object,
            /// modify the document to reflect the deletion,
            /// then call the execute method on the DeleteFromListAnimation object.
            /// </summary>
            /// <param name="deleted" locid="TVJS.UI.Animation.createDeleteFromListAnimation_p:deleted">
            /// Single element or collection of elements which will be deleted.
            /// When the animation completes, the application should hide the elements
            /// or remove them from the document.
            /// </param>
            /// <param name="remaining" locid="TVJS.UI.Animation.createDeleteFromListAnimation_p:remaining">
            /// Single element or collection of elements whose positions were
            /// affected by the deletion.
            /// </param>
            /// <returns type="{ execute: Function }" locid="TVJS.UI.Animation.createDeleteFromListAnimation_returnValue">
            /// DeleteFromListAnimation object whose execute method returns
            /// a Promise that completes when the animation is complete.
            /// </returns>
            /// </signature>
            return layoutTransition(DeleteFromListAnimation, deleted, remaining);
        },

        showPanel: function (element, offset) {
            /// <signature helpKeyword="TVJS.UI.Animation.showPanel">
            /// <summary locid="TVJS.UI.Animation.showPanel">
            /// Slides an element or elements into position at the edge of the screen.
            /// This animation is designed for a large object like a keyboard.
            /// </summary>
            /// <param name="element" locid="TVJS.UI.Animation.showPanel_p:element">
            /// Single element or collection of elements to be slid into position.
            /// The elements should be at their final positions
            /// at the time the function is called.
            /// </param>
            /// <param name="offset" locid="TVJS.UI.Animation.showPanel_p:offset">
            /// Optional offset object or collection of offset objects
            /// array describing the starting point of the animation.
            /// If the number of offset objects is less than the length of the
            /// element parameter, then the last value is repeated for all
            /// remaining elements.
            /// If this parameter is omitted, then a default value is used.
            /// </param>
            /// <returns type="TVJS.Promise" locid="TVJS.UI.Animation.showPanel_returnValue">
            /// promise object
            /// </returns>
            /// </signature>
            writeAnimationProfilerMark("showPanel,StartTM");

            var offsetArray = new OffsetArray(offset, "TVJS-showPanel", [{ top: "0px", left: "364px", rtlflip: true }]);
            return _TransitionAnimation.executeAnimation(
                element,
                {
                    keyframe: offsetArray.keyframe,
                    property: transformNames.cssName,
                    delay: 0,
                    duration: 550,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    from: offsetArray.keyframe || translateCallback(offsetArray),
                    to: "none"
                })
                .then(function () { writeAnimationProfilerMark("showPanel,StopTM"); });
        },

        hidePanel: function (element, offset) {
            /// <signature helpKeyword="TVJS.UI.Animation.hidePanel">
            /// <summary locid="TVJS.UI.Animation.hidePanel">
            /// Slides an element or elements at the edge of the screen out of view.
            /// This animation is designed for a large object like a keyboard.
            /// </summary>
            /// <param name="element" locid="TVJS.UI.Animation.hidePanel_p:element">
            /// Single element or collection of elements to be slid out.
            /// The elements should be at their onscreen positions
            /// at the time the function is called.
            /// </param>
            /// <param name="offset" locid="TVJS.UI.Animation.hidePanel_p:offset">
            /// Optional offset object or collection of offset objects
            /// array describing the ending point of the animation.
            /// If the number of offset objects is less than the length of the
            /// element parameter, then the last value is repeated for all
            /// remaining elements.
            /// If this parameter is omitted, then a default value is used.
            /// </param>
            /// <returns type="TVJS.Promise" locid="TVJS.UI.Animation.hidePanel_returnValue">
            /// Promise object that completes when the animation is complete.
            /// </returns>
            /// </signature>
            writeAnimationProfilerMark("hidePanel,StartTM");

            var offsetArray = new OffsetArray(offset, "TVJS-hidePanel", [{ top: "0px", left: "364px", rtlflip: true }]);
            return _TransitionAnimation.executeAnimation(
                element,
                {
                    keyframe: offsetArray.keyframe,
                    property: transformNames.cssName,
                    delay: 0,
                    duration: 550,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    from: "none",
                    to: offsetArray.keyframe || translateCallback(offsetArray)
                })
                .then(function () { writeAnimationProfilerMark("hidePanel,StopTM"); });
        },

        showPopup: function (element, offset) {
            /// <signature helpKeyword="TVJS.UI.Animation.showPopup">
            /// <summary locid="TVJS.UI.Animation.showPopup">
            /// Displays an element or elements in the style of a popup.
            /// </summary>
            /// <param name="element" locid="TVJS.UI.Animation.showPopup_p:element">
            /// Single element or collection of elements to be shown like a popup.
            /// </param>
            /// <param name="offset" locid="TVJS.UI.Animation.showPopup_p:offset">
            /// Optional offset object or collection of offset objects
            /// array describing the starting point of the animation.
            /// If the number of offset objects is less than the length of the
            /// element parameter, then the last value is repeated for all
            /// remaining elements.
            /// If this parameter is omitted, then a default value is used.
            /// </param>
            /// <returns type="TVJS.Promise" locid="TVJS.UI.Animation.showPopup_returnValue">
            /// Promise object that completes when the animation is complete.
            /// </returns>
            /// </signature>
            writeAnimationProfilerMark("showPopup,StartTM");

            var offsetArray = new OffsetArray(offset, "TVJS-showPopup", [{ top: "50px", left: "0px" }]);
            return _TransitionAnimation.executeAnimation(
                element,
                [{
                    keyframe: "TVJS-opacity-in",
                    property: "opacity",
                    delay: 83,
                    duration: 83,
                    timing: "linear",
                    from: 0,
                    to: 1
                },
                {
                    keyframe: offsetArray.keyframe,
                    property: transformNames.cssName,
                    delay: 0,
                    duration: 367,
                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                    from: offsetArray.keyframe || translateCallback(offsetArray),
                    to: "none"
                }])
                .then(function () { writeAnimationProfilerMark("showPopup,StopTM"); });
        },

        hidePopup: function (element) {
            /// <signature helpKeyword="TVJS.UI.Animation.hidePopup" >
            /// <summary locid="TVJS.UI.Animation.hidePopup">
            /// Removes a popup from the screen.
            /// </summary>
            /// <param name="element" locid="TVJS.UI.Animation.hidePopup_p:element">
            /// Single element or collection of elements to be hidden like a popup.
            /// When the animation completes, the application should hide the elements
            /// or remove them from the document.
            /// </param>
            /// <returns type="TVJS.Promise" locid="TVJS.UI.Animation.hidePopup_returnValue">
            /// Promise object that completes when the animation is complete.
            /// </returns>
            /// </signature>
            writeAnimationProfilerMark("hidePopup,StartTM");

            return _TransitionAnimation.executeAnimation(
                element,
                {
                    keyframe: "TVJS-opacity-out",
                    property: "opacity",
                    delay: 0,
                    duration: 83,
                    timing: "linear",
                    from: 1,
                    to: 0
                })
                .then(function () { writeAnimationProfilerMark("hidePopup,StopTM"); });
        },

        _mediaPlayerShowControlsAnimation: function Utilities__mediaPlayerShowControlsAnimation(args) {

        var skipAnimations = args.skipAnimations,
            compact = args.compact,
            progressContainer = args.progressContainer,
            mediacontrols = args.mediacontrols,
            visibleTransportBarButtons = args.visibleTransportBarButtons;
            
        if (skipAnimations) {
            return Promise.wrap();
        }

            // Left buttons
        var leftButtons = [];
        var leftButtonOffsets = [];

            // Right buttons
        var rightButtons = [];
        var rightButtonOffsets = [];

        var numberOfTransportBarButtons = visibleTransportBarButtons.length;
        var oddNumberOfButtons = numberOfTransportBarButtons % 2 !== 0;

        if (compact) {
            // Fill in the left side
            for (var i = numberOfTransportBarButtons - 1; i >= 0; i--) {
                if (visibleTransportBarButtons[i].leftOfTimelineInSingleRowLayout) {
                    leftButtons.push(visibleTransportBarButtons[i]);
                }
            }

            // Now fill in the offset array
            var leftOffset = -64;
            for (var i = leftButtons.length; i > 0; i--) {
                leftButtonOffsets.push({ left: leftOffset + "px", top: "100px" });
                leftOffset -= (64 * (i + 1));
            }

            // Fill in the right side
            for (var i = 0, len = numberOfTransportBarButtons; i < len; i++) {
                if (!visibleTransportBarButtons[i].leftOfTimelineInSingleRowLayout) {
                    rightButtons.push(visibleTransportBarButtons[i]);
                }
            }

            // Fill in the offset array
            var rightOffset = 64;
            for (var i = rightButtons.length; i > 0; i--) {
                rightButtonOffsets.push({ left: rightOffset + "px", top: "100px" });
                rightOffset += (64 * (i + 1));
            }
        } else {
            for (var i = Math.floor(numberOfTransportBarButtons / 2) - 1; i >= 0; i--) {
                leftButtons.push(visibleTransportBarButtons[i]);
            }
            // Now fill in the offset array
            var leftOffset = -64;
            for (var i = 0, len = leftButtons.length; i < len; i++) {
                leftButtonOffsets.push({ left: leftOffset + "px", top: "100px" });
                leftOffset -= (64 * (i + 1));
            }

            for (var i = Math.ceil(numberOfTransportBarButtons / 2), len = numberOfTransportBarButtons; i < len; i++) {
                rightButtons.push(visibleTransportBarButtons[i]);
            }
            // Fill in the offset array
            var rightOffset = 64;
            for (var i = 0, len = rightButtons.length; i < len; i++) {
                rightButtonOffsets.push({ left: rightOffset + "px", top: "100px" });
                rightOffset += 64 * (i + 1);
            }
            rightButtonOffsets.push({ left: 0 + "px", top: "100px" });
        }

        var animationPromises = [];
        var leftElementsOffsetArray = new OffsetArray(leftButtonOffsets, null, [{ top: "100px", left: "-12px", rtlflip: true }]);
        var rightElementsOffsetArray = new OffsetArray(rightButtonOffsets, null, [{ top: "100px", left: "12px", rtlflip: true }]);
            // Do an animation on them
        animationPromises.push(_TransitionAnimation.executeTransition(leftButtons, [{
            property: _BaseUtils._browserStyleEquivalents["transform"].cssName,
            delay: 0,
            duration: 500,
            timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
            from: translateCallback(leftElementsOffsetArray),
            to: "none"
        }]));

        if (oddNumberOfButtons &&
            compact) {
            var middleButton = visibleTransportBarButtons[leftButtons.length];
            animationPromises.push(_TransitionAnimation.executeTransition(middleButton, [{
                property: _BaseUtils._browserStyleEquivalents["transform"].cssName,
                delay: 0,
                duration: 500,
                timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
                from: "translateY(100px)",
                to: "none"
            }]));
        }

        animationPromises.push(_TransitionAnimation.executeTransition(rightButtons, [{
            property: _BaseUtils._browserStyleEquivalents["transform"].cssName,
            delay: 0,
            duration: 500,
            timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
            from: translateCallback(rightElementsOffsetArray),
            to: "none"
        }]));

            // Animate the timeline
        animationPromises.push(_TransitionAnimation.executeAnimation(progressContainer, [{
            property: _BaseUtils._browserStyleEquivalents["transform"].cssName,
            delay: 0,
            duration: 500,
            timing: "cubic-bezier(0.16, 1, 0.29, 0.99)",
            from: "translateY(100px)",
            to: "none"
        }]));

        animationPromises.push(_TransitionAnimation.executeTransition(mediacontrols, [{
            property: "opacity",
            delay: 0,
            duration: 100,
            timing: "linear",
            from: 0,
            to: 1
        }]));

        return Promise.join(animationPromises);
        }
    });
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Res',[
    'exports',
    './Core/_Global',
    './Core/_Base',
    './Core/_BaseUtils',
    './Core/_ErrorFromName',
    './Core/_Resources',
    './Promise'
    ], function resInit(exports, _Global, _Base, _BaseUtils, _ErrorFromName, _Resources, Promise) {
    "use strict";

    var readyComplete = false;

    var requireSupportedForProcessing = _BaseUtils.requireSupportedForProcessing;

    function processAllImpl(rootElement, count) {
        rootElement = rootElement || _Global.document.body;

        var count = count || 0;

        if (count < 4) {
            // Only 3 depth is supported in the innerHTML
            if (count === 0) {
                if (rootElement.getAttribute) {
                    // Fragment-loaded root element isn't caught by querySelectorAll
                    var rootElementNode = rootElement.getAttribute('data-tv-res');
                    if (rootElementNode) {
                        var decls = _OptionsParser.optionsParser(rootElementNode);
                        setMembers(rootElement, rootElement, decls, count);
                    }
                }
            }

            var selector = "[data-tv-res],[data-tv-control]";
            var elements = rootElement.querySelectorAll(selector);
            if (elements.length === 0) {
                return Promise.as(rootElement);
            }

            for (var i = 0, len = elements.length; i < len; i++) {
                var e = elements[i];

                if (e.winControl && e.winControl.constructor && e.winControl.constructor.isDeclarativeControlContainer) {
                    var idcc = e.winControl.constructor.isDeclarativeControlContainer;
                    if (typeof idcc === "function") {
                        idcc = requireSupportedForProcessing(idcc);
                        idcc(e.winControl, processAll);

                        // Skip all children of declarative control container
                        i += e.querySelectorAll(selector).length;
                    }
                }

                if (!e.hasAttribute("data-tv-res")) {
                    continue;
                }
                // Use optionsParser that accept string format
                // {name="value", name2="value2"}
                var decls = _OptionsParser.optionsParser(e.getAttribute('data-tv-res'));
                setMembers(e, e, decls, count);
            }

        } else if (_BaseUtils.validation) {
            throw new _ErrorFromName("TVJS.Res.NestingExceeded", "NestingExceeded");
        }

        return Promise.as(rootElement);
    }

    function setAttributes(root, descriptor) {
        var names = Object.keys(descriptor);

        for (var k = 0, l = names.length ; k < l; k++) {
            var name = names[k];
            var value = descriptor[name];

            var data = _Resources.getString(value);

            if (!data || !data.empty) {
                root.setAttribute(name, data.value);

                if ((data.lang !== undefined) &&
                    (root.lang !== undefined) &&
                    (root.lang !== data.lang)) {

                        root.lang = data.lang;
                    }
            } else if (_BaseUtils.validation) {
                notFound(value);
            }
        }
    }

    function notFound(name) {
        throw new _ErrorFromName("TVJS.Res.NotFound", _Resources._formatString("NotFound: {0}", name));
    }

    function setMembers(root, target, descriptor, count) {
        var names = Object.keys(descriptor);
        target = requireSupportedForProcessing(target);

        for (var k = 0, l = names.length ; k < l; k++) {
            var name = names[k];
            var value = descriptor[name];

            if (typeof value === "string") {
                var data = _Resources.getString(value);

                if (!data || !data.empty) {
                    target[name] = data.value;

                    if ((data.lang !== undefined) &&
                        (root.lang !== undefined) &&
                        (root.lang !== data.lang)) {
                        // When lang property is different, we set the language with selected string's language
                            root.lang = data.lang;
                        }

                    if (name === "innerHTML") {
                        processAllImpl(target, count + 1);
                    }
                } else if (_BaseUtils.validation) {
                    notFound(value);
                }
            } else if (root === target && name === "attributes") {
                //Exposing setAttribute for attributes that don't have HTML properties, like aria, through a fake 'attributes' property
                setAttributes(root, value);
            } else {
                setMembers(root, target[name], value, count);
            }
        }
    }

    function processAll(rootElement) {
            /// <signature helpKeyword="TVJS.Resources.processAll">
            /// <summary locid="TVJS.Resources.processAll">
            /// Processes resources tag and replaces strings
            /// with localized strings.
            /// </summary>
            /// <param name="rootElement" locid="TVJS.Resources.processAll_p:rootElement">
            /// The DOM element at which to start processing. processAll processes the element and its child elements.
            /// If you don't specify root element, processAll processes the entire document.
            /// </param>
            /// </signature>

            if (!readyComplete) {
                return _BaseUtils.ready().then(function () {
                    readyComplete = true;
                    return processAllImpl(rootElement);
                });
            } else {
                try {
                    return processAllImpl(rootElement);
                }
                catch (e) {
                    return Promise.wrapError(e);
                }
            }
        }

    _Base.Namespace._moduleDefine(exports, "TVJS.Resources", {
        processAll: processAll
    });
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('base',[
    'TVJS/Core/_TVJS',
    'TVJS/Core',
    'TVJS/Promise',
    'TVJS/_Signal',
    'TVJS/Utilities',
    'TVJS/Application',
    'TVJS/Animations',
    'TVJS/Res',
    'TVJS/ControlProcessor',
    ], function (_TVJS) {
    "use strict";

    _TVJS.Namespace.define("TVJS.Utilities", {
        _require: require,
        _define: define
    });

    return _TVJS;
});

        require(['TVJS/Core/_TVJS', 'base'], function (_TVJS) {
            // TVJS always publishes itself to global
            if (window.TVJS) {
                if (!_TVJS.DirectionalNavigation && window.TVJS.DirectionalNavigation) {
                    _TVJS.DirectionalNavigation = window.TVJS.DirectionalNavigation;
                }
                if (!_TVJS.SearchBox && window.TVJS.SearchBox) {
                    _TVJS.SearchBox = window.TVJS.SearchBox;
                }
                if (!_TVJS.ScrollViewer && window.TVJS.ScrollViewer) {
                    _TVJS.ScrollViewer = window.TVJS.ScrollViewer;
                }
            }
            globalObject.TVJS = _TVJS;
            if (typeof module !== 'undefined') {
                // This is a CommonJS context so publish to exports
                module.exports = _TVJS;
            }
        });
        return globalObject.TVJS;
    }));
}());

/* ui.js */

/*! Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information. */
(function () {

    var globalObject = 
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    (function (factory) {
        if (typeof define === 'function' && define.amd) {
            // amd
            define(["./base"], factory);
        } else {
            if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
                // CommonJS
                factory(require("./base"));
            } else {
                // No module system
                factory(globalObject.TVJS);
            }
        }
    }(function (TVJS) {


var require = TVJS.Utilities._require;
var define = TVJS.Utilities._define;

define('TVJS/_Accents',["require", "exports", "./Core/_Global", "./Core/_WinRT", "./Core/_Base", "./Core/_BaseUtils", './Utilities/_ElementUtilities'], function (require, exports, _Global, _WinRT, _Base, _BaseUtils, _ElementUtilities) {
    var Constants = {
        accentStyleId: "TVJSAccentsStyle",
        themeDetectionTag: "TVJS-themedetection-tag",
        hoverSelector: "html.tv-hoverable",
        lightThemeSelector: ".tv-ui-light",
        darkThemeSelector: ".tv-ui-dark"
    };
    var CSSSelectorTokens = [".", "#", ":"];
    var UISettings = null;
    var colors = [];
    var isDarkTheme = false;
    var rules = [];
    var writeRulesTOHandle = -1;
    // Public APIs
    //
    // Enum values align with the colors array indices
    (function (ColorTypes) {
        ColorTypes[ColorTypes["accent"] = 0] = "accent";
        ColorTypes[ColorTypes["listSelectRest"] = 1] = "listSelectRest";
        ColorTypes[ColorTypes["listSelectHover"] = 2] = "listSelectHover";
        ColorTypes[ColorTypes["listSelectPress"] = 3] = "listSelectPress";
        ColorTypes[ColorTypes["_listSelectRestInverse"] = 4] = "_listSelectRestInverse";
        ColorTypes[ColorTypes["_listSelectHoverInverse"] = 5] = "_listSelectHoverInverse";
        ColorTypes[ColorTypes["_listSelectPressInverse"] = 6] = "_listSelectPressInverse";
    })(exports.ColorTypes || (exports.ColorTypes = {}));
    var ColorTypes = exports.ColorTypes;
    function createAccentRule(selector, props) {
        rules.push({ selector: selector, props: props });
        scheduleWriteRules();
    }
    exports.createAccentRule = createAccentRule;
    // Private helpers
    //
    function scheduleWriteRules() {
        if (rules.length === 0 || writeRulesTOHandle !== -1) {
            return;
        }
        writeRulesTOHandle = _BaseUtils._setImmediate(function () {
            writeRulesTOHandle = -1;
            cleanup();
            var inverseThemeSelector = isDarkTheme ? Constants.lightThemeSelector : Constants.darkThemeSelector;
            var inverseThemeHoverSelector = Constants.hoverSelector + " " + inverseThemeSelector;
            var style = _Global.document.createElement("style");
            style.id = Constants.accentStyleId;
            style.textContent = rules.map(function (rule) {
                // example rule: { selector: "  .foo,   html.tv-hoverable   .bar:hover ,  div:hover  ", props: [{ name: "color", value: 0 }, { name: "background-color", value: 1 } }
                var body = "  " + rule.props.map(function (prop) { return prop.name + ": " + colors[prop.value] + ";"; }).join("\n  ");
                // body = color: *accent*; background-color: *listSelectHover*
                var selectorSplit = rule.selector.split(",").map(function (str) { return sanitizeSpaces(str); }); // [".foo", ".bar:hover", "div"]
                var selector = selectorSplit.join(",\n"); // ".foo, html.tv-hoverable .bar:hover, div:hover"
                var css = selector + " {\n" + body + "\n}";
                // css = .foo, html.tv-hoverable .bar:hover, div:hover { *body* }
                // Inverse Theme Selectors
                var isThemedColor = rule.props.some(function (prop) { return prop.value !== 0 /* accent */; });
                if (isThemedColor) {
                    var inverseBody = "  " + rule.props.map(function (prop) { return prop.name + ": " + colors[(prop.value ? (prop.value + 3) : prop.value)] + ";"; }).join("\n  ");
                    // inverseBody = "color: *accent*; background-color: *listSelectHoverInverse"
                    var themedSelectors = [];
                    selectorSplit.forEach(function (sel) {
                        if (sel.indexOf(Constants.hoverSelector) !== -1 && sel.indexOf(inverseThemeHoverSelector) === -1) {
                            themedSelectors.push(sel.replace(Constants.hoverSelector, inverseThemeHoverSelector));
                            var selWithoutHover = sel.replace(Constants.hoverSelector, "").trim();
                            if (CSSSelectorTokens.indexOf(selWithoutHover[0]) !== -1) {
                                themedSelectors.push(sel.replace(Constants.hoverSelector + " ", inverseThemeHoverSelector));
                            }
                        }
                        else {
                            themedSelectors.push(inverseThemeSelector + " " + sel);
                            if (CSSSelectorTokens.indexOf(sel[0]) !== -1) {
                                themedSelectors.push(inverseThemeSelector + sel);
                            }
                        }
                        css += "\n" + themedSelectors.join(",\n") + " {\n" + inverseBody + "\n}";
                    });
                }
                return css;
            }).join("\n");
            _Global.document.head.appendChild(style);
        });
    }
    function handleColorsChanged() {
        var UIColorType = _WinRT.Windows.UI.ViewManagement.UIColorType;
        var uiColor = UISettings.getColorValue(_WinRT.Windows.UI.ViewManagement.UIColorType.accent);
        var accent = colorToString(uiColor, 1);
        if (colors[0] === accent) {
            return;
        }
        // Establish colors
        // The order of the colors align with the ColorTypes enum values
        colors.length = 0;
        colors.push(accent, colorToString(uiColor, (isDarkTheme ? 0.6 : 0.4)), colorToString(uiColor, (isDarkTheme ? 0.8 : 0.6)), colorToString(uiColor, (isDarkTheme ? 0.9 : 0.7)), colorToString(uiColor, (isDarkTheme ? 0.4 : 0.6)), colorToString(uiColor, (isDarkTheme ? 0.6 : 0.8)), colorToString(uiColor, (isDarkTheme ? 0.7 : 0.9)));
        scheduleWriteRules();
    }
    function colorToString(color, alpha) {
        return "rgba(" + color.r + "," + color.g + "," + color.b + "," + alpha + ")";
    }
    function sanitizeSpaces(str) {
        return str.replace(/  /g, " ").replace(/  /g, " ").trim();
    }
    function cleanup() {
        var style = _Global.document.head.querySelector("#" + Constants.accentStyleId);
        style && style.parentNode.removeChild(style);
    }
    function _reset() {
        rules.length = 0;
        cleanup();
    }
    // Module initialization
    //
    // Figure out color theme
    var tag = _Global.document.createElement(Constants.themeDetectionTag);
    _Global.document.head.appendChild(tag);
    var cs = _ElementUtilities._getComputedStyle(tag);
    isDarkTheme = cs.opacity === "0";
    tag.parentElement.removeChild(tag);
    try {
        UISettings = new _WinRT.Windows.UI.ViewManagement.UISettings();
        UISettings.addEventListener("colorvalueschanged", handleColorsChanged);
        handleColorsChanged();
    }
    catch (e) {
        // No WinRT - use hardcoded blue accent color
        // The order of the colors align with the ColorTypes enum values
        colors.push("rgb(0, 120, 215)", "rgba(0, 120, 215, " + (isDarkTheme ? "0.6" : "0.4") + ")", "rgba(0, 120, 215, " + (isDarkTheme ? "0.8" : "0.6") + ")", "rgba(0, 120, 215, " + (isDarkTheme ? "0.9" : "0.7") + ")", "rgba(0, 120, 215, " + (isDarkTheme ? "0.4" : "0.6") + ")", "rgba(0, 120, 215, " + (isDarkTheme ? "0.6" : "0.8") + ")", "rgba(0, 120, 215, " + (isDarkTheme ? "0.7" : "0.9") + ")");
    }
    // Publish to TVJS namespace
    var toPublish = {
        ColorTypes: ColorTypes,
        createAccentRule: createAccentRule,
        // Exposed for tests    
        _colors: colors,
        _reset: _reset,
        _isDarkTheme: isDarkTheme
    };
    _Base.Namespace.define("TVJS.UI._Accents", toPublish);
});

define('require-style',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});

define('require-style!less/styles-intrinsic',[],function(){});

define('require-style!less/colors-intrinsic',[],function(){});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('TVJS/Controls/IntrinsicControls',[
    '../Utilities/_Hoverable',
    '../_Accents',
    'require-style!less/styles-intrinsic',
    'require-style!less/colors-intrinsic'
], function (_Hoverable, _Accents) {
    "use strict";

    // Shared color rule 
    _Accents.createAccentRule(
        ".tv-link,\
         .tv-progress-bar,\
         .tv-progress-ring,\
         .tv-ring",
        [{ name: "color", value: _Accents.ColorTypes.accent }]);

    // Shared background-color rule
    _Accents.createAccentRule(
        "::selection,\
         .tv-button.tv-button-primary,\
         .tv-dropdown option:checked,\
         select[multiple].tv-dropdown option:checked",
        [{ name: "background-color", value: _Accents.ColorTypes.accent }]);

    // Shared border-color rule
    _Accents.createAccentRule(
        ".tv-textbox:focus,\
         .tv-textarea:focus,\
         .tv-textbox:focus:hover,\
         .tv-textarea:focus:hover",
        [{ name: "border-color", value: _Accents.ColorTypes.accent }]);

    // Edge-specific color rule
    _Accents.createAccentRule(
        ".tv-textbox::-ms-clear:hover:not(:active),\
         .tv-textbox::-ms-reveal:hover:not(:active)",
        [{ name: "color", value: _Accents.ColorTypes.accent }]);

    // Edge-specific background-color rule
    _Accents.createAccentRule(
        ".tv-checkbox:checked::-ms-check,\
         .tv-textbox::-ms-clear:active,\
         .tv-textbox::-ms-reveal:active",
        [{ name: "background-color", value: _Accents.ColorTypes.accent }]);

    // Webkit-specific background-color rule
    _Accents.createAccentRule(
        ".tv-progress-bar::-webkit-progress-value,\
         .tv-progress-ring::-webkit-progress-value,\
         .tv-ring::-webkit-progress-value",
        [{ name: "background-color", value: _Accents.ColorTypes.accent }]);

    // Mozilla-specific background-color rule
    _Accents.createAccentRule(
        ".tv-progress-bar:not(:indeterminate)::-moz-progress-bar,\
         .tv-progress-ring:not(:indeterminate)::-moz-progress-bar,\
         .tv-ring:not(:indeterminate)::-moz-progress-bar",
        [{ name: "background-color", value: _Accents.ColorTypes.accent }]);

    // Edge-specific border-color rule
    _Accents.createAccentRule(
        ".tv-checkbox:indeterminate::-ms-check,\
         .tv-checkbox:hover:indeterminate::-ms-check,\
         .tv-radio:checked::-ms-check",
        [{ name: "border-color", value: _Accents.ColorTypes.accent }]);


    // Note the use of background instead of background-color
    // FF slider styling doesn't work with background-color
    // so using background for everything here for consistency

    // Edge-specific background rule
    _Accents.createAccentRule(
        ".tv-slider::-ms-thumb,\
         .tv-slider::-ms-fill-lower", /* Fill-Lower only supported in IE */
        [{ name: "background", value: _Accents.ColorTypes.accent }]);

    // Webkit-specific background rule
    _Accents.createAccentRule(
        ".tv-slider::-webkit-slider-thumb",
        [{ name: "background", value: _Accents.ColorTypes.accent }]);

    // Mozilla-specific background rule
    _Accents.createAccentRule(
        ".tv-slider::-moz-range-thumb",
        [{ name: "background", value: _Accents.ColorTypes.accent }]);
});

define('require-style!less/styles-lightdismissservice',[],function(){});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
define('TVJS/_LightDismissService',["require", "exports", './Application', './Core/_Base', './Core/_BaseUtils', './Utilities/_ElementUtilities', './Core/_Global', './Utilities/_KeyboardBehavior', './Core/_Log', './Core/_Resources'], function (require, exports, Application, _Base, _BaseUtils, _ElementUtilities, _Global, _KeyboardBehavior, _Log, _Resources) {
    require(["require-style!less/styles-lightdismissservice"]);
    "use strict";
    var baseZIndex = 1000;
    var Strings = {
        get closeOverlay() {
            return _Resources._getTVJSString("ui/closeOverlay").value;
        }
    };
    exports._ClassNames = {
        _clickEater: "tv-clickeater"
    };
    var EventNames = {
        requestingFocusOnKeyboardInput: "requestingfocusonkeyboardinput"
    };
    exports.LightDismissalReasons = {
        tap: "tap",
        lostFocus: "lostFocus",
        escape: "escape",
        hardwareBackButton: "hardwareBackButton",
        windowResize: "windowResize",
        windowBlur: "windowBlur"
    };
    // Built-in implementations of ILightDismissable's onShouldLightDismiss.
    exports.DismissalPolicies = {
        light: function LightDismissalPolicies_light_onShouldLightDismiss(info) {
            switch (info.reason) {
                case exports.LightDismissalReasons.tap:
                case exports.LightDismissalReasons.escape:
                    if (info.active) {
                        return true;
                    }
                    else {
                        info.stopPropagation();
                        return false;
                    }
                    break;
                case exports.LightDismissalReasons.hardwareBackButton:
                    if (info.active) {
                        info.preventDefault(); // prevent backwards navigation in the app
                        return true;
                    }
                    else {
                        info.stopPropagation();
                        return false;
                    }
                    break;
                case exports.LightDismissalReasons.lostFocus:
                case exports.LightDismissalReasons.windowResize:
                case exports.LightDismissalReasons.windowBlur:
                    return true;
            }
        },
        modal: function LightDismissalPolicies_modal_onShouldLightDismiss(info) {
            // Light dismiss cues should not be seen by dismissables behind the modal
            info.stopPropagation();
            switch (info.reason) {
                case exports.LightDismissalReasons.tap:
                case exports.LightDismissalReasons.lostFocus:
                case exports.LightDismissalReasons.windowResize:
                case exports.LightDismissalReasons.windowBlur:
                    return false;
                    break;
                case exports.LightDismissalReasons.escape:
                    return info.active;
                    break;
                case exports.LightDismissalReasons.hardwareBackButton:
                    info.preventDefault(); // prevent backwards navigation in the app
                    return info.active;
                    break;
            }
        },
        sticky: function LightDismissalPolicies_sticky_onShouldLightDismiss(info) {
            info.stopPropagation();
            return false;
        }
    };
    var KeyboardInfoType = {
        keyDown: "keyDown",
        keyUp: "keyUp",
        keyPress: "keyPress"
    };
    var AbstractDismissableElement = (function () {
        function AbstractDismissableElement(args) {
            this.element = args.element;
            this.element.tabIndex = args.tabIndex;
            this.onLightDismiss = args.onLightDismiss;
            // Allow the caller to override the default implementations of our ILightDismissable methods.
            if (args.onTakeFocus) {
                this.onTakeFocus = args.onTakeFocus;
            }
            if (args.onShouldLightDismiss) {
                this.onShouldLightDismiss = args.onShouldLightDismiss;
            }
            this._ldeOnKeyDownBound = this._ldeOnKeyDown.bind(this);
            this._ldeOnKeyUpBound = this._ldeOnKeyUp.bind(this);
            this._ldeOnKeyPressBound = this._ldeOnKeyPress.bind(this);
        }
        AbstractDismissableElement.prototype.restoreFocus = function () {
            var activeElement = _Global.document.activeElement;
            if (activeElement && this.containsElement(activeElement)) {
                this._ldeCurrentFocus = activeElement;
                return true;
            }
            else {
                // If the last input type was keyboard, use focus() so a keyboard focus visual is drawn.
                // Otherwise, use setActive() so no focus visual is drawn.
                var useSetActive = !_KeyboardBehavior._keyboardSeenLast;
                return this._ldeCurrentFocus && this.containsElement(this._ldeCurrentFocus) && _ElementUtilities._tryFocusOnAnyElement(this._ldeCurrentFocus, useSetActive);
            }
        };
        AbstractDismissableElement.prototype._ldeOnKeyDown = function (eventObject) {
            this._ldeService.keyDown(this, eventObject);
        };
        AbstractDismissableElement.prototype._ldeOnKeyUp = function (eventObject) {
            this._ldeService.keyUp(this, eventObject);
        };
        AbstractDismissableElement.prototype._ldeOnKeyPress = function (eventObject) {
            this._ldeService.keyPress(this, eventObject);
        };
        // ILightDismissable
        //
        AbstractDismissableElement.prototype.setZIndex = function (zIndex) {
            this.element.style.zIndex = zIndex;
        };
        AbstractDismissableElement.prototype.getZIndexCount = function () {
            return 1;
        };
        AbstractDismissableElement.prototype.containsElement = function (element) {
            return this.element.contains(element);
        };
        AbstractDismissableElement.prototype.onTakeFocus = function (useSetActive) {
            this.restoreFocus() || _ElementUtilities._focusFirstFocusableElement(this.element, useSetActive) || _ElementUtilities._tryFocusOnAnyElement(this.element, useSetActive);
        };
        AbstractDismissableElement.prototype.onFocus = function (element) {
            this._ldeCurrentFocus = element;
        };
        AbstractDismissableElement.prototype.onShow = function (service) {
            this._ldeService = service;
            this.element.addEventListener("keydown", this._ldeOnKeyDownBound);
            this.element.addEventListener("keyup", this._ldeOnKeyUpBound);
            this.element.addEventListener("keypress", this._ldeOnKeyPressBound);
        };
        AbstractDismissableElement.prototype.onHide = function () {
            this._ldeCurrentFocus = null;
            this._ldeService = null;
            this.element.removeEventListener("keydown", this._ldeOnKeyDownBound);
            this.element.removeEventListener("keyup", this._ldeOnKeyUpBound);
            this.element.removeEventListener("keypress", this._ldeOnKeyPressBound);
        };
        // Concrete subclasses are expected to implement these.
        AbstractDismissableElement.prototype.onKeyInStack = function (info) {
        };
        AbstractDismissableElement.prototype.onShouldLightDismiss = function (info) {
            return false;
        };
        // Consumers of concrete subclasses of AbstractDismissableElement are expected to
        // provide these as parameters to the constructor.
        AbstractDismissableElement.prototype.onLightDismiss = function (info) {
        };
        return AbstractDismissableElement;
    })();
    var LightDismissableElement = (function (_super) {
        __extends(LightDismissableElement, _super);
        function LightDismissableElement() {
            _super.apply(this, arguments);
        }
        LightDismissableElement.prototype.onKeyInStack = function (info) {
        };
        LightDismissableElement.prototype.onShouldLightDismiss = function (info) {
            return exports.DismissalPolicies.light(info);
        };
        return LightDismissableElement;
    })(AbstractDismissableElement);
    exports.LightDismissableElement = LightDismissableElement;
    var ModalElement = (function (_super) {
        __extends(ModalElement, _super);
        function ModalElement() {
            _super.apply(this, arguments);
        }
        ModalElement.prototype.onKeyInStack = function (info) {
            // stopPropagation so that none of the app's other event handlers will see the event.
            // Don't preventDefault so that the browser's hotkeys will still work.
            info.stopPropagation();
        };
        ModalElement.prototype.onShouldLightDismiss = function (info) {
            return exports.DismissalPolicies.modal(info);
        };
        return ModalElement;
    })(AbstractDismissableElement);
    exports.ModalElement = ModalElement;
    // An implementation of ILightDismissable that represents the HTML body element. It can never be dismissed. The
    // service should instantiate one of these to act as the bottommost light dismissable at all times (it isn't expected
    // for anybody else to instantiate one). It takes care of restoring focus when the last dismissable is dismissed.
    var LightDismissableBody = (function () {
        function LightDismissableBody() {
        }
        LightDismissableBody.prototype.setZIndex = function (zIndex) {
        };
        LightDismissableBody.prototype.getZIndexCount = function () {
            return 1;
        };
        LightDismissableBody.prototype.containsElement = function (element) {
            return _Global.document.body.contains(element);
        };
        LightDismissableBody.prototype.onTakeFocus = function (useSetActive) {
            this.currentFocus && this.containsElement(this.currentFocus) && _ElementUtilities._tryFocusOnAnyElement(this.currentFocus, useSetActive);
        };
        LightDismissableBody.prototype.onFocus = function (element) {
            this.currentFocus = element;
        };
        LightDismissableBody.prototype.onShow = function (service) {
        };
        LightDismissableBody.prototype.onHide = function () {
            this.currentFocus = null;
        };
        LightDismissableBody.prototype.onKeyInStack = function (info) {
        };
        LightDismissableBody.prototype.onShouldLightDismiss = function (info) {
            return false;
        };
        LightDismissableBody.prototype.onLightDismiss = function (info) {
        };
        return LightDismissableBody;
    })();
    ;
    var LightDismissService = (function () {
        function LightDismissService() {
            this._debug = false; // Disables dismiss due to window blur. Useful during debugging.
            this._clients = [];
            this._notifying = false;
            this._bodyClient = new LightDismissableBody();
            // State private to _updateDom. No other method should make use of it.
            this._updateDom_rendered = {
                serviceActive: false
            };
            this._clickEaterEl = this._createClickEater();
            this._onBeforeRequestingFocusOnKeyboardInputBound = this._onBeforeRequestingFocusOnKeyboardInput.bind(this);
            this._onFocusInBound = this._onFocusIn.bind(this);
            this._onKeyDownBound = this._onKeyDown.bind(this);
            this._onWindowResizeBound = this._onWindowResize.bind(this);
            this._onClickEaterPointerUpBound = this._onClickEaterPointerUp.bind(this);
            this._onClickEaterPointerCancelBound = this._onClickEaterPointerCancel.bind(this);
            // Register for infrequent events.
            Application.addEventListener("backclick", this._onBackClick.bind(this));
            // Focus handlers generally use _ElementUtilities._addEventListener with focusout/focusin. This
            // uses the browser's blur event directly beacuse _addEventListener doesn't support focusout/focusin
            // on window.
            _Global.window.addEventListener("blur", this._onWindowBlur.bind(this));
            this.shown(this._bodyClient);
        }
        // Dismissables should call this as soon as they are ready to be shown. More specifically, they should call this:
        //   - After they are in the DOM and ready to receive focus (e.g. style.display cannot = "none")
        //   - Before their entrance animation is played
        LightDismissService.prototype.shown = function (client) {
            var index = this._clients.indexOf(client);
            if (index === -1) {
                this._clients.push(client);
                client.onShow(this);
                this._updateDom();
            }
        };
        // Dismissables should call this when they are done being dismissed (i.e. after their exit animation has finished)
        LightDismissService.prototype.hidden = function (client) {
            var index = this._clients.indexOf(client);
            if (index !== -1) {
                this._clients.splice(index, 1);
                client.setZIndex("");
                client.onHide();
                this._updateDom();
            }
        };
        // Dismissables should call this when their state has changed such that it'll affect the behavior of some method
        // in its ILightDismissable interface. For example, if the dismissable was altered such that getZIndexCount will
        // now return 2 instead of 1, that dismissable should call *updated* so the LightDismissService can find out about
        // this change.
        LightDismissService.prototype.updated = function (client) {
            this._updateDom();
        };
        LightDismissService.prototype.keyDown = function (client, eventObject) {
            if (eventObject.keyCode === _ElementUtilities.Key.escape) {
                this._escapePressed(eventObject);
            }
            else {
                this._dispatchKeyboardEvent(client, KeyboardInfoType.keyDown, eventObject);
            }
        };
        LightDismissService.prototype.keyUp = function (client, eventObject) {
            this._dispatchKeyboardEvent(client, KeyboardInfoType.keyUp, eventObject);
        };
        LightDismissService.prototype.keyPress = function (client, eventObject) {
            this._dispatchKeyboardEvent(client, KeyboardInfoType.keyPress, eventObject);
        };
        LightDismissService.prototype.isShown = function (client) {
            return this._clients.indexOf(client) !== -1;
        };
        LightDismissService.prototype.isTopmost = function (client) {
            return client === this._clients[this._clients.length - 1];
        };
        // Disables dismiss due to window blur. Useful during debugging.
        LightDismissService.prototype._setDebug = function (debug) {
            this._debug = debug;
        };
        LightDismissService.prototype._updateDom = function (options) {
            options = options || {};
            var activeDismissableNeedsFocus = !!options.activeDismissableNeedsFocus;
            var rendered = this._updateDom_rendered;
            if (this._notifying) {
                return;
            }
            var serviceActive = this._clients.length > 1;
            if (serviceActive !== rendered.serviceActive) {
                // Unregister/register for events that occur frequently.
                if (serviceActive) {
                    Application.addEventListener("beforerequestingfocusonkeyboardinput", this._onBeforeRequestingFocusOnKeyboardInputBound);
                    _ElementUtilities._addEventListener(_Global.document.documentElement, "focusin", this._onFocusInBound);
                    _Global.document.documentElement.addEventListener("keydown", this._onKeyDownBound);
                    _Global.window.addEventListener("resize", this._onWindowResizeBound);
                    this._bodyClient.currentFocus = _Global.document.activeElement;
                    _Global.document.body.appendChild(this._clickEaterEl);
                }
                else {
                    Application.removeEventListener("beforerequestingfocusonkeyboardinput", this._onBeforeRequestingFocusOnKeyboardInputBound);
                    _ElementUtilities._removeEventListener(_Global.document.documentElement, "focusin", this._onFocusInBound);
                    _Global.document.documentElement.removeEventListener("keydown", this._onKeyDownBound);
                    _Global.window.removeEventListener("resize", this._onWindowResizeBound);
                    var parent = this._clickEaterEl.parentNode;
                    parent && parent.removeChild(this._clickEaterEl);
                }
                rendered.serviceActive = serviceActive;
            }
            var zIndexGap = 0;
            var lastUsedZIndex = baseZIndex + 1;
            this._clients.forEach(function (c, i) {
                var currentZIndex = lastUsedZIndex + zIndexGap;
                c.setZIndex("" + currentZIndex);
                lastUsedZIndex = currentZIndex;
                // count + 1 so that there's an unused zIndex between each pair of
                // dismissables that can be used by the click eater.
                zIndexGap = c.getZIndexCount() + 1;
            });
            if (serviceActive) {
                this._clickEaterEl.style.zIndex = "" + (lastUsedZIndex - 1);
            }
            var activeDismissable = this._clients.length > 0 ? this._clients[this._clients.length - 1] : null;
            if (this._activeDismissable !== activeDismissable) {
                this._activeDismissable = activeDismissable;
                activeDismissableNeedsFocus = true;
            }
            if (activeDismissableNeedsFocus) {
                // If the last input type was keyboard, use focus() so a keyboard focus visual is drawn.
                // Otherwise, use setActive() so no focus visual is drawn.
                var useSetActive = !_KeyboardBehavior._keyboardSeenLast;
                this._activeDismissable && this._activeDismissable.onTakeFocus(useSetActive);
            }
        };
        LightDismissService.prototype._dispatchKeyboardEvent = function (client, keyboardInfoType, eventObject) {
            var index = this._clients.indexOf(client);
            if (index !== -1) {
                var info = {
                    type: keyboardInfoType,
                    keyCode: eventObject.keyCode,
                    propagationStopped: false,
                    stopPropagation: function () {
                        this.propagationStopped = true;
                        eventObject.stopPropagation();
                    }
                };
                var clients = this._clients.slice(0, index + 1);
                for (var i = clients.length - 1; i >= 0 && !info.propagationStopped; i--) {
                    clients[i].onKeyInStack(info);
                }
            }
        };
        LightDismissService.prototype._dispatchLightDismiss = function (reason, clients, options) {
            if (this._notifying) {
                _Log.log && _Log.log('_LightDismissService ignored dismiss trigger to avoid re-entrancy: "' + reason + '"', "TVJS _LightDismissService", "warning");
                return;
            }
            clients = clients || this._clients.slice(0);
            if (clients.length === 0) {
                return;
            }
            this._notifying = true;
            var lightDismissInfo = {
                // Which of the LightDismissalReasons caused this event to fire?
                reason: reason,
                // Is this dismissable currently the active dismissable?
                active: false,
                _stop: false,
                stopPropagation: function () {
                    this._stop = true;
                },
                _doDefault: true,
                preventDefault: function () {
                    this._doDefault = false;
                }
            };
            for (var i = clients.length - 1; i >= 0 && !lightDismissInfo._stop; i--) {
                lightDismissInfo.active = this._activeDismissable === clients[i];
                if (clients[i].onShouldLightDismiss(lightDismissInfo)) {
                    clients[i].onLightDismiss(lightDismissInfo);
                }
            }
            this._notifying = false;
            this._updateDom(options);
            return lightDismissInfo._doDefault;
        };
        LightDismissService.prototype._onBeforeRequestingFocusOnKeyboardInput = function (eventObject) {
            // Suppress the requestingFocusOnKeyboardInput event.
            return true;
        };
        //
        // Light dismiss triggers
        //
        // Called by tests.
        LightDismissService.prototype._clickEaterTapped = function () {
            this._dispatchLightDismiss(exports.LightDismissalReasons.tap);
        };
        LightDismissService.prototype._onFocusIn = function (eventObject) {
            var target = eventObject.target;
            for (var i = this._clients.length - 1; i >= 0; i--) {
                if (this._clients[i].containsElement(target)) {
                    break;
                }
            }
            if (i !== -1) {
                this._clients[i].onFocus(target);
            }
            if (i + 1 < this._clients.length) {
                this._dispatchLightDismiss(exports.LightDismissalReasons.lostFocus, this._clients.slice(i + 1), {
                    activeDismissableNeedsFocus: true
                });
            }
        };
        LightDismissService.prototype._onKeyDown = function (eventObject) {
            if (eventObject.keyCode === _ElementUtilities.Key.escape) {
                this._escapePressed(eventObject);
            }
        };
        LightDismissService.prototype._escapePressed = function (eventObject) {
            eventObject.preventDefault();
            eventObject.stopPropagation();
            this._dispatchLightDismiss(exports.LightDismissalReasons.escape);
        };
        // Called by tests.
        LightDismissService.prototype._onBackClick = function (eventObject) {
            var doDefault = this._dispatchLightDismiss(exports.LightDismissalReasons.hardwareBackButton);
            return !doDefault; // Returns whether or not the event was handled.
        };
        LightDismissService.prototype._onWindowResize = function (eventObject) {
            this._dispatchLightDismiss(exports.LightDismissalReasons.windowResize);
        };
        LightDismissService.prototype._onWindowBlur = function (eventObject) {
            if (this._debug) {
                return;
            }
            // Want to trigger a light dismiss on window blur.
            // We get blur if we click off the window, including into an iframe within our window.
            // Both blurs call this function, but fortunately document.hasFocus is true if either
            // the document window or our iframe window has focus.
            if (!_Global.document.hasFocus()) {
                // The document doesn't have focus, so they clicked off the app, so light dismiss.
                this._dispatchLightDismiss(exports.LightDismissalReasons.windowBlur);
            }
            else {
                // We were trying to unfocus the window, but document still has focus,
                // so make sure the iframe that took the focus will check for blur next time.
                var active = _Global.document.activeElement;
                if (active && active.tagName === "IFRAME" && !active["msLightDismissBlur"]) {
                    // - This will go away when the IFRAME goes away, and we only create one.
                    // - This only works in IE because other browsers don't fire focus events on iframe elements.
                    // - Can't use _ElementUtilities._addEventListener's focusout because it doesn't fire when an
                    //   iframe loses focus due to changing windows.
                    active.addEventListener("blur", this._onWindowBlur.bind(this), false);
                    active["msLightDismissBlur"] = true;
                }
            }
        };
        LightDismissService.prototype._createClickEater = function () {
            var clickEater = _Global.document.createElement("section");
            clickEater.className = exports._ClassNames._clickEater;
            _ElementUtilities._addEventListener(clickEater, "pointerdown", this._onClickEaterPointerDown.bind(this), true);
            clickEater.addEventListener("click", this._onClickEaterClick.bind(this), true);
            // Tell Aria that it's clickable
            clickEater.setAttribute("role", "menuitem");
            clickEater.setAttribute("aria-label", Strings.closeOverlay);
            // Prevent CED from removing any current selection
            clickEater.setAttribute("unselectable", "on");
            return clickEater;
        };
        LightDismissService.prototype._onClickEaterPointerDown = function (eventObject) {
            eventObject.stopPropagation();
            eventObject.preventDefault();
            this._clickEaterPointerId = eventObject.pointerId;
            if (!this._registeredClickEaterCleanUp) {
                _ElementUtilities._addEventListener(_Global.window, "pointerup", this._onClickEaterPointerUpBound);
                _ElementUtilities._addEventListener(_Global.window, "pointercancel", this._onClickEaterPointerCancelBound);
                this._registeredClickEaterCleanUp = true;
            }
        };
        LightDismissService.prototype._onClickEaterPointerUp = function (eventObject) {
            var _this = this;
            eventObject.stopPropagation();
            eventObject.preventDefault();
            if (eventObject.pointerId === this._clickEaterPointerId) {
                this._resetClickEaterPointerState();
                var element = _Global.document.elementFromPoint(eventObject.clientX, eventObject.clientY);
                if (element === this._clickEaterEl) {
                    this._skipClickEaterClick = true;
                    _BaseUtils._yieldForEvents(function () {
                        _this._skipClickEaterClick = false;
                    });
                    this._clickEaterTapped();
                }
            }
        };
        LightDismissService.prototype._onClickEaterClick = function (eventObject) {
            eventObject.stopPropagation();
            eventObject.preventDefault();
            if (!this._skipClickEaterClick) {
                // Handle the UIA invoke action on the click eater. this._skipClickEaterClick is false which tells
                // us that we received a click event without an associated PointerUp event. This means that the click
                // event was triggered thru UIA rather than thru the GUI.
                this._clickEaterTapped();
            }
        };
        LightDismissService.prototype._onClickEaterPointerCancel = function (eventObject) {
            if (eventObject.pointerId === this._clickEaterPointerId) {
                this._resetClickEaterPointerState();
            }
        };
        LightDismissService.prototype._resetClickEaterPointerState = function () {
            if (this._registeredClickEaterCleanUp) {
                _ElementUtilities._removeEventListener(_Global.window, "pointerup", this._onClickEaterPointerUpBound);
                _ElementUtilities._removeEventListener(_Global.window, "pointercancel", this._onClickEaterPointerCancelBound);
            }
            this._clickEaterPointerId = null;
            this._registeredClickEaterCleanUp = false;
        };
        return LightDismissService;
    })();
    var service = new LightDismissService();
    exports.shown = service.shown.bind(service);
    exports.hidden = service.hidden.bind(service);
    exports.updated = service.updated.bind(service);
    exports.isShown = service.isShown.bind(service);
    exports.isTopmost = service.isTopmost.bind(service);
    exports.keyDown = service.keyDown.bind(service);
    exports.keyUp = service.keyUp.bind(service);
    exports.keyPress = service.keyPress.bind(service);
    exports._clickEaterTapped = service._clickEaterTapped.bind(service);
    exports._onBackClick = service._onBackClick.bind(service);
    exports._setDebug = service._setDebug.bind(service);
    _Base.Namespace.define("TVJS.UI._LightDismissService", {
        shown: exports.shown,
        hidden: exports.hidden,
        updated: exports.updated,
        isShown: exports.isShown,
        isTopmost: exports.isTopmost,
        keyDown: exports.keyDown,
        keyUp: exports.keyUp,
        keyPress: exports.keyPress,
        _clickEaterTapped: exports._clickEaterTapped,
        _onBackClick: exports._onBackClick,
        _setDebug: exports._setDebug,
        LightDismissableElement: LightDismissableElement,
        DismissalPolicies: exports.DismissalPolicies,
        LightDismissalReasons: exports.LightDismissalReasons,
        _ClassNames: exports._ClassNames,
        _service: service
    });
});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
/// <reference path="../../../../typings/require.d.ts" />
define('TVJS/Utilities/_KeyboardInfo', ["require", "exports", '../Core/_BaseCoreUtils', '../Core/_Global', '../Core/_WinRT'], function (require, exports, _BaseCoreUtils, _Global, _WinRT) {
    "use strict";
    var _Constants = {
        visualViewportClass: "tv-visualviewport-space",
        scrollTimeout: 150,
    };
    // Definiton of *Visible Document*:
    //   Some portions of this file refer to the *visible document* or *visibleDoc*. Generally speaking,
    //   this is the portion of the app that is visible to the user (factoring in optical zoom and input pane occlusion).
    //   Technically speaking, in most cases, this is equivalent to the *visual viewport*. The exception is
    //   when the input pane has shown without resizing the *visual viewport*. In this case, the *visible document*
    //   is the *visual viewport* height minus the input pane occlusion.
    // This private module provides accurate metrics for the Visual Viewport and WWA's IHM offsets in Win10 WWA 
    // where "-ms-device-fixed" CSS positioning is supported. TVJS controls will also use this module for
    // positoning themselves relative to the viewport in a web browser outside of WWA. Their preference is still 
    // to rely on "-ms-device-fixed" positioning, but currently fallback to "fixed" positioning in enviornments where
    // "-ms-device-fixed" is not supported.
    exports._KeyboardInfo;
    // WWA Soft Keyboard offsets
    exports._KeyboardInfo = {
        // Determine if the keyboard is visible or not.
        get _visible() {
            try {
                return (_WinRT.Windows.UI.ViewManagement.InputPane && _WinRT.Windows.UI.ViewManagement.InputPane.getForCurrentView().occludedRect.height > 0);
            }
            catch (e) {
                return false;
            }
        },
        // See if we have to reserve extra space for the IHM
        get _extraOccluded() {
            var occluded = 0;
            // Controls using -ms-device-fixed positioning only need to reposition themselves to remain visible
            // If the IHM has not resized the viewport.  
            if (!exports._KeyboardInfo._isResized && _WinRT.Windows.UI.ViewManagement.InputPane) {
                occluded = _WinRT.Windows.UI.ViewManagement.InputPane.getForCurrentView().occludedRect.height;
            }
            return occluded;
        },
        // See if the view has been resized to fit a keyboard
        get _isResized() {
            // Compare ratios.  Very different includes IHM space.
            var heightRatio = _Global.document.documentElement.clientHeight / _Global.innerHeight, widthRatio = _Global.document.documentElement.clientWidth / _Global.innerWidth;
            // If they're nearly identical, then the view hasn't been resized for the IHM
            // Only check one bound because we know the IHM will make it shorter, not skinnier.
            return (widthRatio / heightRatio < 0.99);
        },
        // Get the bottom of the visible area, relative to the top edge of the visible area.
        get _visibleDocBottom() {
            return exports._KeyboardInfo._visibleDocTop + exports._KeyboardInfo._visibleDocHeight;
        },
        // Get the height of the visible area, e.g. the height of the visual viewport minus any IHM occlusion.
        get _visibleDocHeight() {
            return exports._KeyboardInfo._visualViewportHeight - exports._KeyboardInfo._extraOccluded;
        },
        // Get the top offset of our visible area, aka the top of the visual viewport.
        // This is always 0 when elements use -ms-device-fixed positioning.
        get _visibleDocTop() {
            return 0;
        },
        // Get the offset for, and relative to, the bottom edge of the visual viewport plus any IHM occlusion.
        get _visibleDocBottomOffset() {
            // For -ms-device-fixed positioned elements, the bottom is just 0 when there's no IHM.
            // When the IHM appears, the text input that invoked it may be in a position on the page that is occluded by the IHM.
            // In that instance, the default browser behavior is to resize the visual viewport and scroll the input back into view.
            // However, if the viewport resize is prevented by an IHM event listener, the keyboard will still occlude
            // -ms-device-fixed elements, so we adjust the bottom offset of the appbar by the height of the occluded rect of the IHM.
            return exports._KeyboardInfo._extraOccluded;
        },
        // Get the visual viewport height. window.innerHeight doesn't return floating point values which are present with high DPI.
        get _visualViewportHeight() {
            var boundingRect = exports._KeyboardInfo._visualViewportSpace;
            return boundingRect.height;
        },
        // Get the visual viewport width. window.innerWidth doesn't return floating point values which are present with high DPI.
        get _visualViewportWidth() {
            var boundingRect = exports._KeyboardInfo._visualViewportSpace;
            return boundingRect.width;
        },
        // The visual viewport space element is hidden given -ms-device-fixed positioning and used to calculate
        // the 4 edges of the visual viewport with floating point precision. 
        get _visualViewportSpace() {
            var visualViewportSpace = _Global.document.body.querySelector("." + _Constants.visualViewportClass);
            if (!visualViewportSpace) {
                visualViewportSpace = _Global.document.createElement("DIV");
                visualViewportSpace.className = _Constants.visualViewportClass;
                _Global.document.body.appendChild(visualViewportSpace);
            }
            return visualViewportSpace.getBoundingClientRect();
        },
        // Get total length of the IHM showPanel animation
        get _animationShowLength() {
            if (_BaseCoreUtils.hasWinRT) {
                if (_WinRT.Windows.UI.Core.AnimationMetrics) {
                    // Desktop exposes the AnimationMetrics API that allows us to look up the relevant IHM animation metrics.
                    var a = _WinRT.Windows.UI.Core.AnimationMetrics, animationDescription = new a.AnimationDescription(a.AnimationEffect.showPanel, a.AnimationEffectTarget.primary);
                    var animations = animationDescription.animations;
                    var max = 0;
                    for (var i = 0; i < animations.size; i++) {
                        var animation = animations[i];
                        max = Math.max(max, animation.delay + animation.duration);
                    }
                    return max;
                }
                else {
                    // Phone platform does not yet expose the Animation Metrics API. 
                    // Hard code the correct values for the time being.
                    // https://github.com/TVJS/TVJS/issues/1060
                    var animationDuration = 300;
                    var animationDelay = 50;
                    return animationDelay + animationDuration;
                }
            }
            else {
                return 0;
            }
        },
        // Padding for IHM timer to allow for first scroll event. Tpyically used in conjunction with the
        // _animationShowLength to determine the length of time in which a showing IHM would have triggered
        // a window resize to occur.
        get _scrollTimeout() {
            return _Constants.scrollTimeout;
        },
        // _layoutViewportCoords gives the top and bottom offset of the visible document for elements using
        // position:fixed. Comparison with position:-ms-device-fixed helper:
        //   - Like -ms-device-fixed helper, takes into account input pane occlusion.
        //   - Unlike -ms-device-fixed helper, doesn't account for optical zoom.
        get _layoutViewportCoords() {
            var topOffset = _Global.window.pageYOffset - _Global.document.documentElement.scrollTop;
            var bottomOffset = _Global.document.documentElement.clientHeight - (topOffset + this._visibleDocHeight);
            return {
                visibleDocTop: topOffset,
                visibleDocBottom: bottomOffset
            };
        }
    };
});

define('require-style!less/styles-overlay',[],function(){});

define('require-style!less/colors-overlay',[],function(){});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
/// <dictionary>animatable,appbar,appbars,divs,Flyout,Flyouts,iframe,Statics,unfocus,unselectable</dictionary>
define('TVJS/Controls/Flyout/_Overlay',[
    'exports',
    '../../Core/_Global',
    '../../Core/_WinRT',
    '../../Core/_Base',
    '../../Core/_BaseUtils',
    '../../Core/_ErrorFromName',
    '../../Core/_Events',
    '../../Core/_Resources',
    '../../_Accents',
    '../../Animations',
    '../../Application',
    '../../ControlProcessor',
    '../../Promise',
    '../../Utilities/_Control',
    '../../Utilities/_ElementUtilities',
    '../../Utilities/_KeyboardInfo',
    'require-style!less/styles-overlay',
    'require-style!less/colors-overlay'
], function overlayInit(exports, _Global, _WinRT, _Base, _BaseUtils, _ErrorFromName, _Events, _Resources, _Accents, Animations, Application, ControlProcessor, Promise, _Control, _ElementUtilities, _KeyboardInfo) {
    "use strict";

    _Accents.createAccentRule(
        "button[aria-checked=true].tv-command:before,\
         .tv-menu-containsflyoutcommand button.tv-command-flyout-activated:before", [
        { name: "background-color", value: _Accents.ColorTypes.accent },
        { name: "border-color", value: _Accents.ColorTypes.accent },
         ]);

    _Accents.createAccentRule(".tv-flyout, .tv-settingsflyout", [{ name: "border-color", value: _Accents.ColorTypes.accent }]);

    _Base.Namespace._moduleDefine(exports, "TVJS.UI", {
        _Overlay: _Base.Namespace._lazy(function () {

            // Helper for Global Event listeners. Invokes the specified callback member function on each _Overlay in the DOM.
            function _allOverlaysCallback(event, nameOfFunctionCall, stopImmediatePropagationWhenHandled) {
                var elements = _Global.document.querySelectorAll(".tv-overlay");
                if (elements) {
                    var len = elements.length;
                    for (var i = 0; i < len; i++) {
                        var element = elements[i];
                        var overlay = element.winControl;
                        if (!overlay._disposed) {
                            if (overlay) {
                                var handled = overlay[nameOfFunctionCall](event);
                                if (stopImmediatePropagationWhenHandled && handled) {
                                    // The caller has indicated we should exit as soon as the event is handled.
                                    return handled;
                                }
                            }
                        }
                    }
                }
            }

            // _Overlay Global Events Listener Class. We hang a singleton instance of this class off of a static _Overlay property.
            var _GlobalListener = _Base.Class.define(function _GlobalListener_ctor() {
                this._currentState = _GlobalListener.states.off;

                this._inputPaneShowing = this._inputPaneShowing.bind(this);
                this._inputPaneHiding = this._inputPaneHiding.bind(this);
                this._documentScroll = this._documentScroll.bind(this);
                this._windowResized = this._windowResized.bind(this);
            }, {
                initialize: function _GlobalListener_initialize() {
                    this._toggleListeners(_GlobalListener.states.on);
                },
                // Expose this for unit tests.
                reset: function _GlobalListener_reset() {
                    this._toggleListeners(_GlobalListener.states.off);
                    this._toggleListeners(_GlobalListener.states.on);
                },
                _inputPaneShowing: function _GlobalListener_inputePaneShowing(event) {
                    _allOverlaysCallback(event, "_showingKeyboard");
                },
                _inputPaneHiding: function _GlobalListener_inputPaneHiding(event) {
                    _allOverlaysCallback(event, "_hidingKeyboard");
                },
                _documentScroll: function _GlobalListener_documentScroll(event) {
                    _allOverlaysCallback(event, "_checkScrollPosition");
                },
                _windowResized: function _GlobalListener_windowResized(event) {
                    _allOverlaysCallback(event, "_baseResize");
                },
                _toggleListeners: function _GlobalListener_toggleListeners(newState) {
                    // Add/Remove global event listeners for all _Overlays
                    var listenerOperation;
                    if (this._currentState !== newState) {
                        if (newState === _GlobalListener.states.on) {
                            listenerOperation = "addEventListener";
                        } else if (newState === _GlobalListener.states.off) {
                            listenerOperation = "removeEventListener";
                        }

                        if (_WinRT.Windows.UI.ViewManagement.InputPane) {
                            // React to Soft Keyboard events
                            var inputPane = _WinRT.Windows.UI.ViewManagement.InputPane.getForCurrentView();
                            inputPane[listenerOperation]("showing", this._inputPaneShowing, false);
                            inputPane[listenerOperation]("hiding", this._inputPaneHiding, false);

                            _Global.document[listenerOperation]("scroll", this._documentScroll, false);
                        }

                        // Window resize event
                        _Global.addEventListener("resize", this._windowResized, false);

                        this._currentState = newState;
                    }
                },
            }, {
                // Statics
                profilerString: {
                    get: function () {
                        return "TVJS.UI._Overlay Global Listener:";
                    }
                },
                states: {
                    get: function () {
                        return {
                            off: 0,
                            on: 1,
                        };
                    },
                },
            });

            // Helper to get DOM elements from input single object or array or IDs/toolkit/dom elements
            function _resolveElements(elements) {
                // No input is just an empty array
                if (!elements) {
                    return [];
                }

                // Make sure it's in array form.
                if (typeof elements === "string" || !elements || !elements.length) {
                    elements = [elements];
                }

                // Make sure we have a DOM element for each one, (could be string id name or toolkit object)
                var i,
                    realElements = [];
                for (i = 0; i < elements.length; i++) {
                    if (elements[i]) {
                        if (typeof elements[i] === "string") {
                            var element = _Global.document.getElementById(elements[i]);
                            if (element) {
                                realElements.push(element);
                            }
                        } else if (elements[i].element) {
                            realElements.push(elements[i].element);
                        } else {
                            realElements.push(elements[i]);
                        }
                    }
                }

                return realElements;
            }

            var strings = {
                get duplicateConstruction() { return "Invalid argument: Controls may only be instantiated one time for each DOM element"; },
                get mustContainCommands() { return "Invalid HTML: AppBars/Menus must contain only AppBarCommands/MenuCommands"; },
                get closeOverlay() { return _Resources._getTVJSString("ui/closeOverlay").value; },
            };

            var _Overlay = _Base.Class.define(function _Overlay_ctor(element, options) {
                /// <signature helpKeyword="TVJS.UI._Overlay">
                /// <summary locid="TVJS.UI._Overlay">
                /// Constructs the Overlay control and associates it with the underlying DOM element.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" locid="TVJS.UI._Overlay_p:element">
                /// The DOM element to be associated with the Overlay control.
                /// </param>
                /// <param name="options" type="Object" domElement="false" locid="TVJS.UI._Overlay_p:options">
                /// The set of options to be applied initially to the Overlay control.
                /// </param>
                /// <returns type="TVJS.UI._Overlay" locid="TVJS.UI._Overlay_returnValue">A fully constructed Overlay control.</returns>
                /// </signature>
                this._baseOverlayConstructor(element, options);
            }, {
                // Functions/properties
                _baseOverlayConstructor: function _Overlay_baseOverlayConstructor(element, options) {

                    this._disposed = false;

                    // Make sure there's an input element
                    if (!element) {
                        element = _Global.document.createElement("div");
                    }

                    // Check to make sure we weren't duplicated
                    var overlay = element.winControl;
                    if (overlay) {
                        throw new _ErrorFromName("TVJS.UI._Overlay.DuplicateConstruction", strings.duplicateConstruction);
                    }

                    if (!this._element) {
                        this._element = element;
                    }

                    if (!this._element.hasAttribute("tabIndex")) {
                        this._element.tabIndex = -1;
                    }

                    this._sticky = false;
                    this._doNext = "";

                    this._element.style.visibility = "hidden";
                    this._element.style.opacity = 0;

                    // Remember ourselves
                    element.winControl = this;

                    // Attach our css class
                    _ElementUtilities.addClass(this._element, "tv-overlay");
                    _ElementUtilities.addClass(this._element, "tv-disposable");

                    // We don't want to be selectable, set UNSELECTABLE
                    var unselectable = this._element.getAttribute("unselectable");
                    if (unselectable === null || unselectable === undefined) {
                        this._element.setAttribute("unselectable", "on");
                    }

                    // Base animation is popIn/popOut
                    this._currentAnimateIn = this._baseAnimateIn;
                    this._currentAnimateOut = this._baseAnimateOut;
                    this._animationPromise = Promise.as();

                    // Command Animations to Queue
                    this._queuedToShow = [];
                    this._queuedToHide = [];
                    this._queuedCommandAnimation = false;

                    if (options) {
                        _Control.setOptions(this, options);
                    }

                    // Make sure _Overlay event handlers are hooked up (this aids light dismiss)
                    _Overlay._globalEventListeners.initialize();
                },

                /// <field type="HTMLElement" domElement="true" readonly="true" hidden="true" locid="TVJS.UI._Overlay.element" helpKeyword="TVJS.UI._Overlay.element">The DOM element the Overlay is attached to</field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },

                dispose: function () {
                    /// <signature helpKeyword="TVJS.UI.Overlay.dispose">
                    /// <summary locid="TVJS.UI.Overlay.dispose">
                    /// Disposes this Overlay.
                    /// </summary>
                    /// </signature>
                    if (this._disposed) {
                        return;
                    }

                    this._disposed = true;
                    this._dispose();
                },

                _dispose: function _Overlay_dispose() {
                    // To be overridden by subclasses
                },

                _show: function _Overlay_show() {
                    // We call our base _baseShow because AppBar may need to override show
                    this._baseShow();
                },

                _hide: function _Overlay_hide() {
                    // We call our base _baseHide because AppBar may need to override hide
                    this._baseHide();
                },

                // Is the overlay "hidden"?
                /// <field type="Boolean" hidden="true" locid="TVJS.UI._Overlay.hidden" helpKeyword="TVJS.UI._Overlay.hidden">Gets or sets Overlay's visibility.</field>
                hidden: {
                    get: function () {
                        return (this._element.style.visibility === "hidden" ||
                                this._element.winAnimating === "hiding" ||
                                this._doNext === "hide");
                    },
                    set: function (hidden) {
                        var currentlyHidden = this.hidden;
                        if (!hidden && currentlyHidden) {
                            this.show();
                        } else if (hidden && !currentlyHidden) {
                            this.hide();
                        }
                    }
                },

                addEventListener: function (type, listener, useCapture) {
                    /// <signature helpKeyword="TVJS.UI._Overlay.addEventListener">
                    /// <summary locid="TVJS.UI._Overlay.addEventListener">
                    /// Add an event listener to the DOM element for this Overlay
                    /// </summary>
                    /// <param name="type" type="String" locid="TVJS.UI._Overlay.addEventListener_p:type">Required. Event type to add, "beforehide", "afterhide", "beforeshow", or "aftershow"</param>
                    /// <param name="listener" type="Function" locid="TVJS.UI._Overlay.addEventListener_p:listener">Required. The event handler function to associate with this event.</param>
                    /// <param name="useCapture" type="Boolean" locid="TVJS.UI._Overlay.addEventListener_p:useCapture">Optional. True, register for the event capturing phase.  False for the event bubbling phase.</param>
                    /// </signature>
                    return this._element.addEventListener(type, listener, useCapture);
                },

                removeEventListener: function (type, listener, useCapture) {
                    /// <signature helpKeyword="TVJS.UI._Overlay.removeEventListener">
                    /// <summary locid="TVJS.UI._Overlay.removeEventListener">
                    /// Remove an event listener to the DOM element for this Overlay
                    /// </summary>
                    /// <param name="type" type="String" locid="TVJS.UI._Overlay.removeEventListener_p:type">Required. Event type to remove, "beforehide", "afterhide", "beforeshow", or "aftershow"</param>
                    /// <param name="listener" type="Function" locid="TVJS.UI._Overlay.removeEventListener_p:listener">Required. The event handler function to associate with this event.</param>
                    /// <param name="useCapture" type="Boolean" locid="TVJS.UI._Overlay.removeEventListener_p:useCapture">Optional. True, register for the event capturing phase.  False for the event bubbling phase.</param>
                    /// </signature>
                    return this._element.removeEventListener(type, listener, useCapture);
                },

                _baseShow: function _Overlay_baseShow() {
                    // If we are already animating, just remember this for later
                    if (this._animating || this._needToHandleHidingKeyboard) {
                        this._doNext = "show";
                        return false;
                    }

                    var result = false;

                    if (this._element.style.visibility !== "visible") {
                        // Let us know we're showing.
                        this._element.winAnimating = "showing";

                        // Hiding, but not none
                        this._element.style.display = "";
                        this._element.style.visibility = "hidden";

                        // In case their event is going to manipulate commands, see if there are
                        // any queued command animations we can handle while we're still hidden.
                        if (this._queuedCommandAnimation) {
                            this._showAndHideFast(this._queuedToShow, this._queuedToHide);
                            this._queuedToShow = [];
                            this._queuedToHide = [];
                        }

                        // Do our derived classes show stuff 
                        this._beforeShow();

                        // Send our "beforeShow" event
                        this._sendEvent(_Overlay.beforeShow);

                        // Need to measure
                        this._ensurePosition();

                        // Make sure it's visible, and fully opaque.
                        // Do the popup thing, sending event afterward.
                        var that = this;
                        this._animationPromise = this._currentAnimateIn().
                        then(function () {
                            that._baseEndShow();
                        }, function () {
                            that._baseEndShow();
                        });
                        result = true;
                    }

                    // Remember the previous focus root
                    if (TVJS._tv && TVJS.DirectionalNavigation) {
                        if (TVJS.DirectionalNavigation.focusRoot &&
                            TVJS.DirectionalNavigation.focusRoot !== this._element) {
                            // If there are other visible overlays, then we need to pass our focusRoot to the
                            // new overlay so that if the user opens multiple overlays in a row, then dismisses
                            // each one, once all the overlays are gone, the user will end back up with their origional
                            // focusRoot restored.
                            if (TVJS.Utilities.hasClass(TVJS.DirectionalNavigation.focusRoot, "win-overlay")) {
                                this._previousFocusRoot = TVJS.DirectionalNavigation.focusRoot.winControl._previousFocusRoot;
                            } else {
                                this._previousFocusRoot = TVJS.DirectionalNavigation.focusRoot;
                            }
                            TVJS.DirectionalNavigation.focusRoot = this._element;
                        }
                    }

                    return result;
                },

                _beforeShow: function _Overlay_beforeShow() {
                    // Nothing by default
                },

                // Flyout in particular will need to measure our positioning.
                _ensurePosition: function _Overlay_ensurePosition() {
                    // Nothing by default
                },

                _baseEndShow: function _Overlay_baseEndShow() {
                    if (this._disposed) {
                        return;
                    }

                    // Make sure it's visible after showing
                    this._element.setAttribute("aria-hidden", "false");

                    this._element.winAnimating = "";

                    // We're shown now
                    if (this._doNext === "show") {
                        this._doNext = "";
                    }

                    // After showing, send the after showing event
                    this._sendEvent(_Overlay.afterShow);

                    // If we had something queued, do that
                    setImmediate(this._checkDoNext);

                    if (TVJS._tv && TVJS.DirectionalNavigation) {
                        // Find the first focusable element and set focus to it
                        TVJS.DirectionalNavigation.moveFocus("right", {
                            focusRoot: this._element,
                            referenceRect: {
                                top: -1,
                                left: -1,
                                right: 0,
                                bottom: 0,
                                width: 1,
                                height: 1
                            }
                        });
                    }
                },

                _baseHide: function _Overlay_baseHide() {
                    // If we are already animating, just remember this for later
                    if (this._animating) {
                        this._doNext = "hide";
                        return false;
                    }

                    var result = false;

                    // In the unlikely event we're between the hiding keyboard and the resize events, just snap it away:
                    if (this._needToHandleHidingKeyboard) {
                        // use the "uninitialized" flag
                        this._element.style.visibility = "";
                    }

                    if (this._element.style.visibility !== "hidden") {
                        // Let us know we're hiding, accessibility as well.
                        this._element.winAnimating = "hiding";
                        this._element.setAttribute("aria-hidden", "true");

                        // Send our "beforeHide" event
                        this._sendEvent(_Overlay.beforeHide);

                        // If our visibility is empty, then this is the first time, just hide it
                        if (this._element.style.visibility === "") {
                            // Initial hiding, just hide it
                            this._element.style.opacity = 0;
                            this._baseEndHide();
                        } else {
                            // Make sure it's hidden, and fully transparent.
                            var that = this;
                            this._animationPromise = this._currentAnimateOut().
                            then(function () {
                                that._baseEndHide();
                            }, function () {
                                that._baseEndHide();
                            });
                        }
                        result = true;
                    }

                    // We need to make sure there are no other visible overlays. If there is a visible
                    // overlay and we set the focusRoot back to the previous focusRoot, then the
                    // other overlay will not have focus scoped to itself.
                    var areThereOtherVisibleOverlays = false;
                    var overlays = document.querySelectorAll(".win-overlay, .win-appbar");
                    for (var i = 0, len = overlays.length; i < len; i++) {
                        if (overlays[i].winControl &&
                            !overlays[i].winControl.hidden) {
                            areThereOtherVisibleOverlays = true;
                            break;
                        }
                    }
                    // Reset the old focusRoot. Note: we need to check if the previous focusRoot
                    // is still in the DOM. If it is not (in the case of a page navigation), then 
                    // we do not restore the focusRoot.
                    if (TVJS._tv && TVJS.DirectionalNavigation &&
                        this._previousFocusRoot &&
                        this._previousFocusRoot.parentNode &&
                        !areThereOtherVisibleOverlays) {
                        TVJS.DirectionalNavigation.focusRoot = this._previousFocusRoot;
                        this._previousFocusRoot = null;
                    }

                    return result;
                },

                _baseEndHide: function _Overlay_baseEndHide() {
                    if (this._disposed) {
                        return;
                    }

                    // Do our derived classes hide stuff
                    this._beforeEndHide();

                    // Make sure animation is finished.
                    this._element.style.visibility = "hidden";
                    this._element.style.display = "none";
                    this._element.winAnimating = "";

                    // In case their event is going to manipulate commands, see if there
                    // are any queued command animations we can handle now we're hidden.
                    if (this._queuedCommandAnimation) {
                        this._showAndHideFast(this._queuedToShow, this._queuedToHide);
                        this._queuedToShow = [];
                        this._queuedToHide = [];
                    }

                    // We're hidden now
                    if (this._doNext === "hide") {
                        this._doNext = "";
                    }

                    // Do our derived classes hide stuff
                    this._afterHide();

                    // After hiding, send our "afterHide" event
                    this._sendEvent(_Overlay.afterHide);

                    // If we had something queued, do that.  This has to be after
                    // the afterHide event in case it triggers a show() and they
                    // have something to do in beforeShow that requires afterHide first.
                    setImmediate(this._checkDoNext);
                },

                // Called after the animation but while the Overlay is still visible. It's
                // important that this runs while the Overlay is visible because hiding
                // a DOM element (e.g. visibility="hidden", display="none") while it contains
                // focus has the side effect of moving focus to the body or null and triggering
                // focus move events. _beforeEndHide is a good hook for the Overlay to move focus
                // elsewhere before its DOM element gets hidden.
                _beforeEndHide: function _Overlay_beforeEndHide() {
                    // Nothing by default
                },

                _afterHide: function _Overlay_afterHide() {
                    // Nothing by default
                },

                _checkDoNext: function _Overlay_checkDoNext() {
                    // Do nothing if we're still animating
                    if (this._animating || this._needToHandleHidingKeyboard || this._disposed) {
                        return;
                    }

                    if (this._doNext === "hide") {
                        // Do hide first because animating commands would be easier
                        this._hide();
                        this._doNext = "";
                    } else if (this._queuedCommandAnimation) {
                        // Do queued commands before showing if possible
                        this._showAndHideQueue();
                    } else if (this._doNext === "show") {
                        // Show last so that we don't unnecessarily animate commands
                        this._show();
                        this._doNext = "";
                    }
                },

                // Default animations
                _baseAnimateIn: function _Overlay_baseAnimateIn() {
                    this._element.style.opacity = 0;
                    this._element.style.visibility = "visible";
                    // touch opacity so that IE fades from the 0 we just set to 1
                    _ElementUtilities._getComputedStyle(this._element, null).opacity;
                    return Animations.fadeIn(this._element);
                },

                _baseAnimateOut: function _Overlay_baseAnimateOut() {
                    this._element.style.opacity = 1;
                    // touch opacity so that IE fades from the 1 we just set to 0
                    _ElementUtilities._getComputedStyle(this._element, null).opacity;
                    return Animations.fadeOut(this._element);
                },

                _animating: {
                    get: function _Overlay_animating_get() {
                        // Ensure it's a boolean because we're using the DOM element to keep in-sync
                        return !!this._element.winAnimating;
                    }
                },

                // Send one of our events
                _sendEvent: function _Overlay_sendEvent(eventName, detail) {
                    if (this._disposed) {
                        return;
                    }
                    var event = _Global.document.createEvent("CustomEvent");
                    event.initEvent(eventName, true, true, (detail || {}));
                    this._element.dispatchEvent(event);
                },

                // Show commands
                _showCommands: function _Overlay_showCommands(commands, immediate) {
                    var showHide = this._resolveCommands(commands);
                    this._showAndHideCommands(showHide.commands, [], immediate);
                },

                // Hide commands
                _hideCommands: function _Overlay_hideCommands(commands, immediate) {
                    var showHide = this._resolveCommands(commands);
                    this._showAndHideCommands([], showHide.commands, immediate);
                },

                // Hide commands
                _showOnlyCommands: function _Overlay_showOnlyCommands(commands, immediate) {
                    var showHide = this._resolveCommands(commands);
                    this._showAndHideCommands(showHide.commands, showHide.others, immediate);
                },

                _showAndHideCommands: function _Overlay_showAndHideCommands(showCommands, hideCommands, immediate) {
                    // Immediate is "easy"
                    if (immediate || (this.hidden && !this._animating)) {
                        // Immediate mode (not animated)
                        this._showAndHideFast(showCommands, hideCommands);
                        // Need to remove them from queues, but others could be queued
                        this._removeFromQueue(showCommands, this._queuedToShow);
                        this._removeFromQueue(hideCommands, this._queuedToHide);
                    } else {

                        // Queue Commands
                        this._updateAnimateQueue(showCommands, this._queuedToShow, this._queuedToHide);
                        this._updateAnimateQueue(hideCommands, this._queuedToHide, this._queuedToShow);
                    }
                },

                _removeFromQueue: function _Overlay_removeFromQueue(commands, queue) {
                    // remove commands from queue.
                    var count;
                    for (count = 0; count < commands.length; count++) {
                        // Remove if it was in queue
                        var countQ;
                        for (countQ = 0; countQ < queue.length; countQ++) {
                            if (queue[countQ] === commands[count]) {
                                queue.splice(countQ, 1);
                                break;
                            }
                        }
                    }
                },

                _updateAnimateQueue: function _Overlay_updateAnimateQueue(addCommands, toQueue, fromQueue) {
                    if (this._disposed) {
                        return;
                    }

                    // Add addCommands to toQueue and remove addCommands from fromQueue.
                    var count;
                    for (count = 0; count < addCommands.length; count++) {
                        // See if it's already in toQueue
                        var countQ;
                        for (countQ = 0; countQ < toQueue.length; countQ++) {
                            if (toQueue[countQ] === addCommands[count]) {
                                break;
                            }
                        }
                        if (countQ === toQueue.length) {
                            // Not found, add it
                            toQueue[countQ] = addCommands[count];
                        }
                        // Remove if it was in fromQueue
                        for (countQ = 0; countQ < fromQueue.length; countQ++) {
                            if (fromQueue[countQ] === addCommands[count]) {
                                fromQueue.splice(countQ, 1);
                                break;
                            }
                        }
                    }
                    // If we haven't queued the actual animation
                    if (!this._queuedCommandAnimation) {
                        // If not already animating, we'll need to call _checkDoNext
                        if (!this._animating) {
                            setImmediate(this._checkDoNext);
                        }
                        this._queuedCommandAnimation = true;
                    }
                },

                // show/hide commands without doing any animation.
                _showAndHideFast: function _Overlay_showAndHideFast(showCommands, hideCommands) {
                    var count;
                    var command;
                    for (count = 0; count < showCommands.length; count++) {
                        command = showCommands[count];
                        if (command && command.style) {
                            command.style.visibility = "";
                            command.style.display = "";
                        }
                    }
                    for (count = 0; count < hideCommands.length; count++) {
                        command = hideCommands[count];
                        if (command && command.style) {
                            command.style.visibility = "hidden";
                            command.style.display = "none";
                        }
                    }

                    this._commandsUpdated();

                },

                // show and hide the queued commands, perhaps animating if overlay isn't hidden.
                _showAndHideQueue: function _Overlay_showAndHideQueue() {
                    // Only called if not currently animating.
                    // We'll be done with the queued stuff when we return.
                    this._queuedCommandAnimation = false;

                    // Shortcut if hidden
                    if (this.hidden) {
                        this._showAndHideFast(this._queuedToShow, this._queuedToHide);
                        // Might be something else to do
                        setImmediate(this._checkDoNext);
                    } else {
                        // Animation has 3 parts:  "hiding", "showing", and "moving"
                        // PVL has "addToList" and "deleteFromList", both of which allow moving parts.
                        // So we'll set up "add" for showing, and use "delete" for "hiding" + moving,
                        // then trigger both at the same time.
                        var showCommands = this._queuedToShow;
                        var hideCommands = this._queuedToHide;
                        var siblings = this._findSiblings(showCommands.concat(hideCommands));

                        // Filter out the commands queued for animation that don't need to be animated.
                        var count;
                        for (count = 0; count < showCommands.length; count++) {
                            // If this one's not real or not attached, skip it
                            if (!showCommands[count] ||
                                !showCommands[count].style ||
                                !_Global.document.body.contains(showCommands[count])) {
                                // Not real, skip it
                                showCommands.splice(count, 1);
                                count--;
                            } else if (showCommands[count].style.visibility !== "hidden" && showCommands[count].style.opacity !== "0") {
                                // Don't need to animate showing this one, already visible, so now it's a sibling
                                siblings.push(showCommands[count]);
                                showCommands.splice(count, 1);
                                count--;
                            }
                        }
                        for (count = 0; count < hideCommands.length; count++) {
                            // If this one's not real or not attached, skip it
                            if (!hideCommands[count] ||
                                !hideCommands[count].style ||
                                !_Global.document.body.contains(hideCommands[count]) ||
                                hideCommands[count].style.visibility === "hidden" ||
                                hideCommands[count].style.opacity === "0") {
                                // Don't need to animate hiding this one, not real, or it's hidden,
                                // so don't even need it as a sibling.
                                hideCommands.splice(count, 1);
                                count--;
                            }
                        }

                        // Start command animations.
                        var commandsAnimationPromise = this._baseBeginAnimateCommands(showCommands, hideCommands, siblings);

                        // Hook end animations
                        var that = this;
                        if (commandsAnimationPromise) {
                            // Needed to animate
                            commandsAnimationPromise.done(
                                function () { that._baseEndAnimateCommands(hideCommands); },
                                function () { that._baseEndAnimateCommands(hideCommands); }
                                );
                        } else {
                            // Already positioned correctly
                            setImmediate(function Overlay_async_baseEndAnimationCommands() { that._baseEndAnimateCommands([]); });
                        }
                    }

                    // Done, clear queues
                    this._queuedToShow = [];
                    this._queuedToHide = [];
                },

                _baseBeginAnimateCommands: function _Overlay_baseBeginAnimateCommands(showCommands, hideCommands, siblings) {
                    // The parameters are 3 mutually exclusive arrays of tv-command elements contained in this Overlay.
                    // 1) showCommands[]: All of the HIDDEN tv-command elements that ARE scheduled to show.
                    // 2) hideCommands[]: All of the VISIBLE tv-command elements that ARE shceduled to hide.
                    // 3) siblings[]: i. All VISIBLE tv-command elements that ARE NOT scheduled to hide.
                    //               ii. All HIDDEN tv-command elements that ARE NOT scheduled to hide OR show.
                    this._beginAnimateCommands(showCommands, hideCommands, this._getVisibleCommands(siblings));

                    var showAnimated = null,
                        hideAnimated = null;

                    // Hide commands first, with siblings if necessary,
                    // so that the showing commands don't disrupt the hiding commands position.
                    if (hideCommands.length > 0) {
                        hideAnimated = Animations.createDeleteFromListAnimation(hideCommands, showCommands.length === 0 ? siblings : undefined);
                    }
                    if (showCommands.length > 0) {
                        showAnimated = Animations.createAddToListAnimation(showCommands, siblings);
                    }

                    // Update hiding commands
                    for (var count = 0, len = hideCommands.length; count < len; count++) {
                        // Need to fix our position
                        var rectangle = hideCommands[count].getBoundingClientRect(),
                            style = _ElementUtilities._getComputedStyle(hideCommands[count]);

                        // Use the bounding box, adjusting for margins
                        hideCommands[count].style.top = (rectangle.top - parseFloat(style.marginTop)) + "px";
                        hideCommands[count].style.left = (rectangle.left - parseFloat(style.marginLeft)) + "px";
                        hideCommands[count].style.opacity = 0;
                        hideCommands[count].style.position = "fixed";
                    }

                    // Mark as animating
                    this._element.winAnimating = "rearranging";

                    // Start hiding animations
                    // Hide needs extra cleanup when done
                    var promise = null;
                    if (hideAnimated) {
                        promise = hideAnimated.execute();
                    }

                    // Update showing commands,
                    // After hiding commands so that the hiding ones fade in the right place.
                    for (count = 0; count < showCommands.length; count++) {
                        showCommands[count].style.visibility = "";
                        showCommands[count].style.display = "";
                        showCommands[count].style.opacity = 1;
                    }

                    // Start showing animations
                    if (showAnimated) {
                        var newPromise = showAnimated.execute();
                        if (promise) {
                            promise = Promise.join([promise, newPromise]);
                        } else {
                            promise = newPromise;
                        }
                    }

                    return promise;
                },

                _beginAnimateCommands: function _Overlay_beginAnimateCommands() {
                    // Nothing by default
                },

                _getVisibleCommands: function _Overlay_getVisibleCommands(commandSubSet) {
                    var command,
                        commands = commandSubSet,
                        visibleCommands = [];

                    if (!commands) {
                        // Crawl the inner HTML for the commands.
                        commands = this.element.querySelectorAll(".tv-command");
                    }

                    for (var i = 0, len = commands.length; i < len; i++) {
                        command = commands[i].winControl || commands[i];
                        if (!command.hidden) {
                            visibleCommands.push(command);
                        }
                    }

                    return visibleCommands;
                },

                // Once animation is complete, ensure that the commands are display:none
                // and check if there's another animation to start.
                _baseEndAnimateCommands: function _Overlay_baseEndAnimateCommands(hideCommands) {
                    if (this._disposed) {
                        return;
                    }

                    // Update us
                    var count;
                    for (count = 0; count < hideCommands.length; count++) {
                        // Force us back into our appbar so that we can show again correctly
                        hideCommands[count].style.position = "";
                        hideCommands[count].style.top = "";
                        hideCommands[count].style.left = "";
                        hideCommands[count].getBoundingClientRect();
                        // Now make us really hidden
                        hideCommands[count].style.visibility = "hidden";
                        hideCommands[count].style.display = "none";
                        hideCommands[count].style.opacity = 1;
                    }
                    // Done animating
                    this._element.winAnimating = "";

                    this._endAnimateCommands();

                    // Might be something else to do
                    this._checkDoNext();
                },

                _endAnimateCommands: function _Overlay_endAnimateCommands() {
                    // Nothing by default
                },

                // Resolves our commands
                _resolveCommands: function _Overlay_resolveCommands(commands) {
                    // First make sure they're all DOM elements.
                    commands = _resolveElements(commands);

                    // Now make sure they're all in this container
                    var result = {};
                    result.commands = [];
                    result.others = [];
                    var allCommands = this.element.querySelectorAll(".tv-command");
                    var countAll, countIn;
                    for (countAll = 0; countAll < allCommands.length; countAll++) {
                        var found = false;
                        for (countIn = 0; countIn < commands.length; countIn++) {
                            if (commands[countIn] === allCommands[countAll]) {
                                result.commands.push(allCommands[countAll]);
                                commands.splice(countIn, 1);
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            result.others.push(allCommands[countAll]);
                        }
                    }
                    return result;
                },

                // Find siblings, all DOM elements now.
                // Returns all .tv-commands in this Overlay that are NOT in the passed in 'commands' array.
                _findSiblings: function _Overlay_findSiblings(commands) {
                    // Now make sure they're all in this container
                    var siblings = [];
                    var allCommands = this.element.querySelectorAll(".tv-command");
                    var countAll, countIn;
                    for (countAll = 0; countAll < allCommands.length; countAll++) {
                        var found = false;
                        for (countIn = 0; countIn < commands.length; countIn++) {
                            if (commands[countIn] === allCommands[countAll]) {
                                commands.splice(countIn, 1);
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            siblings.push(allCommands[countAll]);
                        }
                    }
                    return siblings;
                },

                _baseResize: function _Overlay_baseResize(event) {
                    // Call specific resize
                    this._resize(event);
                },

                _hideOrDismiss: function _Overlay_hideOrDismiss() {
                    var element = this._element;
                    if (element && _ElementUtilities.hasClass(element, _Constants.settingsFlyoutClass)) {
                        this._dismiss();
                    } else if (element && _ElementUtilities.hasClass(element, _Constants.appBarClass)) {
                        this.close();
                    } else {
                        this.hide();
                    }
                },

                _resize: function _Overlay_resize() {
                    // Nothing by default
                },

                _commandsUpdated: function _Overlay_commandsUpdated() {
                    // Nothing by default
                },

                _checkScrollPosition: function _Overlay_checkScrollPosition() {
                    // Nothing by default
                },

                _showingKeyboard: function _Overlay_showingKeyboard() {
                    // Nothing by default
                },

                _hidingKeyboard: function _Overlay_hidingKeyboard() {
                    // Nothing by default
                },

                // Verify that this HTML AppBar only has AppBar/MenuCommands.
                _verifyCommandsOnly: function _Overlay_verifyCommandsOnly(element, type) {
                    var children = element.children;
                    var commands = new Array(children.length);
                    for (var i = 0; i < children.length; i++) {
                        // If constructed they have tv-command class, otherwise they have data-tv-control
                        if (!_ElementUtilities.hasClass(children[i], "tv-command") &&
                        children[i].getAttribute("data-tv-control") !== type) {
                            // Wasn't tagged with class or AppBar/MenuCommand, not an AppBar/MenuCommand
                            throw new _ErrorFromName("TVJS.UI._Overlay.MustContainCommands", strings.mustContainCommands);
                        } else {
                            // Instantiate the commands.
                            ControlProcessor.processAll(children[i]);
                            commands[i] = children[i].winControl;
                        }
                    }
                    return commands;
                },

                // Sets focus on what we think is the last tab stop. If nothing is focusable will
                // try to set focus on itself.
                _focusOnLastFocusableElementOrThis: function _Overlay_focusOnLastFocusableElementOrThis() {
                    if (!this._focusOnLastFocusableElement()) {
                        // Nothing is focusable.  Set focus to this.
                        _Overlay._trySetActive(this._element);
                    }
                },

                // Sets focus to what we think is the last tab stop. This element must have
                // a firstDiv with tabIndex equal to the lowest tabIndex in the element
                // and a finalDiv with tabIndex equal to the highest tabIndex in the element.
                // Also the firstDiv must be its first child and finalDiv be its last child.
                // Returns true if successful, false otherwise.
                _focusOnLastFocusableElement: function _Overlay_focusOnLastFocusableElement() {
                    if (this._element.firstElementChild) {
                        var oldFirstTabIndex = this._element.firstElementChild.tabIndex;
                        var oldLastTabIndex = this._element.lastElementChild.tabIndex;
                        this._element.firstElementChild.tabIndex = -1;
                        this._element.lastElementChild.tabIndex = -1;

                        var tabResult = _ElementUtilities._focusLastFocusableElement(this._element);

                        if (tabResult) {
                            _Overlay._trySelect(_Global.document.activeElement);
                        }

                        this._element.firstElementChild.tabIndex = oldFirstTabIndex;
                        this._element.lastElementChild.tabIndex = oldLastTabIndex;

                        return tabResult;
                    } else {
                        return false;
                    }
                },


                // Sets focus on what we think is the first tab stop. If nothing is focusable will
                // try to set focus on itself.
                _focusOnFirstFocusableElementOrThis: function _Overlay_focusOnFirstFocusableElementOrThis() {
                    if (!this._focusOnFirstFocusableElement()) {
                        // Nothing is focusable.  Set focus to this.
                        _Overlay._trySetActive(this._element);
                    }
                },

                // Sets focus to what we think is the first tab stop. This element must have
                // a firstDiv with tabIndex equal to the lowest tabIndex in the element
                // and a finalDiv with tabIndex equal to the highest tabIndex in the element.
                // Also the firstDiv must be its first child and finalDiv be its last child.
                // Returns true if successful, false otherwise.
                _focusOnFirstFocusableElement: function _Overlay__focusOnFirstFocusableElement(useSetActive, scroller) {
                    if (this._element.firstElementChild) {
                        var oldFirstTabIndex = this._element.firstElementChild.tabIndex;
                        var oldLastTabIndex = this._element.lastElementChild.tabIndex;
                        this._element.firstElementChild.tabIndex = -1;
                        this._element.lastElementChild.tabIndex = -1;

                        var tabResult = _ElementUtilities._focusFirstFocusableElement(this._element, useSetActive, scroller);

                        if (tabResult) {
                            _Overlay._trySelect(_Global.document.activeElement);
                        }

                        this._element.firstElementChild.tabIndex = oldFirstTabIndex;
                        this._element.lastElementChild.tabIndex = oldLastTabIndex;

                        return tabResult;
                    } else {
                        return false;
                    }
                },

                _writeProfilerMark: function _Overlay_writeProfilerMark(text) {
                }
            },
            {
                // Statics

                _isFlyoutVisible: function () {
                    var flyouts = _Global.document.querySelectorAll(".tv-flyout");
                    for (var i = 0; i < flyouts.length; i++) {
                        var flyoutControl = flyouts[i].winControl;
                        if (flyoutControl && !flyoutControl.hidden) {
                            return true;
                        }
                    }

                    return false;
                },

                // Try to set us as active
                _trySetActive: function (element, scroller) {
                    if (!element || !_Global.document.body || !_Global.document.body.contains(element)) {
                        return false;
                    }
                    if (!_ElementUtilities._setActive(element, scroller)) {
                        return false;
                    }
                    return (element === _Global.document.activeElement);
                },

                // Try to select the text so keyboard can be used.
                _trySelect: function (element) {
                    try {
                        if (element && element.select) {
                            element.select();
                        }
                    } catch (e) { }
                },

                _sizeOfDocument: function () {
                    return {
                        width: _Global.document.documentElement.offsetWidth,
                        height: _Global.document.documentElement.offsetHeight,
                    };
                },

                _getParentControlUsingClassName: function (element, className) {
                    while (element && element !== _Global.document.body) {
                        if (_ElementUtilities.hasClass(element, className)) {
                            return element.winControl;
                        }
                        element = element.parentNode;
                    }
                    return null;
                },

                // Static controller for _Overlay global events registering/unregistering.
                _globalEventListeners: new _GlobalListener(),

                // Show/Hide all bars
                _hideAppBars: function _Overlay_hideAppBars(bars, keyboardInvoked) {
                    var allBarsAnimationPromises = bars.map(function (bar) {
                        bar.close();
                        return bar._animationPromise;
                    });
                    return Promise.join(allBarsAnimationPromises);
                },

                _showAppBars: function _Overlay_showAppBars(bars, keyboardInvoked) {
                    var allBarsAnimationPromises = bars.map(function (bar) {
                        bar._show();
                        return bar._animationPromise;
                    });
                    return Promise.join(allBarsAnimationPromises);
                },

                // WWA Soft Keyboard offsets
                _keyboardInfo: _KeyboardInfo._KeyboardInfo,

                // Padding for IHM timer to allow for first scroll event
                _scrollTimeout: _KeyboardInfo._KeyboardInfo._scrollTimeout,

                // Events
                beforeShow: "beforeshow",
                beforeHide: "beforehide",
                afterShow: "aftershow",
                afterHide: "afterhide",

                commonstrings: {
                    get cannotChangeCommandsWhenVisible() { return "Invalid argument: You must call hide() before changing {0} commands"; },
                    get cannotChangeHiddenProperty() { return "Unable to set hidden property while parent {0} is visible."; }
                },
            });

            _Base.Class.mix(_Overlay, _Control.DOMEventMixin);

            return _Overlay;
        })
    });

});


// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
/// <dictionary>appbar,Flyout,Flyouts,Statics</dictionary>
define('TVJS/Controls/Flyout',[
    'exports',
    '../Core/_Global',
    '../Core/_Base',
    '../Core/_BaseUtils',
    '../Core/_ErrorFromName',
    '../Core/_Events',
    '../Core/_Log',
    '../Core/_Resources',
    '../Animations',
    '../_Signal',
    '../_LightDismissService',
    '../Utilities/_Dispose',
    '../Utilities/_ElementUtilities',
    '../Utilities/_KeyboardBehavior',
    '../Utilities/_Hoverable',
    './Flyout/_Overlay'
], function flyoutInit(exports, _Global, _Base, _BaseUtils, _ErrorFromName, _Events, _Log, _Resources, Animations, _Signal, _LightDismissService, _Dispose, _ElementUtilities, _KeyboardBehavior, _Hoverable, _Overlay) {
    "use strict";

    _Base.Namespace._moduleDefine(exports, "TVJS.UI", {
        /// <field>
        /// <summary locid="TVJS.UI.Flyout">
        /// Displays lightweight UI that is either informational, or requires user interaction.
        /// Unlike a dialog, a Flyout can be light dismissed by clicking or tapping off of it.
        /// </summary>
        /// <compatibleWith platform="Windows" minVersion="8.0"/>
        /// </field>
        /// <name locid="TVJS.UI.Flyout_name">Flyout</name>
        /// <icon src="ui_TVJS.ui.flyout.12x12.png" width="12" height="12" />
        /// <icon src="ui_TVJS.ui.flyout.16x16.png" width="16" height="16" />
        /// <htmlSnippet supportsContent="true"><![CDATA[<div data-tv-control="TVJS.UI.Flyout"></div>]]></htmlSnippet>
        /// <event name="beforeshow" locid="TVJS.UI.Flyout_e:beforeshow">Raised just before showing a flyout.</event>
        /// <event name="aftershow" locid="TVJS.UI.Flyout_e:aftershow">Raised immediately after a flyout is fully shown.</event>
        /// <event name="beforehide" locid="TVJS.UI.Flyout_e:beforehide">Raised just before hiding a flyout.</event>
        /// <event name="afterhide" locid="TVJS.UI.Flyout_e:afterhide">Raised immediately after a flyout is fully hidden.</event>
        /// <part name="flyout" class="tv-flyout" locid="TVJS.UI.Flyout_part:flyout">The Flyout control itself.</part>
        /// <resource type="javascript" src="//TVJS.4.3/js/TVJS.js" shared="true" />
        /// <resource type="css" src="//TVJS.4.3/css/ui-dark.css" shared="true" />
        Flyout: _Base.Namespace._lazy(function () {
            var Key = _ElementUtilities.Key;

            function getDimension(element, property) {
                return _ElementUtilities.convertToPixels(element, _ElementUtilities._getComputedStyle(element, null)[property]);
            }

            function measureElement(element) {
                return {
                    marginTop: getDimension(element, "marginTop"),
                    marginBottom: getDimension(element, "marginBottom"),
                    marginLeft: getDimension(element, "marginLeft"),
                    marginRight: getDimension(element, "marginRight"),
                    totalWidth: _ElementUtilities.getTotalWidth(element),
                    totalHeight: _ElementUtilities.getTotalHeight(element),
                    contentWidth: _ElementUtilities.getContentWidth(element),
                    contentHeight: _ElementUtilities.getContentHeight(element),
                };
            }

            var strings = {
                get ariaLabel() { return _Resources._getTVJSString("ui/flyoutAriaLabel").value; },
                get noAnchor() { return "Invalid argument: Flyout anchor element not found in DOM."; },
                get badPlacement() { return "Invalid argument: Flyout placement should be 'top' (default), 'bottom', 'left', 'right', 'auto', 'autohorizontal', or 'autovertical'."; },
                get badAlignment() { return "Invalid argument: Flyout alignment should be 'center' (default), 'left', or 'right'."; },
                get noCoordinates() { return "Invalid argument: Flyout coordinates must contain a valid x,y pair."; },
            };

            var createEvent = _Events._createEventProperty;

            // _LightDismissableLayer is an ILightDismissable which manages a set of ILightDismissables.
            // It acts as a proxy between the LightDismissService and the light dismissables it manages.
            // It enables multiple dismissables to be above the click eater at the same time.
            var _LightDismissableLayer = _Base.Class.define(function _LightDismissableLayer_ctor(onLightDismiss) {
                this._onLightDismiss = onLightDismiss;
                this._currentlyFocusedClient = null;
                this._clients = []; // Array of ILightDismissables
            }, {
                // Dismissables should call this as soon as they are ready to be shown. More specifically, they should call this:
                //   - After they are in the DOM and ready to receive focus (e.g. style.display cannot be "none")
                //   - Before their entrance animation is played
                shown: function _LightDismissableLayer_shown(client /*: ILightDismissable */) {
                    client._focusable = true;
                    var index = this._clients.indexOf(client);
                    if (index === -1) {
                        this._clients.push(client);
                        client.onShow(this);
                        if (!_LightDismissService.isShown(this)) {
                            _LightDismissService.shown(this);
                        } else {
                            _LightDismissService.updated(this);
                            this._activateTopFocusableClientIfNeeded();
                        }
                    }
                },

                // Dismissables should call this at the start of their exit animation. A "hiding",
                // dismissable will still be rendered with the proper z-index but it will no
                // longer be given focus. Also, focus is synchronously moved out of this dismissable.
                hiding: function _LightDismissableLayer_hiding(client /*: ILightDismissable */) {
                    var index = this._clients.indexOf(client);
                    if (index !== -1) {
                        this._clients[index]._focusable = false;
                        this._activateTopFocusableClientIfNeeded();
                    }
                },

                // Dismissables should call this when they are done being dismissed (i.e. after their exit animation has finished)
                hidden: function _LightDismissableLayer_hidden(client /*: ILightDismissable */) {
                    var index = this._clients.indexOf(client);
                    if (index !== -1) {
                        this._clients.splice(index, 1);
                        client.setZIndex("");
                        client.onHide();
                        if (this._clients.length === 0) {
                            _LightDismissService.hidden(this);
                        } else {
                            _LightDismissService.updated(this);
                            this._activateTopFocusableClientIfNeeded();
                        }
                    }
                },

                keyDown: function _LightDismissableLayer_keyDown(client /*: ILightDismissable */, eventObject) {
                    _LightDismissService.keyDown(this, eventObject);
                },
                keyUp: function _LightDismissableLayer_keyUp(client /*: ILightDismissable */, eventObject) {
                    _LightDismissService.keyUp(this, eventObject);
                },
                keyPress: function _LightDismissableLayer_keyPress(client /*: ILightDismissable */, eventObject) {
                    _LightDismissService.keyPress(this, eventObject);
                },

                // Used by tests.
                clients: {
                    get: function _LightDismissableLayer_clients_get() {
                        return this._clients;
                    }
                },

                _clientForElement: function _LightDismissableLayer_clientForElement(element) {
                    for (var i = this._clients.length - 1; i >= 0; i--) {
                        if (this._clients[i].containsElement(element)) {
                            return this._clients[i];
                        }
                    }
                    return null;
                },

                _focusableClientForElement: function _LightDismissableLayer_focusableClientForElement(element) {
                    for (var i = this._clients.length - 1; i >= 0; i--) {
                        if (this._clients[i]._focusable && this._clients[i].containsElement(element)) {
                            return this._clients[i];
                        }
                    }
                    return null;
                },

                _getTopmostFocusableClient: function _LightDismissableLayer_getTopmostFocusableClient() {
                    for (var i = this._clients.length - 1; i >= 0; i--) {
                        var client = this._clients[i];
                        if (client && client._focusable) {
                            return client;
                        }
                    }
                    return null;
                },

                _activateTopFocusableClientIfNeeded: function _LightDismissableLayer_activateTopFocusableClientIfNeeded() {
                    var topClient = this._getTopmostFocusableClient();
                    if (topClient && _LightDismissService.isTopmost(this)) {
                        // If the last input type was keyboard, use focus() so a keyboard focus visual is drawn.
                        // Otherwise, use setActive() so no focus visual is drawn.
                        var useSetActive = !_KeyboardBehavior._keyboardSeenLast;
                        topClient.onTakeFocus(useSetActive);
                    }
                },

                // ILightDismissable
                //

                setZIndex: function _LightDismissableLayer_setZIndex(zIndex) {
                    this._clients.forEach(function (client, index) {
                        client.setZIndex(zIndex + index);
                    }, this);
                },
                getZIndexCount: function _LightDismissableLayer_getZIndexCount() {
                    return this._clients.length;
                },
                containsElement: function _LightDismissableLayer_containsElement(element) {
                    return !!this._clientForElement(element);
                },
                onTakeFocus: function _LightDismissableLayer_onTakeFocus(useSetActive) {
                    // Prefer the client that has focus
                    var client = this._focusableClientForElement(_Global.document.activeElement);

                    if (!client && this._clients.indexOf(this._currentlyFocusedClient) !== -1 && this._currentlyFocusedClient._focusable) {
                        // Next try the client that had focus most recently
                        client = this._currentlyFocusedClient;
                    }

                    if (!client) {
                        // Finally try the client at the top of the stack
                        client = this._getTopmostFocusableClient();
                    }

                    this._currentlyFocusedClient = client;
                    client && client.onTakeFocus(useSetActive);
                },
                onFocus: function _LightDismissableLayer_onFocus(element) {
                    this._currentlyFocusedClient = this._clientForElement(element);
                    this._currentlyFocusedClient && this._currentlyFocusedClient.onFocus(element);
                },
                onShow: function _LightDismissableLayer_onShow(service /*: ILightDismissService */) { },
                onHide: function _LightDismissableLayer_onHide() {
                    this._currentlyFocusedClient = null;
                },
                onKeyInStack: function _LightDismissableLayer_onKeyInStack(info /*: IKeyboardInfo*/) {
                    // A keyboard event occurred in the light dismiss stack. Notify the flyouts to
                    // give them the opportunity to handle this evnet.
                    var index = this._clients.indexOf(this._currentlyFocusedClient);
                    if (index !== -1) {
                        var clients = this._clients.slice(0, index + 1);
                        for (var i = clients.length - 1; i >= 0 && !info.propagationStopped; i--) {
                            if (clients[i]._focusable) {
                                clients[i].onKeyInStack(info);
                            }
                        }
                    }
                },
                onShouldLightDismiss: function _LightDismissableLayer_onShouldLightDismiss(info) {
                    return _LightDismissService.DismissalPolicies.light(info);
                },
                onLightDismiss: function _LightDismissableLayer_onLightDismiss(info) {
                    this._onLightDismiss(info);
                }
            });

            // Singleton class for managing cascading flyouts
            var _CascadeManager = _Base.Class.define(function _CascadeManager_ctor() {
                var that = this;
                this._dismissableLayer = new _LightDismissableLayer(function _CascadeManager_onLightDismiss(info) {
                    if (info.reason === _LightDismissService.LightDismissalReasons.escape) {
                        that.collapseFlyout(that.getAt(that.length - 1));
                    } else {
                        that.collapseAll();
                    }
                });
                this._cascadingStack = [];
                this._handleKeyDownInCascade_bound = this._handleKeyDownInCascade.bind(this);
                this._inputType = null;
            },
            {
                appendFlyout: function _CascadeManager_appendFlyout(flyoutToAdd) {
                    // PRECONDITION: this.reentrancyLock must be false. appendFlyout should only be called from baseFlyoutShow() which is the function responsible for preventing reentrancy.
                    _Log.log && this.reentrancyLock && _Log.log('_CascadeManager is attempting to append a Flyout through reentrancy.', "TVJS _CascadeManager", "error");

                    if (this.indexOf(flyoutToAdd) < 0) {
                        // IF the anchor element for flyoutToAdd is contained within another flyout,
                        // && that flyout is currently in the cascadingStack, consider that flyout to be the parent of flyoutToAdd:
                        //  Remove from the cascadingStack, any subflyout descendants of the parent flyout.
                        // ELSE flyoutToAdd isn't anchored to any of the Flyouts in the existing cascade
                        //  Collapse the entire cascadingStack to start a new cascade.
                        // FINALLY:
                        //  add flyoutToAdd to the end of the cascading stack. Monitor it for events.

                        var collapseFn = this.collapseAll;
                        if (flyoutToAdd._positionRequest instanceof PositionRequests.AnchorPositioning) {
                            var indexOfParentFlyout = this.indexOfElement(flyoutToAdd._positionRequest.anchor);
                            if (indexOfParentFlyout >= 0) {
                                collapseFn = function collapseFn() {
                                    this.collapseFlyout(this.getAt(indexOfParentFlyout + 1));
                                };
                            }
                        }
                        collapseFn.call(this);

                        flyoutToAdd.element.addEventListener("keydown", this._handleKeyDownInCascade_bound, false);
                        this._cascadingStack.push(flyoutToAdd);
                    }
                },
                collapseFlyout: function _CascadeManager_collapseFlyout(flyout) {
                    // Synchronously removes flyout param and its subflyout descendants from the _cascadingStack.
                    // Synchronously calls hide on all removed flyouts.

                    if (!this.reentrancyLock && flyout && this.indexOf(flyout) >= 0) {
                        this.reentrancyLock = true;
                        var signal = new _Signal();
                        this.unlocked = signal.promise;

                        var subFlyout;
                        while (this.length && flyout !== subFlyout) {
                            subFlyout = this._cascadingStack.pop();
                            subFlyout.element.removeEventListener("keydown", this._handleKeyDownInCascade_bound, false);
                            subFlyout._hide(); // We use the reentrancyLock to prevent reentrancy here.
                        }

                        if (this._cascadingStack.length === 0) {
                            // The cascade is empty so clear the input type. This gives us the opportunity
                            // to recalculate the input type when the next cascade starts.
                            this._inputType = null;
                        }

                        this.reentrancyLock = false;
                        this.unlocked = null;
                        signal.complete();
                    }
                },
                flyoutShown: function _CascadeManager_flyoutShown(flyout) {
                    this._dismissableLayer.shown(flyout._dismissable);
                },
                flyoutHiding: function _CascadeManager_flyoutHiding(flyout) {
                    this._dismissableLayer.hiding(flyout._dismissable);
                },
                flyoutHidden: function _CascadeManager_flyoutHidden(flyout) {
                    this._dismissableLayer.hidden(flyout._dismissable);
                },
                collapseAll: function _CascadeManager_collapseAll() {
                    // Empties the _cascadingStack and hides all flyouts.
                    var headFlyout = this.getAt(0);
                    if (headFlyout) {
                        this.collapseFlyout(headFlyout);
                    }
                },
                indexOf: function _CascadeManager_indexOf(flyout) {
                    return this._cascadingStack.indexOf(flyout);
                },
                indexOfElement: function _CascadeManager_indexOfElement(el) {
                    // Returns an index cooresponding to the Flyout in the cascade whose element contains the element in question.
                    // Returns -1 if the element is not contained by any Flyouts in the cascade.
                    var indexOfAssociatedFlyout = -1;
                    for (var i = 0, len = this.length; i < len; i++) {
                        var currentFlyout = this.getAt(i);
                        if (currentFlyout.element.contains(el)) {
                            indexOfAssociatedFlyout = i;
                            break;
                        }
                    }
                    return indexOfAssociatedFlyout;
                },
                length: {
                    get: function _CascadeManager_getLength() {
                        return this._cascadingStack.length;
                    }
                },
                getAt: function _CascadeManager_getAt(index) {
                    return this._cascadingStack[index];
                },
                handleFocusIntoFlyout: function _CascadeManager_handleFocusIntoFlyout(event) {
                    // When a flyout in the cascade recieves focus, we close all subflyouts beneath it.
                    var index = this.indexOfElement(event.target);
                    if (index >= 0) {
                        var subFlyout = this.getAt(index + 1);
                        this.collapseFlyout(subFlyout);
                    }
                },
                // Compute the input type that is associated with the cascading stack on demand. Allows
                // each Flyout in the cascade to adjust its sizing based on the current input type
                // and to do it in a way that is consistent with the rest of the Flyouts in the cascade.
                inputType: {
                    get: function _CascadeManager_inputType_get() {
                        if (!this._inputType) {
                            this._inputType = _KeyboardBehavior._lastInputType;
                        }
                        return this._inputType;
                    }
                },
                // Used by tests.
                dismissableLayer: {
                    get: function _CascadeManager_dismissableLayer_get() {
                        return this._dismissableLayer;
                    }
                },
                _handleKeyDownInCascade: function _CascadeManager_handleKeyDownInCascade(event) {
                    var rtl = _ElementUtilities._getComputedStyle(event.target).direction === "rtl",
                        leftKey = rtl ? Key.rightArrow : Key.leftArrow,
                        target = event.target;

                    if (event.keyCode === leftKey) {
                        // Left key press in a SubFlyout will close that subFlyout and any subFlyouts cascading from it.
                        var index = this.indexOfElement(target);
                        if (index >= 1) {
                            var subFlyout = this.getAt(index);
                            this.collapseFlyout(subFlyout);
                            // Prevent document scrolling
                            event.preventDefault();
                        }
                    } else if (event.keyCode === Key.alt || event.keyCode === Key.F10) {
                        this.collapseAll();
                    }
                }
            });

            var AnimationOffsets = {
                top: { top: "50px", left: "0px", keyframe: "TVJS-showFlyoutTop" },
                bottom: { top: "-50px", left: "0px", keyframe: "TVJS-showFlyoutBottom" },
                left: { top: "0px", left: "50px", keyframe: "TVJS-showFlyoutLeft" },
                right: { top: "0px", left: "-50px", keyframe: "TVJS-showFlyoutRight" },
            };

            var PositionRequests = {
                AnchorPositioning: _Base.Class.define(function AnchorPositioning_ctor(anchor, placement, alignment) {

                    // We want to position relative to an anchor element. Anchor element is required.

                    // Dereference the anchor if necessary
                    if (typeof anchor === "string") {
                        anchor = _Global.document.getElementById(anchor);
                    } else if (anchor && anchor.element) {
                        anchor = anchor.element;
                    }

                    if (!anchor) {
                        // We expect an anchor
                        throw new _ErrorFromName("TVJS.UI.Flyout.NoAnchor", strings.noAnchor);
                    }

                    this.anchor = anchor;
                    this.placement = placement;
                    this.alignment = alignment;
                },
                {
                    getTopLeft: function AnchorPositioning_getTopLeft(flyoutMeasurements, isRtl) {
                        // This determines our positioning.  We have 8 placements, the 1st four are explicit, the last 4 are automatic:
                        // * top - position explicitly on the top of the anchor, shrinking and adding scrollbar as needed.
                        // * bottom - position explicitly below the anchor, shrinking and adding scrollbar as needed.
                        // * left - position left of the anchor, shrinking and adding a vertical scrollbar as needed.
                        // * right - position right of the anchor, shrinking and adding a vertical scroolbar as needed.
                        // * _cascade - Private placement algorithm used by MenuCommand._activateFlyoutCommand.
                        // * auto - Automatic placement.
                        // * autohorizontal - Automatic placement (only left or right).
                        // * autovertical - Automatic placement (only top or bottom).
                        // Auto tests the height of the anchor and the flyout.  For consistency in orientation, we imagine
                        // that the anchor is placed in the vertical center of the display.  If the flyout would fit above
                        // that centered anchor, then we will place the flyout vertically in relation to the anchor, otherwise
                        // placement will be horizontal.
                        // Vertical auto or autovertical placement will be positioned on top of the anchor if room, otherwise below the anchor.
                        //   - this is because touch users would be more likely to obscure flyouts below the anchor.
                        // Horizontal auto or autohorizontal placement will be positioned to the left of the anchor if room, otherwise to the right.
                        //   - this is because right handed users would be more likely to obscure a flyout on the right of the anchor.
                        // All three auto placements will add a vertical scrollbar if necessary.
                        // 

                        var anchorBorderBox;

                        try {
                            // Anchor needs to be in DOM.
                            anchorBorderBox = this.anchor.getBoundingClientRect();
                        }
                        catch (e) {
                            throw new _ErrorFromName("TVJS.UI.Flyout.NoAnchor", strings.noAnchor);
                        }

                        var nextLeft;
                        var nextTop;
                        var doesScroll;
                        var nextAnimOffset;
                        var verticalMarginBorderPadding = (flyoutMeasurements.totalHeight - flyoutMeasurements.contentHeight);
                        var nextContentHeight = flyoutMeasurements.contentHeight;

                        function configureVerticalWithScroll(anchorBorderBox) {
                            // Won't fit top or bottom. Pick the one with the most space and add a scrollbar.
                            if (topHasMoreRoom(anchorBorderBox)) {
                                // Top
                                nextContentHeight = spaceAbove(anchorBorderBox) - verticalMarginBorderPadding;
                                nextTop = _Overlay._Overlay._keyboardInfo._visibleDocTop;
                                nextAnimOffset = AnimationOffsets.top;
                            } else {
                                // Bottom
                                nextContentHeight = spaceBelow(anchorBorderBox) - verticalMarginBorderPadding;
                                nextTop = _Constants.pinToBottomEdge;
                                nextAnimOffset = AnimationOffsets.bottom;
                            }
                            doesScroll = true;
                        }

                        // If the anchor is centered vertically, would the flyout fit above it?
                        function fitsVerticallyWithCenteredAnchor(anchorBorderBox, flyoutMeasurements) {
                            // Returns true if the flyout would always fit at least top 
                            // or bottom of its anchor, regardless of the position of the anchor, 
                            // as long as the anchor never changed its height, nor did the height of 
                            // the visualViewport change.
                            return ((_Overlay._Overlay._keyboardInfo._visibleDocHeight - anchorBorderBox.height) / 2) >= flyoutMeasurements.totalHeight;
                        }

                        function spaceAbove(anchorBorderBox) {
                            return anchorBorderBox.top - _Overlay._Overlay._keyboardInfo._visibleDocTop;
                        }

                        function spaceBelow(anchorBorderBox) {
                            return _Overlay._Overlay._keyboardInfo._visibleDocBottom - anchorBorderBox.bottom;
                        }

                        function topHasMoreRoom(anchorBorderBox) {
                            return spaceAbove(anchorBorderBox) > spaceBelow(anchorBorderBox);
                        }

                        // See if we can fit in various places, fitting in the main view,
                        // ignoring viewport changes, like for the IHM.
                        function fitTop(bottomConstraint, flyoutMeasurements) {
                            nextTop = bottomConstraint - flyoutMeasurements.totalHeight;
                            nextAnimOffset = AnimationOffsets.top;
                            return (nextTop >= _Overlay._Overlay._keyboardInfo._visibleDocTop &&
                                    nextTop + flyoutMeasurements.totalHeight <= _Overlay._Overlay._keyboardInfo._visibleDocBottom);
                        }

                        function fitBottom(topConstraint, flyoutMeasurements) {
                            nextTop = topConstraint;
                            nextAnimOffset = AnimationOffsets.bottom;
                            return (nextTop >= _Overlay._Overlay._keyboardInfo._visibleDocTop &&
                                    nextTop + flyoutMeasurements.totalHeight <= _Overlay._Overlay._keyboardInfo._visibleDocBottom);
                        }

                        function fitLeft(leftConstraint, flyoutMeasurements) {
                            nextLeft = leftConstraint - flyoutMeasurements.totalWidth;
                            nextAnimOffset = AnimationOffsets.left;
                            return (nextLeft >= 0 && nextLeft + flyoutMeasurements.totalWidth <= _Overlay._Overlay._keyboardInfo._visualViewportWidth);
                        }

                        function fitRight(rightConstraint, flyoutMeasurements) {
                            nextLeft = rightConstraint;
                            nextAnimOffset = AnimationOffsets.right;
                            return (nextLeft >= 0 && nextLeft + flyoutMeasurements.totalWidth <= _Overlay._Overlay._keyboardInfo._visualViewportWidth);
                        }

                        function centerVertically(anchorBorderBox, flyoutMeasurements) {
                            nextTop = anchorBorderBox.top + anchorBorderBox.height / 2 - flyoutMeasurements.totalHeight / 2;
                            if (nextTop < _Overlay._Overlay._keyboardInfo._visibleDocTop) {
                                nextTop = _Overlay._Overlay._keyboardInfo._visibleDocTop;
                            } else if (nextTop + flyoutMeasurements.totalHeight >= _Overlay._Overlay._keyboardInfo._visibleDocBottom) {
                                // Flag to pin to bottom edge of visual document.
                                nextTop = _Constants.pinToBottomEdge;
                            }
                        }

                        function alignHorizontally(anchorBorderBox, flyoutMeasurements, alignment) {
                            if (alignment === "center") {
                                nextLeft = anchorBorderBox.left + anchorBorderBox.width / 2 - flyoutMeasurements.totalWidth / 2;
                            } else if (alignment === "left") {
                                nextLeft = anchorBorderBox.left;
                            } else if (alignment === "right") {
                                nextLeft = anchorBorderBox.right - flyoutMeasurements.totalWidth;
                            } else {
                                throw new _ErrorFromName("TVJS.UI.Flyout.BadAlignment", strings.badAlignment);
                            }
                            if (nextLeft < 0) {
                                nextLeft = 0;
                            } else if (nextLeft + flyoutMeasurements.totalWidth >= _Overlay._Overlay._keyboardInfo._visualViewportWidth) {
                                // Flag to pin to right edge of visible document.
                                nextLeft = _Constants.pinToRightEdge;
                            }
                        }

                        var currentAlignment = this.alignment;

                        // Check fit for requested placement, doing fallback if necessary
                        switch (this.placement) {
                            case "top":
                                if (!fitTop(anchorBorderBox.top, flyoutMeasurements)) {
                                    // Didn't fit, needs scrollbar
                                    nextTop = _Overlay._Overlay._keyboardInfo._visibleDocTop;
                                    doesScroll = true;
                                    nextContentHeight = spaceAbove(anchorBorderBox) - verticalMarginBorderPadding;
                                }
                                alignHorizontally(anchorBorderBox, flyoutMeasurements, currentAlignment);
                                break;
                            case "bottom":
                                if (!fitBottom(anchorBorderBox.bottom, flyoutMeasurements)) {
                                    // Didn't fit, needs scrollbar
                                    nextTop = _Constants.pinToBottomEdge;
                                    doesScroll = true;
                                    nextContentHeight = spaceBelow(anchorBorderBox) - verticalMarginBorderPadding;
                                }
                                alignHorizontally(anchorBorderBox, flyoutMeasurements, currentAlignment);
                                break;
                            case "left":
                                if (!fitLeft(anchorBorderBox.left, flyoutMeasurements)) {
                                    // Didn't fit, just shove it to edge
                                    nextLeft = 0;
                                }
                                centerVertically(anchorBorderBox, flyoutMeasurements);
                                break;
                            case "right":
                                if (!fitRight(anchorBorderBox.right, flyoutMeasurements)) {
                                    // Didn't fit, just shove it to edge
                                    nextLeft = _Constants.pinToRightEdge;
                                }
                                centerVertically(anchorBorderBox, flyoutMeasurements);
                                break;
                            case "autovertical":
                                if (!fitTop(anchorBorderBox.top, flyoutMeasurements)) {
                                    // Didn't fit above (preferred), so go below.
                                    if (!fitBottom(anchorBorderBox.bottom, flyoutMeasurements)) {
                                        // Didn't fit, needs scrollbar
                                        configureVerticalWithScroll(anchorBorderBox);
                                    }
                                }
                                alignHorizontally(anchorBorderBox, flyoutMeasurements, currentAlignment);
                                break;
                            case "autohorizontal":
                                if (!fitLeft(anchorBorderBox.left, flyoutMeasurements)) {
                                    // Didn't fit left (preferred), so go right.
                                    if (!fitRight(anchorBorderBox.right, flyoutMeasurements)) {
                                        // Didn't fit,just shove it to edge
                                        nextLeft = _Constants.pinToRightEdge;
                                    }
                                }
                                centerVertically(anchorBorderBox, flyoutMeasurements);
                                break;
                            case "auto":
                                // Auto, if the anchor was in the vertical center of the display would we fit above it?
                                if (fitsVerticallyWithCenteredAnchor(anchorBorderBox, flyoutMeasurements)) {
                                    // It will fit above or below the anchor
                                    if (!fitTop(anchorBorderBox.top, flyoutMeasurements)) {
                                        // Didn't fit above (preferred), so go below.
                                        fitBottom(anchorBorderBox.bottom, flyoutMeasurements);
                                    }
                                    alignHorizontally(anchorBorderBox, flyoutMeasurements, currentAlignment);
                                } else {
                                    // Won't fit above or below, try a side
                                    if (!fitLeft(anchorBorderBox.left, flyoutMeasurements) &&
                                        !fitRight(anchorBorderBox.right, flyoutMeasurements)) {
                                        // Didn't fit left or right either
                                        configureVerticalWithScroll(anchorBorderBox);
                                        alignHorizontally(anchorBorderBox, flyoutMeasurements, currentAlignment);
                                    } else {
                                        centerVertically(anchorBorderBox, flyoutMeasurements);
                                    }
                                }
                                break;
                            case "_cascade":

                                // Vertical Alignment:
                                // PREFERRED:
                                // When there is enough room to align a subMenu to either the top or the bottom of its
                                // anchor element, the subMenu prefers to be top aligned.
                                // FALLBACK:
                                // When there is enough room to bottom align a subMenu but not enough room to top align it, 
                                // then the subMenu will align to the bottom of its anchor element.
                                // LASTRESORT:
                                // When there is not enough room to top align or bottom align the subMenu to its anchor,
                                // then the subMenu will be center aligned to it's anchor's vertical midpoint.
                                if (!fitBottom(anchorBorderBox.top - flyoutMeasurements.marginTop, flyoutMeasurements) && !fitTop(anchorBorderBox.bottom + flyoutMeasurements.marginBottom, flyoutMeasurements)) {
                                    centerVertically(anchorBorderBox, flyoutMeasurements);
                                }

                                // Cascading Menus should overlap their ancestor menu horizontally by 4 pixels and we have a 
                                // unit test to verify that behavior. Because we don't have access to the ancestor flyout we 
                                // need to specify the overlap in terms of our anchor element. There is a 1px border around 
                                // the menu that contains our anchor we need to overlap our anchor by 3px to ensure that we 
                                // overlap the containing Menu by 4px.
                                var horizontalOverlap = 3;

                                // Horizontal Placement:
                                // PREFERRED:
                                // When there is enough room to fit a subMenu on either side of the anchor,
                                // the subMenu prefers to go on the right hand side.
                                // FALLBACK:
                                // When there is only enough room to fit a subMenu on the left side of the anchor,
                                // the subMenu is placed to the left of the parent menu.
                                // LASTRESORT:
                                // When there is not enough room to fit a subMenu on either side of the anchor,
                                // the subMenu is pinned to the right edge of the window.
                                var beginRight = anchorBorderBox.right - flyoutMeasurements.marginLeft - horizontalOverlap;
                                var beginLeft = anchorBorderBox.left + flyoutMeasurements.marginRight + horizontalOverlap;

                                if (isRtl) {
                                    if (!fitLeft(beginLeft, flyoutMeasurements) && !fitRight(beginRight, flyoutMeasurements)) {
                                        // Doesn't fit on either side, pin to the left edge.
                                        nextLeft = 0;
                                        nextAnimOffset = AnimationOffsets.left;
                                    }
                                } else {
                                    if (!fitRight(beginRight, flyoutMeasurements) && !fitLeft(beginLeft, flyoutMeasurements)) {
                                        // Doesn't fit on either side, pin to the right edge of the visible document.
                                        nextLeft = _Constants.pinToRightEdge;
                                        nextAnimOffset = AnimationOffsets.right;
                                    }
                                }

                                break;
                            default:
                                // Not a legal placement value
                                throw new _ErrorFromName("TVJS.UI.Flyout.BadPlacement", strings.badPlacement);
                        }

                        return {
                            left: nextLeft,
                            top: nextTop,
                            animOffset: nextAnimOffset,
                            doesScroll: doesScroll,
                            contentHeight: nextContentHeight,
                            verticalMarginBorderPadding: verticalMarginBorderPadding,
                        };
                    },
                }),
                CoordinatePositioning: _Base.Class.define(function CoordinatePositioning_ctor(coordinates) {
                    // Normalize coordinates since they could be a mouse/pointer event object or an {x,y} pair.
                    if (coordinates.clientX === +coordinates.clientX &&
                        coordinates.clientY === +coordinates.clientY) {

                        var temp = coordinates;

                        coordinates = {
                            x: temp.clientX,
                            y: temp.clientY,
                        };

                    } else if (coordinates.x !== +coordinates.x ||
                        coordinates.y !== +coordinates.y) {

                        // We expect an x,y pair of numbers.
                        throw new _ErrorFromName("TVJS.UI.Flyout.NoCoordinates", strings.noCoordinates);
                    }
                    this.coordinates = coordinates;
                }, {
                    getTopLeft: function CoordinatePositioning_getTopLeft(flyoutMeasurements, isRtl) {
                        // This determines our positioning.
                        // The top left corner of the Flyout border box is rendered at the specified coordinates

                        // Place the top left of the Flyout's border box at the specified coordinates.
                        // If we are in RTL, position the top right of the Flyout's border box instead.
                        var currentCoordinates = this.coordinates;
                        var widthOfBorderBox = (flyoutMeasurements.totalWidth - flyoutMeasurements.marginLeft - flyoutMeasurements.marginRight);
                        var adjustForRTL = isRtl ? widthOfBorderBox : 0;

                        var verticalMarginBorderPadding = (flyoutMeasurements.totalHeight - flyoutMeasurements.contentHeight);
                        var nextContentHeight = flyoutMeasurements.contentHeight;
                        var nextTop = currentCoordinates.y - flyoutMeasurements.marginTop;
                        var nextLeft = currentCoordinates.x - flyoutMeasurements.marginLeft - adjustForRTL;

                        if (nextTop < 0) {
                            // Overran top, pin to top edge.
                            nextTop = 0;
                        } else if (nextTop + flyoutMeasurements.totalHeight > _Overlay._Overlay._keyboardInfo._visibleDocBottom) {
                            // Overran bottom, pin to bottom edge.
                            nextTop = _Constants.pinToBottomEdge;
                        }

                        if (nextLeft < 0) {
                            // Overran left, pin to left edge.
                            nextLeft = 0;
                        } else if (nextLeft + flyoutMeasurements.totalWidth > _Overlay._Overlay._keyboardInfo._visualViewportWidth) {
                            // Overran right, pin to right edge.
                            nextLeft = _Constants.pinToRightEdge;
                        }

                        return {
                            left: nextLeft,
                            top: nextTop,
                            verticalMarginBorderPadding: verticalMarginBorderPadding,
                            contentHeight: nextContentHeight,
                            doesScroll: false,
                            animOffset: AnimationOffsets.top,
                        };
                    },
                }),
            };

            var Flyout = _Base.Class.derive(_Overlay._Overlay, function Flyout_ctor(element, options) {
                /// <signature helpKeyword="TVJS.UI.Flyout.Flyout">
                /// <summary locid="TVJS.UI.Flyout.constructor">
                /// Creates a new Flyout control.
                /// </summary>
                /// <param name="element" type="HTMLElement" domElement="true" locid="TVJS.UI.Flyout.constructor_p:element">
                /// The DOM element that hosts the control.
                /// </param>
                /// <param name="options" type="Object" domElement="false" locid="TVJS.UI.Flyout.constructor_p:options">
                /// The set of properties and values to apply to the new Flyout.
                /// </param>
                /// <returns type="TVJS.UI.Flyout" locid="TVJS.UI.Flyout.constructor_returnValue">The new Flyout control.</returns>
                /// <compatibleWith platform="Windows" minVersion="8.0"/>
                /// </signature>

                // Simplify checking later
                options = options || {};

                // Make sure there's an input element
                this._element = element || _Global.document.createElement("div");
                this._id = this._element.id || _ElementUtilities._uniqueID(this._element);

                this._baseFlyoutConstructor(this._element, options);

                var _elms = this._element.getElementsByTagName("*");
                var firstDiv = this._addFirstDiv();
                firstDiv.tabIndex = _ElementUtilities._getLowestTabIndexInList(_elms);
                var finalDiv = this._addFinalDiv();
                finalDiv.tabIndex = _ElementUtilities._getHighestTabIndexInList(_elms);

                // Handle "esc" & "tab" key presses
                this._element.addEventListener("keydown", this._handleKeyDown, true);

                // TV devices handle actions on keyup
                if (TVJS) {
                    this._element.addEventListener("keyup", this._handleKeyUp, true);
                }

                return this;
            }, {
                _lastMaxHeight: null,

                _baseFlyoutConstructor: function Flyout_baseFlyoutContstructor(element, options) {
                    // Flyout constructor

                    // We have some options with defaults
                    this._placement = "auto";
                    this._alignment = "center";

                    // Call the base overlay constructor helper
                    this._baseOverlayConstructor(element, options);

                    // Start flyouts hidden
                    this._element.style.visibilty = "hidden";
                    this._element.style.display = "none";

                    // Attach our css class
                    _ElementUtilities.addClass(this._element, "tv-flyout");

                    var that = this;
                    // Each flyout has an ILightDismissable that is managed through the
                    // CascasdeManager rather than by the _LightDismissService directly.
                    this._dismissable = new _LightDismissService.LightDismissableElement({
                        element: this._element,
                        tabIndex: this._element.hasAttribute("tabIndex") ? this._element.tabIndex : -1,
                        onLightDismiss: function () {
                            that.hide();
                        },
                        onTakeFocus: function (useSetActive) {
                            if (!that._dismissable.restoreFocus()) {
                                // Make sure the menu has focus, but don't show a focus rect
                                _Overlay._Overlay._trySetActive(that._element);
                            }
                        }
                    });

                    // Make sure we have an ARIA role
                    var role = this._element.getAttribute("role");
                    if (role === null || role === "" || role === undefined) {
                        this._element.setAttribute("role", "dialog");
                    }
                    var label = this._element.getAttribute("aria-label");
                    if (label === null || label === "" || label === undefined) {
                        this._element.setAttribute("aria-label", strings.ariaLabel);
                    }

                    // Base animation is popIn, but our flyout has different arguments
                    this._currentAnimateIn = this._flyoutAnimateIn;
                    this._currentAnimateOut = this._flyoutAnimateOut;

                    _ElementUtilities._addEventListener(this.element, "focusin", this._handleFocusIn.bind(this), false);
                },

                /// <field type="String" locid="TVJS.UI.Flyout.anchor" helpKeyword="TVJS.UI.Flyout.anchor">
                /// Gets or sets the Flyout control's anchor. The anchor element is the HTML element which the Flyout originates from and is positioned relative to.
                /// (This setting can be overridden when you call the show method.)
                /// <compatibleWith platform="Windows" minVersion="8.0"/>
                /// </field>
                anchor: {
                    get: function () {
                        return this._anchor;
                    },
                    set: function (value) {
                        this._anchor = value;
                    }
                },

                /// <field type="String" defaultValue="auto" oamOptionsDatatype="TVJS.UI.Flyout.placement" locid="TVJS.UI.Flyout.placement" helpKeyword="TVJS.UI.Flyout.placement">
                /// Gets or sets the default placement of this Flyout. (This setting can be overridden when you call the show method.)
                /// <compatibleWith platform="Windows" minVersion="8.0"/>
                /// </field>
                placement: {
                    get: function () {
                        return this._placement;
                    },
                    set: function (value) {
                        if (value !== "top" && value !== "bottom" && value !== "left" && value !== "right" && value !== "auto" && value !== "autohorizontal" && value !== "autovertical") {
                            // Not a legal placement value
                            throw new _ErrorFromName("TVJS.UI.Flyout.BadPlacement", strings.badPlacement);
                        }
                        this._placement = value;
                    }
                },

                /// <field type="String" defaultValue="center" oamOptionsDatatype="TVJS.UI.Flyout.alignment" locid="TVJS.UI.Flyout.alignment" helpKeyword="TVJS.UI.Flyout.alignment">
                /// Gets or sets the default alignment for this Flyout. (This setting can be overridden when you call the show method.)
                /// <compatibleWith platform="Windows" minVersion="8.0"/>
                /// </field>
                alignment: {
                    get: function () {
                        return this._alignment;
                    },
                    set: function (value) {
                        if (value !== "right" && value !== "left" && value !== "center") {
                            // Not a legal alignment value
                            throw new _ErrorFromName("TVJS.UI.Flyout.BadAlignment", strings.badAlignment);
                        }
                        this._alignment = value;
                    }
                },

                /// <field type="Boolean" locid="TVJS.UI.Flyout.disabled" helpKeyword="TVJS.UI.Flyout.disabled">Disable a Flyout, setting or getting the HTML disabled attribute.  When disabled the Flyout will no longer display with show(), and will hide if currently visible.</field>
                disabled: {
                    get: function () {
                        // Ensure it's a boolean because we're using the DOM element to keep in-sync
                        return !!this._element.disabled;
                    },
                    set: function (value) {
                        // Force this check into a boolean because our current state could be a bit confused since we tie to the DOM element
                        value = !!value;
                        var oldValue = !!this._element.disabled;
                        if (oldValue !== value) {
                            this._element.disabled = value;
                            if (!this.hidden && this._element.disabled) {
                                this.hide();
                            }
                        }
                    }
                },

                /// <field type="Function" locid="TVJS.UI.Flyout.onbeforeshow" helpKeyword="TVJS.UI.Flyout.onbeforeshow">
                /// Occurs immediately before the control is shown.
                /// </field>
                onbeforeshow: createEvent(_Overlay._Overlay.beforeShow),

                /// <field type="Function" locid="TVJS.UI.Flyout.onaftershow" helpKeyword="TVJS.UI.Flyout.onaftershow">
                /// Occurs immediately after the control is shown.
                /// </field>
                onaftershow: createEvent(_Overlay._Overlay.afterShow),

                /// <field type="Function" locid="TVJS.UI.Flyout.onbeforehide" helpKeyword="TVJS.UI.Flyout.onbeforehide">
                /// Occurs immediately before the control is hidden.
                /// </field>
                onbeforehide: createEvent(_Overlay._Overlay.beforeHide),

                /// <field type="Function" locid="TVJS.UI.Flyout.onafterhide" helpKeyword="TVJS.UI.Flyout.onafterhide">
                /// Occurs immediately after the control is hidden.
                /// </field>
                onafterhide: createEvent(_Overlay._Overlay.afterHide),

                _dispose: function Flyout_dispose() {
                    _Dispose.disposeSubTree(this.element);
                    this._hide();
                    Flyout._cascadeManager.flyoutHidden(this);
                    this.anchor = null;
                },

                show: function (anchor, placement, alignment) {
                    /// <signature helpKeyword="TVJS.UI.Flyout.show">
                    /// <summary locid="TVJS.UI.Flyout.show">
                    /// Shows the Flyout, if hidden, regardless of other states.
                    /// </summary>
                    /// <param name="anchor" type="HTMLElement" domElement="true" locid="TVJS.UI.Flyout.show_p:anchor">
                    /// The DOM element, or ID of a DOM element to anchor the Flyout, overriding the anchor property for this time only.
                    /// </param>
                    /// <param name="placement" type="Object" domElement="false" locid="TVJS.UI.Flyout.show_p:placement">
                    /// The placement of the Flyout to the anchor: 'auto' (default), 'top', 'bottom', 'left', or 'right'.  This parameter overrides the placement property for this show only.
                    /// </param>
                    /// <param name="alignment" type="Object" domElement="false" locid="TVJS.UI.Flyout.show:alignment">
                    /// For 'top' or 'bottom' placement, the alignment of the Flyout to the anchor's edge: 'center' (default), 'left', or 'right'.
                    /// This parameter overrides the alignment property for this show only.
                    /// </param>
                    /// <compatibleWith platform="Windows" minVersion="8.0"/>
                    /// </signature>

                    // Pick up defaults
                    this._positionRequest = new PositionRequests.AnchorPositioning(
                        anchor || this._anchor,
                        placement || this._placement,
                        alignment || this._alignment
                    );

                    this._show();
                },

                _show: function Flyout_show() {
                    this._baseFlyoutShow();
                },

                /// <signature helpKeyword="TVJS.UI.Flyout.showAt">
                /// <summary locid="TVJS.UI.Flyout.showAt">
                /// Shows the Flyout, if hidden, at the specified (x,y) coordinates.
                /// </summary>
                /// <param name="coordinates" type="Object" locid="TVJS.UI.Flyout.showAt_p:coordinates">
                /// An Object specifying the (X,Y) position to render the top left corner of the Flyout. commands to show. 
                /// The coordinates object may be a MouseEventObj, or an Object in the shape of {x:number, y:number}.
                /// </param>
                /// </signature>
                showAt: function Flyout_showAt(coordinates) {

                    this._positionRequest = new PositionRequests.CoordinatePositioning(coordinates);

                    this._show();
                },

                hide: function () {
                    /// <signature helpKeyword="TVJS.UI.Flyout.hide">
                    /// <summary locid="TVJS.UI.Flyout.hide">
                    /// Hides the Flyout, if visible, regardless of other states.
                    /// </summary>
                    /// <compatibleWith platform="Windows" minVersion="8.0"/>
                    /// </signature>
                    // Just wrap the private one, turning off keyboard invoked flag
                    this._hide();
                },

                _hide: function Flyout_hide() {

                    // First close all subflyout descendants in the cascade.
                    // Any calls to collapseFlyout through reentrancy should nop.
                    Flyout._cascadeManager.collapseFlyout(this);

                    if (this._baseHide()) {
                        Flyout._cascadeManager.flyoutHiding(this);
                    }
                },

                _beforeEndHide: function Flyout_beforeEndHide() {
                    Flyout._cascadeManager.flyoutHidden(this);
                },

                _baseFlyoutShow: function Flyout_baseFlyoutShow() {
                    if (this.disabled || this._disposed) {
                        // Don't do anything.
                        return;
                    }

                    // If we're animating (eg baseShow is going to fail), or the cascadeManager is in the middle of 
                    // updating the cascade, then don't mess up our current state.
                    // Add this flyout to the correct position in the cascadingStack, first collapsing flyouts 
                    // in the current stack that are not anchored ancestors to this flyout.
                    Flyout._cascadeManager.appendFlyout(this);

                    // If we're animating (eg baseShow is going to fail), or the cascadeManager is in the 
                    // middle of updating the cascade, then we have to try again later.
                    if (this._element.winAnimating) {
                        // Queue us up to wait for the current animation to finish.
                        // _checkDoNext() is always scheduled after the current animation completes.
                        this._doNext = "show";
                    } else if (Flyout._cascadeManager.reentrancyLock) {
                        // Queue us up to wait for the current animation to finish.
                        // Schedule a call to _checkDoNext() for when the cascadeManager unlocks.
                        this._doNext = "show";
                        var that = this;
                        Flyout._cascadeManager.unlocked.then(function () { that._checkDoNext(); });
                    } else {
                        // We call our base _baseShow to handle the actual animation
                        if (this._baseShow()) {
                            // (_baseShow shouldn't ever fail because we tested winAnimating above).
                            if (!_ElementUtilities.hasClass(this.element, "tv-menu")) {
                                // Verify that the firstDiv is in the correct location.
                                // Move it to the correct location or add it if not.
                                var _elms = this._element.getElementsByTagName("*");
                                var firstDiv = this.element.querySelectorAll(".tv-first");
                                if (this.element.children.length && !_ElementUtilities.hasClass(this.element.children[0], "tv-firstdiv")) {
                                    if (firstDiv && firstDiv.length > 0) {
                                        firstDiv.item(0).parentNode.removeChild(firstDiv.item(0));
                                    }

                                    firstDiv = this._addFirstDiv();
                                }
                                firstDiv.tabIndex = _ElementUtilities._getLowestTabIndexInList(_elms);

                                // Verify that the finalDiv is in the correct location.
                                // Move it to the correct location or add it if not.
                                var finalDiv = this.element.querySelectorAll(".tv-final");
                                if (!_ElementUtilities.hasClass(this.element.children[this.element.children.length - 1], "tv-finaldiv")) {
                                    if (finalDiv && finalDiv.length > 0) {
                                        finalDiv.item(0).parentNode.removeChild(finalDiv.item(0));
                                    }

                                    finalDiv = this._addFinalDiv();
                                }
                                finalDiv.tabIndex = _ElementUtilities._getHighestTabIndexInList(_elms);
                            }

                            Flyout._cascadeManager.flyoutShown(this);
                        }
                    }
                },

                _lightDismiss: function Flyout_lightDismiss() {
                    Flyout._cascadeManager.collapseAll();
                },

                // Find our new flyout position.
                _ensurePosition: function Flyout_ensurePosition() {
                    this._keyboardMovedUs = false;

                    // Remove old height restrictions and scrolling.
                    this._clearAdjustedStyles();

                    this._setAlignment();

                    // Set up the new position, and prep the offset for showPopup.
                    var flyoutMeasurements = measureElement(this._element);
                    var isRtl = _ElementUtilities._getComputedStyle(this._element).direction === "rtl";
                    this._currentPosition = this._positionRequest.getTopLeft(flyoutMeasurements, isRtl);

                    // Adjust position
                    if (this._currentPosition.top < 0) {
                        // Overran bottom, attach to bottom.
                        this._element.style.bottom = _Overlay._Overlay._keyboardInfo._visibleDocBottomOffset + "px";
                        this._element.style.top = "auto";
                    } else {
                        // Normal, set top
                        this._element.style.top = this._currentPosition.top + "px";
                        this._element.style.bottom = "auto";
                    }
                    if (this._currentPosition.left < 0) {
                        // Overran right, attach to right
                        this._element.style.right = "0px";
                        this._element.style.left = "auto";
                    } else {
                        // Normal, set left
                        this._element.style.left = this._currentPosition.left + "px";
                        this._element.style.right = "auto";
                    }

                    // Adjust height/scrollbar
                    if (this._currentPosition.doesScroll) {
                        _ElementUtilities.addClass(this._element, "tv-scrolls");
                        this._lastMaxHeight = this._element.style.maxHeight;
                        this._element.style.maxHeight = this._currentPosition.contentHeight + "px";
                    }

                    // May need to adjust if the IHM is showing.
                    if (_Overlay._Overlay._keyboardInfo._visible) {
                        // Use keyboard logic
                        this._checkKeyboardFit();

                        if (this._keyboardMovedUs) {
                            this._adjustForKeyboard();
                        }
                    }
                },


                _clearAdjustedStyles: function Flyout_clearAdjustedStyles() {
                    // Move to 0,0 in case it is off screen, so that it lays out at a reasonable size
                    this._element.style.top = "0px";
                    this._element.style.bottom = "auto";
                    this._element.style.left = "0px";
                    this._element.style.right = "auto";

                    // Clear height restrictons and scrollbar class
                    _ElementUtilities.removeClass(this._element, "tv-scrolls");
                    if (this._lastMaxHeight !== null) {
                        this._element.style.maxHeight = this._lastMaxHeight;
                        this._lastMaxHeight = null;
                    }

                    // Clear Alignment
                    _ElementUtilities.removeClass(this._element, "tv-rightalign");
                    _ElementUtilities.removeClass(this._element, "tv-leftalign");
                },

                _setAlignment: function Flyout_setAlignment() {
                    // Alignment
                    switch (this._positionRequest.alignment) {
                        case "left":
                            _ElementUtilities.addClass(this._element, "tv-leftalign");
                            break;
                        case "right":
                            _ElementUtilities.addClass(this._element, "tv-rightalign");
                            break;
                        default:
                            break;
                    }
                },

                _showingKeyboard: function Flyout_showingKeyboard(event) {
                    if (this.hidden) {
                        return;
                    }

                    // The only way that we can be showing a keyboard when a flyout is up is because the input was
                    // in the flyout itself, in which case we'll be moving ourselves.  There is no practical way
                    // for the application to override this as the focused element is in our flyout.
                    event.ensuredFocusedElementInView = true;

                    // See if the keyboard is going to force us to move
                    this._checkKeyboardFit();

                    if (this._keyboardMovedUs) {
                        // Pop out immediately, then move to new spot
                        this._element.style.opacity = 0;
                        var that = this;
                        _Global.setTimeout(function () { that._adjustForKeyboard(); that._baseAnimateIn(); }, _Overlay._Overlay._keyboardInfo._animationShowLength);
                    }
                },

                _resize: function Flyout_resize() {
                    // If hidden and not busy animating, then nothing to do
                    if (!this.hidden || this._animating) {

                        // This should only happen if the IHM is dismissing,
                        // the only other way is for viewstate changes, which
                        // would dismiss any flyout.
                        if (this._needToHandleHidingKeyboard) {
                            // Hiding keyboard, update our position, giving the anchor a chance to update first.
                            var that = this;
                            _BaseUtils._setImmediate(function () {
                                if (!that.hidden || that._animating) {
                                    that._ensurePosition();
                                }
                            });
                            this._needToHandleHidingKeyboard = false;
                        }
                    }
                },

                // If you were not pinned to the bottom, you might have to be now.
                _checkKeyboardFit: function Flyout_checkKeyboardFit() {
                    // Special Flyout positioning rules to determine if the Flyout needs to adjust its
                    // position because of the IHM. If the Flyout needs to adjust for the IHM, it will reposition
                    // itself to be pinned to either the top or bottom edge of the visual viewport.
                    // - Too Tall, above top, or below bottom.

                    var keyboardMovedUs = false;
                    var viewportHeight = _Overlay._Overlay._keyboardInfo._visibleDocHeight;
                    var adjustedMarginBoxHeight = this._currentPosition.contentHeight + this._currentPosition.verticalMarginBorderPadding;
                    if (adjustedMarginBoxHeight > viewportHeight) {
                        // The Flyout is now too tall to fit in the viewport, pin to top and adjust height.
                        keyboardMovedUs = true;
                        this._currentPosition.top = _Constants.pinToBottomEdge;
                        this._currentPosition.contentHeight = viewportHeight - this._currentPosition.verticalMarginBorderPadding;
                        this._currentPosition.doesScroll = true;
                    } else if (this._currentPosition.top >= 0 &&
                        this._currentPosition.top + adjustedMarginBoxHeight > _Overlay._Overlay._keyboardInfo._visibleDocBottom) {
                        // Flyout clips the bottom of the viewport. Pin to bottom.
                        this._currentPosition.top = _Constants.pinToBottomEdge;
                        keyboardMovedUs = true;
                    } else if (this._currentPosition.top === _Constants.pinToBottomEdge) {
                        // We were already pinned to the bottom, so our position on screen will change
                        keyboardMovedUs = true;
                    }

                    // Signals use of basic fadein animation
                    this._keyboardMovedUs = keyboardMovedUs;
                },

                _adjustForKeyboard: function Flyout_adjustForKeyboard() {
                    // Keyboard moved us, update our metrics as needed
                    if (this._currentPosition.doesScroll) {
                        // Add scrollbar if we didn't already have scrollsClass
                        if (!this._lastMaxHeight) {
                            _ElementUtilities.addClass(this._element, _Constants.scrollsClass);
                            this._lastMaxHeight = this._element.style.maxHeight;
                        }
                        // Adjust height
                        this._element.style.maxHeight = this._currentPosition.contentHeight + "px";
                    }

                    // Update top/bottom
                    this._checkScrollPosition(true);
                },

                _hidingKeyboard: function Flyout_hidingKeyboard() {
                    // If we aren't visible and not animating, or haven't been repositioned, then nothing to do
                    // We don't know if the keyboard moved the anchor, so _keyboardMovedUs doesn't help here
                    if (!this.hidden || this._animating) {

                        // Snap to the final position
                        // We'll either just reveal the current space or resize the window
                        if (_Overlay._Overlay._keyboardInfo._isResized) {
                            // Flag resize that we'll need an updated position
                            this._needToHandleHidingKeyboard = true;
                        } else {
                            // Not resized, update our final position, giving the anchor a chance to update first.
                            var that = this;
                            _BaseUtils._setImmediate(function () {
                                if (!that.hidden || that._animating) {
                                    that._ensurePosition();
                                }
                            });
                        }
                    }
                },

                _checkScrollPosition: function Flyout_checkScrollPosition(showing) {
                    if (this.hidden && !showing) {
                        return;
                    }

                    // May need to adjust top by viewport offset
                    if (this._currentPosition.top < 0) {
                        // Need to attach to bottom
                        this._element.style.bottom = _Overlay._Overlay._keyboardInfo._visibleDocBottomOffset + "px";
                        this._element.style.top = "auto";
                    } else {
                        // Normal, attach to top
                        this._element.style.top = this._currentPosition.top + "px";
                        this._element.style.bottom = "auto";
                    }
                },

                // AppBar flyout animations
                _flyoutAnimateIn: function Flyout_flyoutAnimateIn() {
                    if (this._keyboardMovedUs) {
                        return this._baseAnimateIn();
                    } else {
                        this._element.style.opacity = 1;
                        this._element.style.visibility = "visible";
                        return Animations.showPopup(this._element, this._currentPosition.animOffset);
                    }
                },

                _flyoutAnimateOut: function Flyout_flyoutAnimateOut() {
                    if (this._keyboardMovedUs) {
                        return this._baseAnimateOut();
                    } else {
                        this._element.style.opacity = 0;
                        return Animations.hidePopup(this._element, this._currentPosition.animOffset);
                    }
                },

                // Hide all other flyouts besides this one
                _hideAllOtherFlyouts: function Flyout_hideAllOtherFlyouts(thisFlyout) {
                    var flyouts = _Global.document.querySelectorAll(".tv-flyout");
                    for (var i = 0; i < flyouts.length; i++) {
                        var flyoutControl = flyouts[i].winControl;
                        if (flyoutControl && !flyoutControl.hidden && (flyoutControl !== thisFlyout)) {
                            flyoutControl.hide();
                        }
                    }
                },

                _handleKeyDown: function Flyout_handleKeyDown(event) {
                    if ((event.keyCode === Key.space || event.keyCode === Key.enter)
                         && (this === _Global.document.activeElement)) {
                        event.preventDefault();
                        event.stopPropagation();
                        this.winControl.hide();
                    } else if (event.shiftKey && event.keyCode === Key.tab
                          && this === _Global.document.activeElement
                          && !event.altKey && !event.ctrlKey && !event.metaKey) {
                        event.preventDefault();
                        event.stopPropagation();
                        this.winControl._focusOnLastFocusableElementOrThis();
                    }
                },

                _handleKeyUp: function (event) {
                    if (event.keyCode === 196) { // GamepadB
                        // Show a focus rect on what we move focus to
                        event.preventDefault();
                        event.stopPropagation();
                        this.winControl._keyboardInvoked = true;
                        this.winControl._hide();
                    } else if ((event.keyCode === 195) // GamepadA
                         && (this === document.activeElement)) {
                        event.preventDefault();
                        event.stopPropagation();
                        this.winControl.hide();
                    }
                },

                _handleFocusIn: function Flyout_handleFocusIn(event) {
                    if (!this.element.contains(event.relatedTarget)) {
                        Flyout._cascadeManager.handleFocusIntoFlyout(event);
                    }
                    // Else focus is only moving between elements in the flyout.
                    // Doesn't need to be handled by cascadeManager.
                },

                // Create and add a new first div as the first child
                _addFirstDiv: function Flyout_addFirstDiv() {
                    var firstDiv = _Global.document.createElement("div");
                    firstDiv.className = "tv-firstdiv";
                    firstDiv.style.display = "inline";
                    firstDiv.setAttribute("role", "menuitem");
                    firstDiv.setAttribute("aria-hidden", "true");

                    // add to beginning
                    if (this._element.children[0]) {
                        this._element.insertBefore(firstDiv, this._element.children[0]);
                    } else {
                        this._element.appendChild(firstDiv);
                    }

                    var that = this;
                    _ElementUtilities._addEventListener(firstDiv, "focusin", function () { that._focusOnLastFocusableElementOrThis(); }, false);

                    return firstDiv;
                },

                // Create and add a new final div as the last child
                _addFinalDiv: function Flyout_addFinalDiv() {
                    var finalDiv = _Global.document.createElement("div");
                    finalDiv.className = "tv-finaldiv";
                    finalDiv.style.display = "inline";
                    finalDiv.setAttribute("role", "menuitem");
                    finalDiv.setAttribute("aria-hidden", "true");

                    this._element.appendChild(finalDiv);
                    var that = this;
                    _ElementUtilities._addEventListener(finalDiv, "focusin", function () { that._focusOnFirstFocusableElementOrThis(); }, false);

                    return finalDiv;
                },

                _writeProfilerMark: function Flyout_writeProfilerMark(text) {
                }
            },
            {
                _cascadeManager: new _CascadeManager(),
            });
            return Flyout;
        })
    });

});

// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('ui',[
    'TVJS/Core/_TVJS',
    'TVJS/Controls/IntrinsicControls',
    'TVJS/Controls/Flyout',
    ], function (_TVJS) {
    "use strict";

    return _TVJS;
});

        require(['TVJS/Core/_TVJS', 'ui'], function (_TVJS) {
            // TVJS always publishes itself to global
            if (window.TVJS) {
                if (!_TVJS.DirectionalNavigation && window.TVJS.DirectionalNavigation) {
                    _TVJS.DirectionalNavigation = window.TVJS.DirectionalNavigation;
                }
                if (!_TVJS.SearchBox && window.TVJS.SearchBox) {
                    _TVJS.SearchBox = window.TVJS.SearchBox;
                }
                if (!_TVJS.ScrollViewer && window.TVJS.ScrollViewer) {
                    _TVJS.ScrollViewer = window.TVJS.ScrollViewer;
                }
            }
            globalObject.TVJS = _TVJS;
            if (typeof module !== 'undefined') {
                // This is a CommonJS context so publish to exports
                module.exports = _TVJS;
            }
        });
        return globalObject.TVJS;
    }));
}());

/*! Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information. */
(function () {

    var globalObject = 
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    (function (factory) {
        if (typeof define === 'function' && define.amd) {
            // amd
            define(["./base","./ui"], factory);
        } else {
            if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
                // CommonJS
                factory(require("./base"),require("./ui"));
            } else {
                // No module system
                factory(globalObject.TVJS);
            }
        }
    }(function (TVJS) {


var require = TVJS.Utilities._require;
var define = TVJS.Utilities._define;

        // Function aliases to help with minification
function addClass(element, className) {
    element.classList.add(className);
};
function removeClass(element, className) {
    element.classList.remove(className);
};

// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved. Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
define('TVJS/Controls/MediaPlayer/MediaElementAdapter', [
    'exports',
    '../../Core/_Global',
    '../../Core/_WinRT',
    '../../Core/_Base',
    '../../Core/_ErrorFromName',
    '../../Core/_Resources',
    '../../Utilities/_Control',
    '../../Utilities/_ElementUtilities'
], function mediaElementAdapterInitInit(exports, _Global, _WinRT, _Base, _ErrorFromName, _Resources, _Control, _ElementUtilities) {
    "use strict";

    var utilities = _ElementUtilities;

    var strings = {
        get mediaElementAdapterConstructorNullParameter() { return _Resources._getTVJSString("ui/mediaElementAdapterConstructorNullParameter").value; },
    };

    var MediaElementAdapter = _Base.Class.define(function (mediaPlayer, existingMediaElement) {
        this.baseMediaElementAdapterConstructor(mediaPlayer, existingMediaElement);
    }, {
        _resetInternalState: function () {
            this.liveTime = 0;
            this.isPauseAllowed = true;
            this.isPlayAllowed = true;
            this.isLive = false;
            this.seekAllowed = true;
        },

        // Public Properties
        liveTime: {
            /// <field type="Object" locid="TVJS.UI.MediaElementAdapter.liveTime" helpKeyword="TVJS.UI.MediaElementAdapter.liveTime">
            /// Gets or sets the live time.
            /// </field>

            get: function () {
                return this._liveTime;
            },

            set: function (value) {
                this._liveTime = value;
            },
        },

        live: {
            /// <field type="Boolean" locid="TVJS.UI.MediaElementAdapter.live" helpKeyword="TVJS.UI.MediaElementAdapter.live">
            /// Gets or sets whether the content is a live stream.
            /// </field>

            get: function () {
                return this._isLive;
            },

            set: function (value) {
                this._isLive = value;
            },
        },

        isLive: {
            /// <field type="Boolean" locid="TVJS.UI.MediaElementAdapter.isLive" helpKeyword="TVJS.UI.MediaElementAdapter.isLive">
            /// Exists for legacy compatability.
            /// </field>
            get: function () {
                return this.live;
            },
            set: function (value) {
                this.live = value;
            }
        },

        pauseAllowed: {
            /// <field type="Boolean" locid="TVJS.UI.MediaElementAdapter.pauseAllowed" helpKeyword="TVJS.UI.MediaElementAdapter.pauseAllowed">
            /// Gets or sets a value that specifies whether the pause method can be executed.
            /// </field>

            get: function () {
                return this._pauseAllowed;
            },

            set: function (value) {

                this._pauseAllowed = value;

                if (value) {
                    this._mediaPlayer._playPauseButton.disabled = false;
                    if (this._smtControls) {
                        this._smtControls.isPauseEnabled = true;
                    }
                } else {
                    this._mediaPlayer._playPauseButton.disabled = true;
                    if (this._smtControls) {
                        this._smtControls.isPauseEnabled = false;
                    }
                }
            },
        },

        isPauseAllowed: {
            /// <field type="Boolean" locid="TVJS.UI.MediaElementAdapter.isPauseAllowed" helpKeyword="TVJS.UI.MediaElementAdapter.isPauseAllowed">
            /// Exists for legacy compatability.
            /// </field>
            get: function () {
                return this.pauseAllowed;
            },
            set: function (value) {
                this.pauseAllowed = value;
            }
        },

        playAllowed: {
            /// <field type="Boolean" locid="TVJS.UI.MediaElementAdapter.playAllowed" helpKeyword="TVJS.UI.MediaElementAdapter.playAllowed">
            /// Gets or sets a value that specifies whether the play method can be executed.
            /// </field>

            get: function () {
                return this._playAllowed;
            },

            set: function (value) {

                this._playAllowed = value;

                if (value) {
                    this._mediaPlayer._playPauseButton.disabled = false;
                    if (this._smtControls) {
                        this._smtControls.isPlayEnabled = true;
                    }
                } else {
                    this._mediaPlayer._playPauseButton.disabled = true;
                    if (this._smtControls) {
                        this._smtControls.isPlayEnabled = false;
                    }
                }
            },
        },

        isPlayAllowed: {
            /// <field type="Boolean" locid="TVJS.UI.MediaElementAdapter.isPlayAllowed" helpKeyword="TVJS.UI.MediaElementAdapter.isPlayAllowed">
            /// Exists for legacy compatability.
            /// </field>
            get: function () {
                return this.playAllowed;
            },
            set: function (value) {
                this.playAllowed = value;
            }
        },

        seekAllowed: {
            /// <field type="Boolean" locid="TVJS.UI.MediaElementAdapter.seekAllowed" helpKeyword="TVJS.UI.MediaElementAdapter.seekAllowed">
            /// Gets or sets a value that specifies whether the seek method can be executed.
            /// </field>

            get: function () {
                return this._seekAllowed;
            },

            set: function (value) {

                this._seekAllowed = value;
                var seekEnabled = !!value;

                this._mediaPlayer.chapterSkipBackButtonEnabled = seekEnabled;
                this._mediaPlayer.chapterSkipForwardButtonEnabled = seekEnabled;
                this._mediaPlayer.fastForwardButtonEnabled = seekEnabled;
                this._mediaPlayer.rewindButtonEnabled = seekEnabled;
                this._mediaPlayer.timeSkipBackButtonEnabled = seekEnabled;
                this._mediaPlayer.timeSkipForwardButtonEnabled = seekEnabled;
                if (this._smtControls) {
                    this._smtControls.isFastForwardEnabled = seekEnabled;
                    this._smtControls.isRewindEnabled = seekEnabled;
                }

                if (value) {
                    removeClass(this._mediaPlayer._element, "tv-mediaplayer-seekbar-disabled");
                } else {
                    addClass(this._mediaPlayer._element, "tv-mediaplayer-seekbar-disabled");
                }
            },
        },

        isSeekAllowed: {
            /// <field type="Boolean" locid="TVJS.UI.MediaElementAdapter.isSeekAllowed" helpKeyword="TVJS.UI.MediaElementAdapter.isSeekAllowed">
            /// Exists for legacy compatability.
            /// </field>
            get: function () {
                return this.seekAllowed;
            },
            set: function (value) {
                this.seekAllowed = value;
            }
        },

        mediaElement: {
            /// <field type="Object" locid="TVJS.UI.MediaElementAdapter.mediaElement" helpKeyword="TVJS.UI.MediaElementAdapter.mediaElement">
            /// Gets or sets a value the underlying media element. This is either a video or audio tag.
            /// </field>

            get: function () {
                return this._mediaElement;
            },

            set: function (value) {

                var oldMediaElement = this._mediaElement;
                this._mediaElement = value;

                this._resetInternalState();

                this._mediaPlayer._setupNewMediaElement(this._mediaElement, oldMediaElement);

                if (this._mediaPlayer &&
                    this._mediaPlayer.element) {
                    var dispatchedEvent = _Global.document.createEvent("Event");
                    dispatchedEvent.initEvent("mediaelementchanged", true, false);
                    this._mediaPlayer.element.dispatchEvent(dispatchedEvent);
                }
            },
        },
        baseMediaElementAdapterConstructor: function (mediaPlayer, existingMediaElement) {
            /// <signature helpKeyword="TVJS.UI.MediaElementAdapter.baseMediaElementAdapterConstructor">
            /// <summary locid="TVJS.UI.MediaElementAdapter.baseMediaElementAdapterConstructor">
            /// The base class constructor. If you are deriving from the MediaElementAdapter class, you
            /// must call this base class constructor.
            /// </summary>
            /// </signature>
            this._disposed = false;
            this._liveTime = 0;
            this._pauseAllowed = true;
            this._playAllowed = true;
            this._isLive = false;
            this._seekAllowed = true;
            this._mediaElement = null;
            this._mediaPlayer = null;
            this._smtControls = null;

            if (mediaPlayer) {
                this._mediaPlayer = mediaPlayer;
            } else {
                throw new _ErrorFromName("TVJS.UI.MediaElementAdapter.nullParameter", strings.mediaElementAdapterConstructorNullParameter);
            }

            if (_WinRT.Windows.Media.SystemMediaTransportControls) {
                this._smtControls = _WinRT.Windows.Media.SystemMediaTransportControls.getForCurrentView();
            }

            if (existingMediaElement) {
                this._mediaElement = existingMediaElement;
            } else {
                var containerElement = this._mediaPlayer._element;
                if (containerElement && containerElement.getElementsByTagName) {

                    // We check for whether there is an video tag or audio tag present
                    // in order to determine which mode we're in:
                    //      1. If we find a video tag, we assume we're in video mode.
                    //      2. If not, we check for an audio tag. If we find one, we assume we're in audio mode.
                    //      3. If don't find an audio tag, then we don'd create one and assume the app developer wants to assign one later.
                    this.mediaElement = containerElement.getElementsByTagName("video")[0];

                    if (!this.mediaElement) {
                        this.mediaElement = containerElement.getElementsByTagName("audio")[0];
                    }
                }
            }
        },

        dispose: function () {
            /// <signature helpKeyword="TVJS.UI.MediaElementAdapter.dispose">
            /// <summary locid="TVJS.UI.MediaElementAdapter.dispose">
            /// Releases MediaElementAdapter resources.
            /// </summary>
            /// </signature>

            if (this._disposed) {
                return;
            }
            this._disposed = true;

            if (this._mediaElement) {
                this._mediaElement.removeAttribute("src");
            }

            this._liveTime = null;
            this._mediaElement = null;
            this._mediaPlayer = null;
            this._smtControls = null;
        },

        nextTrack: function () {
            /// <signature helpKeyword="TVJS.UI.MediaElementAdapter.nextTrack">
            /// <summary locid="TVJS.UI.MediaElementAdapter.nextTrack">
            /// Skips to the next track in a playlist. This function is empty by default and
            /// meant to be overridden with a custom implementation.
            /// </summary>
            /// </signature>
        },

        pause: function () {
            /// <signature helpKeyword="TVJS.UI.MediaElementAdapter.pause">
            /// <summary locid="TVJS.UI.MediaElementAdapter.pause">
            /// Pauses the media.
            /// </summary>
            /// </signature>

            if (this._mediaElement &&
                this._pauseAllowed) {
                this._mediaElement.pause();
            }
        },

        play: function () {
            /// <signature helpKeyword="TVJS.UI.MediaElementAdapter.play">
            /// <summary locid="TVJS.UI.MediaElementAdapter.play">
            /// Sets the playbackRate to the default playbackRate for the media and plays the media.
            /// </summary>
            /// </signature>

            if (this._mediaElement &&
                this._playAllowed) {
                this._mediaElement.play();
            }
        },

        previousTrack: function () {
            /// <signature helpKeyword="TVJS.UI.MediaElementAdapter.previousTrack">
            /// <summary locid="TVJS.UI.MediaElementAdapter.previousTrack">
            /// Skips to the previous track in a playlist. This function is empty by default and
            /// meant to be overridden with a custom implementation.
            /// </summary>
            /// </signature>
        },

        seek: function (newTime) {
            /// <signature helpKeyword="TVJS.UI.MediaElementAdapter.seek">
            /// <summary locid="TVJS.UI.MediaElementAdapter.seek">
            /// Navigates to the specified position in the media.
            /// </summary>
            /// </signature>

            if (this._mediaElement &&
                this._seekAllowed) {
                this._mediaElement.currentTime = newTime;
            }
        },

        stop: function () {
            /// <signature helpKeyword="TVJS.UI.MediaElementAdapter.stop">
            /// <summary locid="TVJS.UI.MediaElementAdapter.stop">
            /// Navigates to the specified position in the media.
            /// </summary>
            /// </signature>

            // Stop seeks to the beginning of the media
            if (this._mediaElement &&
                this._seekAllowed) {
                if (this._mediaPlayer) {
                    this._mediaElement.currentTime = this._mediaPlayer.startTime;
                } else {
                    this._mediaElement.currentTime = 0;
                }
                this._mediaElement.pause();
            }
        }
    });

    _Base.Namespace.define("TVJS", {
        MediaElementAdapter: MediaElementAdapter
    });

    return MediaElementAdapter;

});
// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved. Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
define('TVJS/Controls/MediaPlayer/_MediaUI', [
    'exports',
    '../../Core/_BaseCoreUtils',
    '../../Core/_Base'
], function mediaUIInit(exports, _BaseCoreUtils, _Base) {
    "use strict";

    _Base.Namespace._moduleDefine(exports, "TVJS", {
        /// <field locid="TVJS.UI.MediaCommand" helpKeyword="TVJS.UI.MediaCommand">
        /// An enumeration of Media commands that the transport bar buttons support.
        /// </field>
        MediaCommand: {
            /// <field type="String" locid="TVJS.UI.MediaCommand.audioTracks" helpKeyword="TVJS.UI.MediaCommand.audioTracks">
            /// Invokes a menu that allows the viewer to select an audio track.
            /// </field>
            audioTracks: "audioTracks",

            /// <field type="String" locid="TVJS.UI.MediaCommand.cast" helpKeyword="TVJS.UI.MediaCommand.cast">
            /// Play the current media on a remote screen.
            /// </field>
            cast: "cast",

            /// <field type="String" locid="TVJS.UI.MediaCommand.chapterSkipBack" helpKeyword="TVJS.UI.MediaCommand.chapterSkipBack">
            /// Seeks to the previous chapter.
            /// </field>
            chapterSkipBack: "chapterSkipBack",

            /// <field type="String" locid="TVJS.UI.MediaCommand.chapterSkipForward" helpKeyword="TVJS.UI.MediaCommand.chapterSkipForward">
            /// Seeks to the next chapter marker.
            /// </field>
            chapterSkipForward: "chapterSkipForward",

            /// <field type="String" locid="TVJS.UI.MediaCommand.closedcaptions" helpKeyword="TVJS.UI.MediaCommand.closedcaptions">
            /// Invokes a menu that allows the user to choose a closed captions setting.
            /// </field>
            closedCaptions: "closedCaptions",

            /// <field type="String" locid="TVJS.UI.MediaCommand.fastForward" helpKeyword="TVJS.UI.MediaCommand.fastForward">
            /// Increases the playback rate of the media.
            /// </field>
            fastForward: "fastForward",

            /// <field type="String" locid="TVJS.UI.MediaCommand.goToLive" helpKeyword="TVJS.UI.MediaCommand.goToLive">
            /// Navigates to the real-time position in live streamed media.
            /// </field>
            goToLive: "goToLive",

            /// <field type="String" locid="TVJS.UI.MediaCommand.nextTrack" helpKeyword="TVJS.UI.MediaCommand.nextTrack">
            /// Plays the next track.
            /// </field>
            nextTrack: "nextTrack",

            /// <field type="String" locid="TVJS.UI.MediaCommand.pause" helpKeyword="TVJS.UI.MediaCommand.pause">
            /// Pauses the media.
            /// </field>
            pause: "pause",

            /// <field type="String" locid="TVJS.UI.MediaCommand.play" helpKeyword="TVJS.UI.MediaCommand.play">
            /// Sets the playbackRate to the default playbackRate for the media and plays the media.
            /// </field>
            play: "play",

            /// <field type="String" locid="TVJS.UI.MediaCommand.play" helpKeyword="TVJS.UI.MediaCommand.play">
            /// Allows the viewer to select a playback rate for the media.
            /// </field>
            playbackRate: "playbackRate",

            /// <field type="String" locid="TVJS.UI.MediaCommand.playFromBeginning" helpKeyword="TVJS.UI.MediaCommand.playFromBeginning">
            /// Seeks to the beginning of the timeline and starts playing.
            /// </field>
            playFromBeginning: "playFromBeginning",

            /// <field type="String" locid="TVJS.UI.MediaCommand.previousTrack" helpKeyword="TVJS.UI.MediaCommand.previousTrack">
            /// Plays the previous track.
            /// </field>
            previousTrack: "previousTrack",

            /// <field type="String" locid="TVJS.UI.MediaCommand.rewind" helpKeyword="TVJS.UI.MediaCommand.rewind">
            /// Decreases the playbackRate of the media.
            /// </field>
            rewind: "rewind",

            /// <field type="String" locid="TVJS.UI.MediaCommand.seek" helpKeyword="TVJS.UI.MediaCommand.seek">
            /// Navigates to the specified position in the media.
            /// </field>
            seek: "seek",

            /// <field type="String" locid="TVJS.UI.MediaCommand.stop" helpKeyword="TVJS.UI.MediaCommand.stop">
            /// Stops the media.
            /// </field>
            stop: "stop",

            /// <field type="String" locid="TVJS.UI.MediaCommand.timeskipBack" helpKeyword="TVJS.UI.MediaCommand.timeskipBack">
            /// Moves the current timeline position backward by a short interval.
            /// </field>
            timeSkipBack: "timeSkipBack",

            /// <field type="String" locid="TVJS.UI.MediaCommand.timeSkipForward" helpKeyword="TVJS.UI.MediaCommand.timeSkipForward">
            /// Moves the current timeline position forward short interval.
            /// </field>
            timeSkipForward: "timeSkipForward",

            /// <field type="String" locid="TVJS.UI.MediaCommand.zoom" helpKeyword="TVJS.UI.MediaCommand.zoom">
            /// Shows UI that allows the viewer to change the volume.
            /// </field>
            volume: "volume",

            /// <field type="String" locid="TVJS.UI.MediaCommand.zoom" helpKeyword="TVJS.UI.MediaCommand.zoom">
            /// Toggles the display mode between letterbox and native.
            /// </field>
            zoom: "zoom"
        },

        /// <field locid="TVJS.UI.MediaCommand" helpKeyword="TVJS.UI.MediaCommand">
        /// The types of timeline markers supported by the MediaPlayer.
        /// </field>
        MarkerType: {
            /// <field type="String" locid="TVJS.UI.MarkerType.advertisement" helpKeyword="TVJS.UI.MarkerType.advertisement">
            /// The marker represents the beginning of an advertisement.
            /// </field>
            advertisement: "advertisement",

            /// <field type="String" locid="TVJS.UI.MarkerType.chapter" helpKeyword="TVJS.UI.MarkerType.chapter">
            /// The markers represents the beginning of a chapter.
            /// </field>
            chapter: "chapter",

            /// <field type="String" locid="TVJS.UI.MarkerType.custom" helpKeyword="TVJS.UI.MarkerType.custom">
            /// The markers represents a custom event.
            /// </field>
            custom: "custom"
        }
    });
});

define('require-style!less/styles-mediaplayer',[],function(){});

define('require-style!less/colors-mediaplayer',[],function(){});
// Copyright (c) Microsoft Open Technologies, Inc.  All Rights Reserved. Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// Note: We should not call the API directly from mediaElement object.We should always call those API (like play, pause etc) from mediaElementAdapter. Otherwise functionality might breaks
// if someone implemented custom mediaElementAdapters.
// Media Player
define('TVJS/Controls/MediaPlayer', [
    'exports',
    '../Core/_Global',
    '../Core/_WinRT',
    '../Core/_Base',
    '../Core/_BaseUtils',
    '../Core/_Events',
    '../Core/_ErrorFromName',
    '../Res',
    '../Core/_Resources',
    '../Promise',
    '../_Signal',
    '../_Accents',
    '../Animations',
    '../Animations/_TransitionAnimation',
    '../Utilities/_Dispose',
    '../Utilities/_Control',
    '../ControlProcessor',
    '../Controls/MediaPlayer/MediaElementAdapter',
    "../Controls/Flyout",
    '../Utilities/_ElementUtilities',
    '../Controls/MediaPlayer/_MediaUI',
    'require-style!less/styles-mediaplayer',
    'require-style!less/colors-mediaplayer'
], function mediaPlayerInit(exports, _Global, _WinRT, _Base, _BaseUtils, _Events, _ErrorFromName, _Res, _Resources, Promise, _Signal, _Accents, Animations, _TransitionAnimation, _Dispose, _Control, _ControlProcessor, MediaElementAdapter, _Flyout, _ElementUtilities, _MediaUI) {
    "use strict";

    _Accents.createAccentRule(".tv-mediaplayer-seekprogress, .tv-mediaplayer-scrubbing .tv-mediaplayer-seek-mark", [{ name: "background-color", value: _Accents.ColorTypes.accent }]);
    _Accents.createAccentRule(".tv-mediaplayer-seek-mark, html.tv-hoverable .tv-mediaplayer-scrubbing .tv-mediaplayer-seek-mark:hover", [{ name: "border-color", value: _Accents.ColorTypes.accent }]);

    var utilities = _ElementUtilities;
    var mediaCommandEnum = _MediaUI.MediaCommand;
    var markerType = _MediaUI.MarkerType;

    _Base.Namespace.define("TVJS", {

        // MediaPlayer is capitalized to follow TVJS conventions for class names.
        MediaPlayer: _Base.Namespace._lazy(function () {

            var strings = {
                get chapterSkipBackMediaCommandDisplayText() { return _Resources._getTVJSString("ui/chapterSkipBackMediaCommandDisplayText").value; },
                get chapterSkipForwardMediaCommandDisplayText() { return _Resources._getTVJSString("ui/chapterSkipForwardMediaCommandDisplayText").value; },
                get closedCaptionsLabelNone() { return _Resources._getTVJSString("ui/closedCaptionsLabelNone").value; },
                get closedCaptionsMediaCommandDisplayText() { return _Resources._getTVJSString("ui/closedCaptionsMediaCommandDisplayText").value; },
                get fastForwardMediaCommandDisplayText() { return _Resources._getTVJSString("ui/fastForwardMediaCommandDisplayText").value; },
                get fastForwardFeedbackDisplayText() { return _Resources._getTVJSString("ui/fastForwardFeedbackDisplayText").value; },
                get fastForwardFeedbackSlowMotionDisplayText() { return _Resources._getTVJSString("ui/fastForwardFeedbackSlowMotionDisplayText").value; },
                get goToLiveMediaCommandDisplayText() { return _Resources._getTVJSString("ui/goToLiveMediaCommandDisplayText").value; },
                get mediaErrorAborted() { return _Resources._getTVJSString("ui/mediaErrorAborted").value; },
                get mediaErrorNetwork() { return _Resources._getTVJSString("ui/mediaErrorNetwork").value; },
                get mediaErrorDecode() { return _Resources._getTVJSString("ui/mediaErrorDecode").value; },
                get mediaErrorSourceNotSupported() { return _Resources._getTVJSString("ui/mediaErrorSourceNotSupported").value; },
                get mediaErrorUnknown() { return _Resources._getTVJSString("ui/mediaErrorUnknown").value; },
                get mediaPlayerAddMarkerErrorInvalidMarkerType() { return "Invalid argument: The type used is not supported."; },
                get mediaPlayerOverlayActiveOptionIndicator() { return _Resources._getTVJSString("ui/mediaPlayerOverlayActiveOptionIndicator").value; },
                get mediaPlayerLayvolumeoutUnsupportedValue() { return "Invalid argument: The value for XboxJS.UI.MediaPlayer.layout is not supported."; },
                get mediaPlayerInvalidTimeValue() { return "Invalid argument: Time must be a number."; },
                get mediaPlayerNullContentType() { return "Invalid argument: contentType cannot be null."; },
                get unSupportedOperation() { return "UnSupported Operation: Cannot possible set the compact after setting Commands property"; },
                get mediaPlayerNullMetadata() { return "Invalid argument: metadata cannot be null."; },
                get mediaPlayerSetContentMetadataInvalidContentRating() { return "Invalid argument: contentRating is empty or incorrectly formatted."; },
                get nextTrackMediaCommandDisplayText() { return _Resources._getTVJSString("ui/nextTrackMediaCommandDisplayText").value; },
                get playbackRateHalfSpeedLabel() { return _Resources._getTVJSString("ui/playbackRateHalfSpeedLabel").value; },
                get playbackRateNormalSpeedLabel() { return _Resources._getTVJSString("ui/playbackRateNormalSpeedLabel").value; },
                get playbackRateOneAndHalfSpeedLabel() { return _Resources._getTVJSString("ui/playbackRateOneAndHalfSpeedLabel").value; },
                get playbackRateDoubleSpeedLabel() { return _Resources._getTVJSString("ui/playbackRateDoubleSpeedLabel").value; },
                get playMediaCommandDisplayText() { return _Resources._getTVJSString("ui/playMediaCommandDisplayText").value; },
                get playFromBeginningMediaCommandDisplayText() { return _Resources._getTVJSString("ui/playMediaCommandDisplayText").value; },
                get pauseMediaCommandDisplayText() { return _Resources._getTVJSString("ui/pauseMediaCommandDisplayText").value; },
                get previousTrackMediaCommandDisplayText() { return _Resources._getTVJSString("ui/playFromBeginningMediaCommandDisplayText").value; },
                get replayMediaCommandDisplayText() { return _Resources._getTVJSString("ui/replayMediaCommandDisplayText").value; },
                get rewindMediaCommandDisplayText() { return _Resources._getTVJSString("ui/rewindMediaCommandDisplayText").value; },
                get rewindFeedbackDisplayText() { return _Resources._getTVJSString("ui/rewindFeedbackDisplayText").value; },
                get rewindFeedbackSlowMotionDisplayText() { return _Resources._getTVJSString("ui/rewindFeedbackSlowMotionDisplayText").value; },
                get stopMediaCommandDisplayText() { return _Resources._getTVJSString("ui/stopMediaCommandDisplayText").value; },
                get timeSeparator() { return _Resources._getTVJSString("ui/timeSeparator").value; },
                get timeSkipBackMediaCommandDisplayText() { return _Resources._getTVJSString("ui/timeSkipBackMediaCommandDisplayText").value; },
                get timeSkipForwardMediaCommandDisplayText() { return _Resources._getTVJSString("ui/timeSkipForwardMediaCommandDisplayText").value; },
                get mediaPlayerAudioTracksButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerAudioTracksButtonLabel").value; },
                get mediaPlayerStopButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerStopButtonLabel").value; },
                get mediaPlayerPreviousTrackButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerPreviousTrackButtonLabel").value; },
                get mediaPlayerPlayFromBeginningButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerPlayFromBeginningButtonLabel").value; },
                get mediaPlayerChapterSkipBackButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerChapterSkipBackButtonLabel").value; },
                get mediaPlayerRewindButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerRewindButtonLabel").value; },
                get mediaPlayerTimeSkipBackButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerTimeSkipBackButtonLabel").value; },
                get mediaPlayerPlayButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerPlayButtonLabel").value; },
                get mediaPlayerPauseButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerPauseButtonLabel").value; },
                get mediaPlayerPlayRateButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerPlayRateButtonLabel").value; },
                get mediaPlayerTimeSkipForwardButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerTimeSkipForwardButtonLabel").value; },
                get mediaPlayerFastForwardButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerFastForwardButtonLabel").value; },
                get mediaPlayerChapterSkipForwardButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerChapterSkipForwardButtonLabel").value; },
                get mediaPlayerNextTrackButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerNextTrackButtonLabel").value; },
                get mediaPlayerClosedCaptionsButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerClosedCaptionsButtonLabel").value; },
                get mediaPlayerZoomButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerZoomButtonLabel").value; },
                get mediaPlayerLiveButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerLiveButtonLabel").value; },
                get mediaPlayerToggleSnapButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerToggleSnapButtonLabel").value; },
                get mediaPlayerCastButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerCastButtonLabel").value; },
                get mediaPlayerVolumeButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerVolumeButtonLabel").value; },
                get mediaPlayerFullscreenButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerFullscreenButtonLabel").value; },
                get mediaPlayerExitFullscreenButtonLabel() { return _Resources._getTVJSString("ui/mediaPlayerFullscreenButtonLabel").value; }
            };

            // If we are running in an iFrame, then wuiv should be undefined. Otherwise there will be an exception.
            var wuiv = _WinRT.Windows.UI.ViewManagement;

            var MediaPlayer = _Base.Class.define(function (element, options) {
                /// <signature helpKeyword="TVJS.MediaPlayer.MediaPlayer">
                /// <summary locid="TVJS.MediaPlayer.constructor">
                /// Creates a new MediaPlayer.
                /// </summary>
                /// <param name="element" domElement="true" locid="TVJS.MediaPlayer.constructor_p:element">
                /// The DOM element that hosts the MediaPlayer control.
                /// </param>
                /// <param name="options" type="Object" locid="TVJS.MediaPlayer.constructor_p:options">
                /// An object that contains one or more property/value pairs to apply to the new control.
                /// Each property of the options object corresponds to one of the control's properties or events.
                /// </param>
                /// <returns type="TVJS.MediaPlayer" locid="TVJS.MediaPlayer.constructor_returnValue">
                /// The new MediaPlayer.
                /// </returns>
                /// </signature>
                element = element || _Global.document.createElement("div");
                element.tvControl = this;

                addClass(element, "tv-disposable");
                addClass(element, "tv-mediaplayer");
                addClass(element, "tv-mediaplayer-doublerow");

                // Private fields.
                this._adjustedContentType = null;
                this._audioTracksButton = null;
                this._areControlsHiding = false;
                this._busyIndicator = null;
                this._buttonEventSubscriptions = [];
                this._castButton = null;
                this._chapterSkipBackButton = null;
                this._chapterSkipForwardButton = null;
                this._closedCaptionsButton = null;
                this._element = element;
                if (_WinRT.Windows.Media.ContentRestrictions.RatedContentRestrictions) {
                    this._contentRestrictions = new _WinRT.Windows.Media.ContentRestrictions.RatedContentRestrictions();
                }
                this._checkParentalControlsBind = this._checkParentalControls.bind(this);
                this._checkParentalControlsAvailableBind = this._checkParentalControlsAvailable.bind(this);
                this._controlHideTimeout = null;
                this._controls = null;
                this._controlsKeyupInputHandler = null;
                this._currentTimeIndicator = null;
                this._currentTimeVisualElements = null;
                this._currentScrubbingVelocity = 0;
                this._defaultChapterMarkers = [];
                this._disposed = false;
                // The following 3 does*NeedResetting variables are used to keep track of whether or not we to re-initialize endTime, startTime, and
                // the custom markers array to default values. They are initialized to 'true' because when the control is first instantiated, we need 
                // to set default values for these properties.
                this._doesEndTimeNeedResetting = true;
                this._doesStartTimeNeedResetting = true;
                this._doMarkersNeedResetting = true;
                this._endTime = 0;
                // We need to keep track of whether the endTime was reached so we can set button state appropriately
                this._endTimeReached = false;
                this._errorFlyout = null;
                this._audioTracksFlyout = null;
                this._closedCaptionsFlyout = null;
                this._commandsInternal = [];
                this._errorText = null;
                this._fastForwardButton = null;
                this._fastForwardOrRewindTimer = null;
                this._fastForwardOrRewindTimerElapsedTime = 0;
                this._gestureEventSubscriptions = [];
                this._gestureRecognizer = null;
                if (_WinRT.Windows.UI.Input.GestureRecognizer) {
                    this._gestureRecognizer = new _WinRT.Windows.UI.Input.GestureRecognizer();
                    this._gestureRecognizer.gestureSettings =
                        _WinRT.Windows.UI.Input.GestureSettings.manipulationTranslateX |
                        _WinRT.Windows.UI.Input.GestureSettings.manipulationTranslateY;
                }
                this._goToLiveButton = null;
                this._handleFlyoutOpenCallbackBind = null;
                this._handleFlyoutCloseCallbackBind = null;
                this._handleSeekedAfterExitFastForwardOrRewindBind = null;
                this._handleSystemTransportControlsButtonPressedBind = null;
                this._handleloadTextTrackCallbackBind = null;
                this._handleTransportBarButtonFocus = null;
                this._handleVoiceEngagedBind = null;
                this._handleVoiceDisengagedBind = null;
                // We need this extra variable to keep track of when the 1st custom marker is added and the last custom marker is
                // removed. If we didn't care about when the 1st custom marker was added (as opposed to the 2nd), we could just check
                // to see if: this._markers.length > 0;
                this._hasCustomMarkers = false;
                this._inputHandlerClickCallback = null;
                this._inputHandlerPointerDownCallback, null,
                this._inputHandlerPointerMoveCallback = null,
                this._inputHandlerPointerUpCallback = null,
                this._inputHandlerElement = null;
                this._isBusyInternal = false;
                this._isChapterMarkerVisualsDirty = false;
                this._compact = false;
                this._controlsVisible = false;
                this._isInFastForwardOrRewindMode = false;
                this._isFlyoutOpen = false;
                this._fullScreen = false;
                this._handleTimelineArrowKeyDownBind = this._handleTimelineArrowKeyDown.bind(this);
                this._isHandAtLeftEdge = false;
                this._isHandAtRightEdge = false;
                this._isPointerDown = false;
                this._simulatedFastForwardMode = true;
                this._isThumbGrabbed = false;
                this._keydownInputHandler = null;
                this._keyupInputHandler = null;
                this._fullScreenChangeHandler = null;
                this._fullScreenErrorHandler = null;
                this._lastControlsResetTimeStamp = null;
                this._lastFastForwardOrRewindTimerTime = 0;
                this._lastPointerPosition = "0,0";
                this._lastPosition = 0;
                this._markers = [];
                this._mediaCommandFeedbackText = null;
                this._mediaElementAdapter = null;
                this._mediaEventSubscriptions = [];
                this._mediaMetadata = null;
                this._mediaState = {};
                this._metadataTitle = null;
                this._metadataDescription = null;
                this._muteButton = null;
                // This private field tracks the next marker time as an optimization so we don't have to iterate
                // through the entire marker collection when trying to determine which one is next. 
                // We initialize the next two values to '-1' rather than zero; because otherwise a 'markerreached'
                // event will always fire at time zero.
                this._nextCustomMarkerIndex = -1;
                this._nextCustomMarkerTime = -1;
                this._nextTrackButton = null;
                this._onHideControlsCommandInvokedBind = null;
                this._onShowControlsCommandInvokedBind = null;
                this._playbackSpeedIndicator = null;
                this._playbackRateButton = null;
                this._playbackRateFlyout = null;
                this._playPauseButton = null;
                this._playFromBeginningButton = null;
                this._previousPlaybackRate = 0;
                this._previousCustomMarkerIndex = -1;
                this._previousCustomMarkerTime = -1;
                this._previousTrackButton = null;
                this._previousVolumeValue = 0;
                this._progress = null;
                this._progressContainer = null;
                this._updateMediaStateBind = null;
                this._relativeTimelineStartOffset = 0;
                this._rewindButton = null;
                this._seekBar = null;
                this._seekMark = null;
                this._seekTimeIndicator = null;
                this._seekWindowLeftEdgeElement = null;
                this._seekWindowRightEdgeElement = null;
                this._startOffsetX = 0;
                this._startTime = 0;
                this._stopButton = null;
                this._smtControls = null;
                if (_WinRT.Windows.Media.SystemMediaTransportControls) {
                    this._smtControls = _WinRT.Windows.Media.SystemMediaTransportControls.getForCurrentView();
                }
                this._targetPlaybackRate = 0;
                this._targetCurrentTime = 0;
                this._minimumSeekableRangeInPixels = 0;
                this._thumbElement = null;
                this._thumbElementWidthDividedByTwo = 0;
                this._thumbnailEnabled = true;
                this._thumbnailImage = null;
                this._thumbnailImageVisual = null;
                this._thumbImageElementWidthDividedByTwo = 0;
                this._toggleFullScreenButton = null;
                this._timeline = null;
                // This time is in milliseconds. The recommended time for showing
                // progress is for operations that are two seconds or greater. By waiting
                // one second, we can avoid the flicker.
                this._timeBeforeShowingBusyVisual = 1000;
                this._timeFormatter = this._defaultTimeFormatter;
                this._timeRemainingIndicator = null;
                this._timeSeparator = strings.timeSeparator;
                this._timeSkipBackButton = null;
                this._timeSkipForwardButton = null;
                this._totalSeekBarWidth = 0;
                this._totalTimeInternal = 0;
                this._transportControls = null;
                TVJS._tv = _WinRT.Windows.System.Profile.AnalyticsInfo && _WinRT.Windows.System.Profile.AnalyticsInfo.versionInfo.deviceFamily === "Windows.Xbox";
                if (!TVJS._tv) {
                    document.body.classList.add("tv-mediaplayer-mobile");
                }
                this._updateAudioTracksButtonStateBind = this._updateAudioTracksButtonState.bind(this);
                this._updateClosedCaptionsButtonStateBind = this._updateClosedCaptionsButtonState.bind(this);
                this._volumeButton = null;
                this._volumeFlyout = null;
                this._volumeSlider = null;
                this._volumeValue = null;
                this._wasStartTimeSetProgrammatically = false;
                this._wasEndTimeSetProgrammatically = false;
                this._wasDragAndNotClick = false;
                this._wasPausedBeforeScrubbing = false;
                // This variable keeps track of whether the time was clamped to the end time. There are cases where we need the
                // current time can go past the end time. If we perform more than one seek in this state, it is possible to trigger
                // a condition in Media Foundation that results in the ended event not being fired. To work around the issue, we
                // keep track of whether we've already clamped the end time once so that we don't do it more than once and trigger
                // the undesirable condition.
                this._wasTimeClampedToEndTime = false;
                this._windowResizeCallback = null;
                this._zoomButton = null;

                this._originalParent = null;
                this._nextSibiling = null;

                // Test hooks
                this._isTestMode = false;
                // This property tells the MediaPlayer control to skip animations so that tests can run faster
                this._skipAnimations = false;

                // Constants
                // This value is used to determine whether the current time is close enough to the nearest marker
                // that is can be considered at the marker for chapter skipping purposes. See the chapterSkipForward
                // or chapterSkipBack functions for more detail. The value is in seconds.
                this._CHAPTER_SKIP_THRESHOLD = 1;
                this._CONTROLS_AUTO_HIDE_DURATION = 3000;
                // How often the function to update the time display during a fast forward or rewind is called.
                this._FAST_FORWARD_OR_REWIND_TIMER_INTERVAL = 250;
                this._MARKER_PROXIMITY_THRESHOLD = 0.5;
                // We won't add chapter markers for media under 1 minute
                this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS = 60;
                // This number represents the minimum time range where scrubbing is accurate with gesture.
                this._MINIMUM_ACCURATE_SEEKABLE_RANGE = 1800;
                // The minimum distance between consecutive pointer events for the MediaPlayer's
                // scrubbing logic to determine that the user is moving "quickly" across the timeline
                // and does not want the "sticky marker" behavior. Units are in pixels.
                this._MINIMUM_POINTER_DELTA_TO_ENABLE_SNAPPING_TO_NEAREST_MARKER = 4;
                // The amount of space on the left and right of the user that is used for. 
                // using gesture to move the seekable window. Units are in pixels.
                this._GESTURE_REGION_FOR_MOVING_THE_SEEKABLE_WINDOW = 200;
                // We report media state to various listeners via the Playback Manager every 30 seconds.
                this._REPORT_MEDIA_STATE_INTERVAL = 5000;
                this._SEEK_OFFSET = 0.1;
                this._SKIP_BACK_INTERVAL = 8;
                this._SKIP_FORWARD_INTERVAL = 30;
                // If the user is scrubbing and the timeline is within a distance of
                // a marker, the timeline will snap to the marker. The Value is expressed 
                // as a percentage of the total length of the timeline.
                this._SNAP_TO_NEAREST_MARKER_THRESHOLD = 0.005;

                // PlaybackRates
                this._PLAYBACKRATE_FAST_FORWARD_MAX_RATE = 128;
                this._PLAYBACKRATE_FAST_FORWARD_128X = 128;
                this._PLAYBACKRATE_FAST_FORWARD_64X = 64;
                this._PLAYBACKRATE_FAST_FORWARD_32X = 32;
                this._PLAYBACKRATE_FAST_FORWARD_16X = 16;
                this._PLAYBACKRATE_FAST_FORWARD_8X = 8;
                this._PLAYBACKRATE_FAST_FORWARD_4X = 4;
                this._PLAYBACKRATE_FAST_FORWARD_2X = 2;
                this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE = 0.5;
                this._PLAYBACKRATE_PLAYING = 1;
                this._PLAYBACKRATE_NOT_PLAYING = 1;
                this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE = -0.5;
                this._PLAYBACKRATE_REWIND_2X = -2;
                this._PLAYBACKRATE_REWIND_4X = -4;
                this._PLAYBACKRATE_REWIND_8X = -8;
                this._PLAYBACKRATE_REWIND_16X = -16;
                this._PLAYBACKRATE_REWIND_32X = -32;
                this._PLAYBACKRATE_REWIND_64X = -64;
                this._PLAYBACKRATE_REWIND_128X = -128;
                this._PLAYBACKRATE_REWIND_MAX_RATE = -128;

                // MEDIA ELEMENT TAG NAMES
                this._TAG_NAME_AUDIO = "AUDIO";
                this._TAG_NAME_VIDEO = "VIDEO";

                // This is the innerHTML that gets rendered when the MediaPlayer is instantiated.
                this._mediaPlayerHtml = '<div class="tv-mediaplayer-container">' +
                                        '   <div class="tv-mediaplayer-controls tv-mediaplayer-hidden">' +
                                        '       <div class="tv-mediaplayer-mediatitle"></div>' +
                                        '       <div class="tv-mediaplayer-mediadescription"></div>' +
                                        '       <div class="tv-mediaplayer-transportcontrols">' +
                                        '        <div class="tv-mediaplayer-timeline tv-mediaplayer-thumbnailmode" tabindex="0">' +
                                        '            <div class="tv-mediaplayer-progresscontainer">' +
                                        '                <div class="tv-mediaplayer-seekbar">' +
                                        '                  <div class="tv-mediaplayer-buffer"></div>' +
                                        '                  <div class="tv-mediaplayer-seekprogress"></div>' +
                                        '                  <div class="tv-mediaplayer-seekbarvisualelements-container">' +
                                        '                      <div class="tv-mediaplayer-thumb tv-mediaplayer-hidden">' +
                                        '                          <div class="tv-mediaplayer-thumbvisual"></div>' +
                                        '                      </div>' +
                                        '                      <div class="tv-mediaplayer-thumbnail tv-mediaplayer-hidden">' +
                                        '                          <div class="tv-mediaplayer-thumbnailvisual">' +
                                        '                              <div class="tv-mediaplayer-playbackspeedindicator"></div>' +
                                        '                              <div class="tv-mediaplayer-seektimeindicator"></div>' +
                                        '                          </div>' +
                                        '                      </div>' +
                                        '                      <div class="tv-mediaplayer-seek-mark"></div>' +
                                        '                  </div>' +
                                        '                  <div class="tv-mediaplayer-seek-leftboundary tv-invisible"></div>' +
                                        '                  <div class="tv-mediaplayer-seek-rightboundary tv-invisible"></div>' +
                                        '                </div>' +
                                        '                <div class="tv-mediaplayer-currenttimeindicator"></div>' +
                                        '                <div class="tv-mediaplayer-timeremainingindicator"></div>' +
                                        '            </div>' +
                                        '            <div class="tv-mediaplayer-inputfeedback"></div>' +
                                        '         </div>' +
                                        '         <div class="tv-mediaplayer-transportcontrols-commands">' +
                                        '              <button id="tv-mediaplayer-playfrombeginningbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-playfrombeginningbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-replayicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-chapterskipbackbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-chapterskipbackbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-chapterskipbackicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-previoustrackbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-previoustrackbutton tv-mediaplayer-hidden" tabindex="0" >' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-previoustrackicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-stopbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-stopbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-stopicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-timeskipbackbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-timeskipbackbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-timeskipbackicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-playonremotedevicebutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-playonremotedevicebutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-playonremotedeviceicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-zoombutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-zoombutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-zoomicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-audiotracksbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-audiotracksbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-audiotracksicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-rewindbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-rewindbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-rewindicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-playpausebutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-playpausebutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-playpausetogglevisual tv-mediaplayer-playicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-fastforwardbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-fastforwardbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-fastforwardicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-closedcaptionsbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-closedcaptionsbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-closedcaptionsicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-volumebutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-volumebutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-volumeicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-timeskipforwardbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-timeskipforwardbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-timeskipforwardicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-chapterskipforwardbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-chapterskipforwardbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-chapterskipforwardicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-nexttrackbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-nexttrackbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                <span class="tv-mediaplayer-icon tv-mediaplayer-nexttrackicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-playbackratebutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-playbackratebutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-playbackrateicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-livebutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-livebutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-liveicon"></span>' +
                                        '              </button>' +
                                        '              <button id="tv-mediaplayer-fullscreenbutton" class="tv-mediaplayer-transportcontrols-builtinbutton tv-mediaplayer-fullscreenbutton tv-mediaplayer-hidden" tabindex="0">' +
                                        '                 <span class="tv-mediaplayer-icon tv-mediaplayer-fullscreenicon"></span>' +
                                        '              </button>' +
                                        '         </div>' +
                                        '       </div>' +
                                        '    </div>' +
                                        '</div>' +
                                        '<div class="tv-mediaplayer-inputhandler"></div>' +
                                        '<progress class="tv-mediaplayer-busy tv-mediaplayer-hidden tv-ring tv-large"></progress>';

                this._playPauseCompactIndex = 0;
                this._playPauseFullIndex = -1; // default -1 indicates missing PlayPauseButton
                this._isCommandsSetByUser = false;
                var that = this;
                // Note: We need to initialize _keydownInputHandler here, because it is used by fullScreen
                this._keydownInputHandler = function handleKeyDownInput(eventObject) {
                    that._onInputHandlerKeyDown(eventObject);
                };

                this._keyupInputHandler = function handleKeyUpInput(eventObject) {
                    that._onInputHandlerKeyUp(eventObject);
                };

                this._fullScreenChangeHandler = function handleFullScreenChange(eventObject) {

                    var fullScreenElement = _Global.document.fullscreenElement ||
                                                   _Global.document.msFullscreenElement ||
                                                   _Global.document.mozFullScreenElement ||
                                                   _Global.document.webkitFullscreenElement;
                    if (!fullScreenElement && that.isFullScreen) {
                        // make sure MediaPlayer also exits the fullscreen, since we exited the fullscreen thru other means like escape key
                        that.isFullScreen = false;
                    }
                };

                this._fullScreenErrorHandler = function handleFullScreenError(eventObject) {
                    // always reset back to non-fullscreen in case of error, if we already in fullscreen.
                    if (that.isFullScreen) {
                        that.isFullScreen = false;
                    }
                };

                this._controlsKeyupInputHandler = function handleControlsKeyInput(eventObject) {
                    that._onControlsKeyupInputHandler(eventObject);
                };

                this._windowResizeCallback = function handleResize() {
                    if (that._disposed) {
                        return;
                    }

                    var mediaPlayerContainer = that._element.querySelector(".tv-mediaplayer-controls");
                    if (!mediaPlayerContainer) {
                        return;
                    }

                    if (_WinRT.Windows.System.Profile.AnalyticsInfo &&
                        _WinRT.Windows.System.Profile.AnalyticsInfo.versionInfo.deviceFamily === "Windows.Xbox") {
                        addClass(mediaPlayerContainer, "tv-mediaplayer-hidden");

                        // Note: We need to reset this field so the MediaPlayer can maintain the correct
                        // UI state. If _controlsVisible = true, which would be the case if the controls
                        // were up right before the MediaPlayer was snapped then when the MediaPlayer returns
                        // from being snapped _controlsVisible will still be true even though the
                        // controls may or may not be visible.
                        that._controlsVisible = false;
                        that.hideControls();
                    }

                    if (_WinRT.Windows.UI.ViewManagement.ApplicationView) {
                        var applicationView = _WinRT.Windows.UI.ViewManagement.ApplicationView.getForCurrentView();
                        var fullscreenMode = applicationView.isFullScreenMode;
                        // This will cause the MediaPlayer to exit its full screen mode when the user clicks the exit full screen button in the app's title bar."
                        if (!fullscreenMode && that.isFullScreen) {
                            that.isFullScreen = false;
                        }
                    }

                    // Update the controls if they are visible
                    if (that._controlsVisible) {
                        that._updateChapterMarkerVisuals();
                        that._updateTimelineVisuals();
                    }

                    // Update the timeline sizes
                    setImmediate(function () {
                        if (that._disposed) {
                            return;
                        }

                        that._totalSeekBarWidth = that._seekBar.clientWidth;
                        that._seekBarLeftOffset = that._seekBar.offsetLeft;
                        that._thumbElementWidthDividedByTwo = that._thumbElement.clientWidth / 2;
                        that._thumbImageElementWidthDividedByTwo = that._thumbnailImage.clientWidth / 2;
                    }.bind(this));
                };
                utilities._resizeNotifier.subscribe(this._element, this._windowResizeCallback);

                this._initializeDomElements();

                // Set fullscreen
                this._fullScreen = TVJS._tv ? true : false;

                // Set options
                if (options) {
                    var keys = Object.keys(options);
                    for (var i = 0, len = keys.length; i < len; i++) {
                        var key = keys[i];
                        var value = options[key];
                        if (key.length > 2) {
                            var ch1 = key[0];
                            var ch2 = key[1];
                            if ((ch1 === 'o' || ch1 === 'O') && (ch2 === 'n' || ch2 === 'N')) {
                                if (typeof value === "function") {
                                    if (this.addEventListener) {
                                        this.addEventListener(key.substr(2), value);
                                        continue;
                                    }
                                }
                            }
                        }
                        this[key] = value;
                    }
                }

                // Create a default mediaElementAdapter if none was specified
                if (!this._mediaElementAdapter) {
                    this.mediaElementAdapter = new MediaElementAdapter(this, null);
                }

                // Set a timer to report state to SmartGlass periodically
                this._updateMediaStateBind = this._updateMediaState.bind(this);
                this._updateMediaStateTimerCookie = _Global.setInterval(this._updateMediaStateBind, this._REPORT_MEDIA_STATE_INTERVAL);

                if (utilities.hasWinRT) {
                    Windows.UI.WebUI.WebUIApplication.addEventListener(this.element, "resuming", this._checkParentalControlsAvailableBind);
                }

                if (this._contentRestrictions && _WinRT.Windows.Xbox) {
                    this._contentRestrictions.addEventListener("restrictionschanged", this._checkParentalControlsBind, false);
                }

                // Listen for active listening & show the controls and don't hide them until we go out of active listening
                this._onShowControlsCommandInvokedBind = this._onShowControlsCommandInvoked.bind(this);
                this._onHideControlsCommandInvokedBind = this._onHideControlsCommandInvoked.bind(this);

                // Set up the system transport controls event handlers
                if (_WinRT.Windows.Media.SystemMediaTransportControls) {
                    // We need to set the enabled state for stop during construction
                    this._handleSystemTransportControlsButtonPressedBind = this._handleSystemTransportControlsButtonPressed.bind(this);
                    this._handleSystemTransportControlsPropertyChangedBind = this._handleSystemTransportControlsPropertyChanged.bind(this);
                    this._smtControls.addEventListener(this.element, "buttonpressed", this._handleSystemTransportControlsButtonPressedBind);
                    this._smtControls.addEventListener(this.element, "propertychanged", this._handleSystemTransportControlsPropertyChangedBind);
                }

                this._handleloadTextTrackCallbackBind = this._handleloadTextTrackCallback.bind(this);
            },
            {
                // Private properties
                _isBusy: {

                    get: function () {
                        return this._isBusyInternal;
                    },

                    set: function (value) {
                        if (this._disposed) {
                            return;
                        }
                        // we are already in same state.
                        if (this._isBusyInternal === value) {
                            return;
                        }

                        this._isBusyInternal = value;

                        var that = this;
                        if (value) {
                            removeClass(this._busyIndicator, "tv-mediaplayer-hidden");
                            _TransitionAnimation.executeTransition(this._busyIndicator,
                                [{
                                    property: "opacity",
                                    delay: 0,
                                    duration: 200,
                                    timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                    from: 0,
                                    to: 1
                                }]);
                        } else {
                            // The duration of the fade out is set to one second to avoid flicker.
                            Promise.timeout(1000).then(function afterShortDelay() {
                                if (!that._busyIndicator) {
                                    return;
                                }

                                var fadeOutSpinnerAnimationPromise = _TransitionAnimation.executeTransition(that._busyIndicator,
                                    [{
                                        property: "opacity",
                                        delay: 0,
                                        duration: 200,
                                        timing: "cubic-bezier(0.1, 0.9, 0.2, 1)",
                                        from: 1,
                                        to: 0
                                    }]);
                                fadeOutSpinnerAnimationPromise.done(function afterSpinnerFadeOut() {
                                    if (that._busyIndicator) {
                                        addClass(that._busyIndicator, "tv-mediaplayer-hidden");
                                    }
                                });
                            });
                        }

                        this._updateMediaState(false);
                    }
                },

                _totalTime: {

                    get: function () {
                        return this._totalTimeInternal;
                    },

                    set: function (value) {

                        this._totalTimeInternal = value;

                        if (!this._markers.length &&
                            this._totalTimeInternal > this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS) {
                            this._initializeDefaultChapterMarkers();
                        } else {
                            this._defaultChapterMarkers.length = 0;
                        }
                    }
                },

                // Private methods

                // Add an event handler for a button. This method tracks keeps a list of the handlers so they can be unsubscribed later.
                _addButtonEventHandler: function (button, eventName, handler) {

                    if (button) {
                        var that = this;
                        var buttonClickEventSubscription = {
                            button: button,
                            eventName: eventName,
                            handler: function (ev) {
                                handler.call(that, ev);
                                // If the button was clicked via voice, we need to play the press animation
                                if (ev.type === "click" &&
                                    !ev.deviceSessionId) {
                                    var buttonIcon = ev.target.querySelector(".tv-mediaplayer-icon");
                                    if (buttonIcon) {
                                        _TransitionAnimation.executeTransition(buttonIcon, [{
                                            property: _BaseUtils._browserStyleEquivalents["transform"].cssName,
                                            delay: 0,
                                            duration: 100,
                                            timing: "ease-out",
                                            from: "scale(2)",
                                            to: "scale(1)"
                                        }]).then(function () {
                                            if (buttonIcon) {
                                                buttonIcon.removeAttribute("style");
                                            }
                                        });
                                    }
                                }
                            }
                        };

                        button.addEventListener(eventName, buttonClickEventSubscription.handler, false);
                        this._buttonEventSubscriptions.push(buttonClickEventSubscription);
                    }
                },

                // Add a handler for gesture events. This method tracks keeps a list of the handlers so they can be unsubscribed later.
                _addGestureEventHandler: function (owner, eventName, handler) {

                    var that = this;
                    var gestureEventSubscription = {
                        owner: owner,
                        eventName: eventName,
                        handler: function (ev) {
                            handler.call(that, ev);
                        }
                    };

                    owner.addEventListener(eventName, gestureEventSubscription.handler, false);
                    this._gestureEventSubscriptions.push(gestureEventSubscription);
                },

                // Add a media event listener. This method tracks keeps a list of the handlers so they can be unsubscribed later.
                _addMediaEventListener: function (mediaElement, eventName, handler) {

                    if (mediaElement) {
                        mediaElement.addEventListener(eventName, handler, false);
                        if (this._mediaEventSubscriptions) {
                            this._mediaEventSubscriptions.push({ eventName: eventName, handler: handler });
                        }
                    }
                },

                // Checks if the content restrictions are such that the user is allowed to stream video
                _checkParentalControls: function () {
                    // If contentRating has been set to a valid contentRating, then
                    // we check the family settings to see if the user is allowed to
                    // view the content.
                    if (!_WinRT.Windows.Xbox ||
                        !this._mediaMetadata ||
                        !this._mediaMetadata.contentRating ||
                        !this._mediaMetadata.contentType ||
                        !this._mediaMetadata.contentId) {
                        return Promise.wrap(true);
                    }

                    // We need to map the contentType from the one in the TVJS.Data.ContentType
                    // enumeration to the contentType enumeration in the family safety API.
                    var contentType = this._mediaMetadata.contentType;
                    var contentDescription = new _WinRT.Windows.Media.ContentRestrictions.RatedContentDescription(
                        this._mediaMetadata.contentId,
                        this._mediaMetadata.title,
                        null,
                        contentType
                    );

                    contentDescription.category = contentType;
                    var ratingArray = [];
                    if (Array.isArray(this._mediaMetadata.contentRating)) {
                        ratingArray = this._mediaMetadata.contentRating;
                    } else {
                        ratingArray = [this._mediaMetadata.contentRating];
                    }
                    for (var i = 0, len = ratingArray.length; i < len; i++) {
                        contentDescription.ratings[i] = ratingArray[i];
                    }

                    return this._contentRestrictions.requestContentAccessAsync(contentDescription);
                },

                _checkParentalControlsAvailable: function () {
                    if (this._disposed) {
                        return;
                    }

                    var that = this;

                    var hasParentalControlsPrivilege = false;
                    var checkParentalControlsPromise = this._checkParentalControlsBind()
                        .then(
                            function afterParentalControlsCheck(result) {
                                if (result) {
                                    hasParentalControlsPrivilege = true;
                                } else {
                                    hasParentalControlsPrivilege = false;
                                }
                            },
                            function error() {
                                hasParentalControlsPrivilege = false;
                            });

                    checkParentalControlsPromise
                        .done(
                            function afterPriviledgeChecksHaveCompleted() {
                                if (hasParentalControlsPrivilege) {
                                    // No-op - continue video playback
                                } else {
                                    that.pause();
                                    if (that._mediaElementAdapter.mediaElement) {
                                        that._mediaElementAdapter.mediaElement.style.display = "none";
                                    }
                                }
                            });
                },

                // Removes the DOM elements from the timeline that are used to visualize chapter markers.
                // This function does not remove chapter markers from the _markers or _defaultChapterMarkers array.
                _clearChapterMarkerVisuals: function () {

                    // We need to make sure the _element is not null, which is possible if dispose was called
                    if (this._disposed) {
                        return;
                    }

                    this._clearDefaultChapterMarkers();

                    // Remove custom chapter markers if they exist
                    var markersLength = this._markers.length;
                    for (var i = 0; i < markersLength; i++) {

                        if (this._markers[i].markerType === markerType.chapter) {
                            var time = this._markers[i].time;

                            var marker = this._element.querySelector("#ms__marker" + (time.toString()).replace(".", "_"));

                            // Note: This check is necessary, because the markers in the _markers collection do not
                            // always have a corresponding DOM element on the timeline. This is because we add the marker visuals
                            // at a different time than we add them to the _markers array.
                            if (marker &&
                                marker.parentNode) {
                                marker.parentNode.removeChild(marker);
                            }
                        }
                    }
                },

                // Removes the default chapters markers and DOM elements used to represent the default chapter markers.
                _clearDefaultChapterMarkers: function () {

                    if (this._disposed) {
                        return;
                    }

                    var defaultChapterMarkersLength = this._defaultChapterMarkers.length;
                    for (var i = 0; i < defaultChapterMarkersLength; i++) {

                        if (this._defaultChapterMarkers[i].markerType === markerType.chapter) {
                            var time = this._defaultChapterMarkers[i].time;

                            var marker = this._element.querySelector("#ms__marker" + (time.toString()).replace(".", "_"));
                            if (marker &&
                                marker.parentNode) {
                                marker.parentNode.removeChild(marker);
                            }
                        }
                    }

                    this._defaultChapterMarkers.length = 0;
                },

                // Clears the feedback text on the timeline that shows the last executed media command.
                _clearMediaCommandFeedbackText: function () {

                    if (this._mediaCommandFeedbackText) {
                        this._mediaCommandFeedbackText.textContent = "";
                    }
                },

                _clearTimeDisplay: function () {

                    if (this._currentTimeIndicator &&
                        this._timeRemainingIndicator) {
                        this._currentTimeIndicator.textContent = "";
                        this._timeRemainingIndicator.textContent = "";
                        this._seekTimeIndicator.textContent = "";
                    }
                },

                // Formats time in seconds to the hh:mm:ss format.
                _defaultTimeFormatter: function (seconds) {

                    if (isNaN(seconds)) {
                        return "";
                    }

                    var minutes = Math.floor(seconds / 60);
                    seconds = Math.floor(seconds % 60);
                    var hours = Math.floor(minutes / 60);
                    minutes = minutes % 60;

                    var timeString = "";
                    if (hours > 0) {
                        timeString = hours.toString() + this._timeSeparator + this._getTimeString(minutes) + this._timeSeparator + this._getTimeString(seconds);
                    } else {
                        timeString = minutes.toString() + this._timeSeparator + this._getTimeString(seconds);
                    }

                    return timeString;
                },

                // Helper to raise a cancellable event through the containerElement
                _dispatchCancellableEvent: function (eventName, detail) {
                    if (this._disposed) {
                        // We return true because the event will never get raised if the control is disposed.
                        // Therefore the developer could not have prevented the event so the only possible return
                        // value is true.
                        return true;
                    }

                    var dispatchedEvent = _Global.document.createEvent("Event");
                    dispatchedEvent.initEvent(eventName, true, true);

                    if (detail) {
                        dispatchedEvent.detail = detail;
                    }

                    return this._element.dispatchEvent(dispatchedEvent);
                },

                _exitFastForwardOrRewind: function (shouldPlay) {

                    if (!this._isInFastForwardOrRewindMode) {
                        return;
                    }

                    _Global.clearInterval(this._fastForwardOrRewindTimer);
                    this._fastForwardOrRewindTimer = null;
                    this._isInFastForwardOrRewindMode = false;

                    // Hide the thumbnails. We do this regardless of whether thumbnail mode is enabled,
                    // because it will be a no-op if thumbnail mode is disabled.
                    if (this._thumbnailImage) {
                        addClass(this._thumbElement, "tv-mediaplayer-hidden");
                        addClass(this._thumbnailImage, "tv-mediaplayer-hidden");

                        removeClass(this._element, "tv-mediaplayer-scrubbing");
                        removeClass(this._element, "tv-mediaplayer-rewind");
                        removeClass(this._element, "tv-mediaplayer-fastforward");
                    }

                    if (this._simulatedFastForwardMode &&
                        this._mediaElementAdapter &&
                        this._isFastForwardOrRewind(this._targetPlaybackRate)) {
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement &&
                            this._mediaElementAdapter.mediaElement.readyState >= this._MediaReadyState.MediaReadyState_Have_FutureData) {
                            // If we are past the endTime, we need to seek to just before the endTime so the developer can
                            // get the ended event on the mediaElement.
                            this._shouldPlayAfterExitingFastForwardOrRewind = shouldPlay;

                            // Reset the playbackRate to the previous value
                            this._mediaElementAdapter.mediaElement.playbackRate = this._previousPlaybackRate;

                            if (!this._handleSeekedAfterExitFastForwardOrRewindBind) {
                                this._handleSeekedAfterExitFastForwardOrRewindBind = this._handleSeekedAfterExitFastForwardOrRewind.bind(this);
                            }
                            this._mediaElementAdapter.mediaElement.addEventListener("seeked", this._handleSeekedAfterExitFastForwardOrRewindBind, false);
                            if (this._targetCurrentTime > this._endTime - this._SEEK_OFFSET &&
                                !this._wasTimeClampedToEndTime) {
                                this._wasTimeClampedToEndTime = true;
                                this._seekInternal(this._endTime - this._SEEK_OFFSET, false);
                            } else {
                                this._seekInternal(this._targetCurrentTime, false);
                            }
                        }

                        this._targetPlaybackRate = 1;
                    }

                    // Since the auto-hide timer is disabled in fast forward or rewind mode,
                    // we need to manually hide the controls.
                    if (this._controlHideTimeout) {
                        this._removeControlsTimer();
                    }
                },

                // Pads seconds or minutes with leading zeros and returns string format. Seconds or Minutes should be less than 60.
                _getTimeString: function (secondsOrMinutes) {

                    var stringForm = secondsOrMinutes.toString();

                    if (secondsOrMinutes < 10) {
                        stringForm = "0" + stringForm;
                    }

                    return stringForm;
                },

                _getElapsedTimeText: function () {

                    var elapsedTime = "";
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        var currentTime = 0;
                        if (!this._isInFastForwardOrRewindMode) {
                            currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        } else {
                            currentTime = this._targetCurrentTime;
                        }

                        if (currentTime < this._startTime) {
                            currentTime = this._startTime;
                        } else if (currentTime > this._endTime) {
                            currentTime = this._endTime;
                        }

                        elapsedTime = Math.ceil(currentTime - this._startTime);
                    }

                    return this._timeFormatter(elapsedTime);
                },

                _getRemainingTimeText: function () {

                    var remainingTime = "";
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        var currentTime = 0;
                        if (!this._isInFastForwardOrRewindMode) {
                            currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        } else {
                            currentTime = this._targetCurrentTime;
                        }

                        if (currentTime < this._startTime) {
                            currentTime = this._startTime;
                        } else if (currentTime > this._endTime) {
                            currentTime = this._endTime;
                        }

                        remainingTime = Math.ceil(this._endTime - (currentTime - this._startTime));
                    }

                    return this._timeFormatter(remainingTime);
                },

                _handlePointerDown: function (args) {
                    this._handlePointerMove(args);
                },

                // There are cases where the controls can disappear while gesture is engaged. To make sure this never happens,
                // we listen for hover and if the controls are ever not visible, we show them.
                _handlePointerHover: function (args) {
                    this._onShowControlsCommandInvokedBind();
                },
                
                _handlePointerMove: function (args) {
                    // The following data is used for gesture scrubbing
                    if (this._isThumbGrabbed) {
                        if (args.x < 100) {
                            this._isHandAtLeftEdge = true;
                        } else if (args.y > _Global.screen.availWidth - 100) {
                            this._isHandAtRightEdge = true;
                        } else {
                            this._isHandAtLeftEdge = false;
                            this._isHandAtRightEdge = false;
                            this._currentScrubbingVelocity = 0;
                        }
                    }
                },

                _handlePointerUp: function (args) {
                    // We have to ensure the up pointer is sent to IC, so treat it as a move first.
                    this._handlePointerMove(args);
                },

                _handleManipulationStarted: function (args) {
                    this._inputHandlerPointerDownCallback(args);
                },

                _handleManipulationEnd: function (args) {
                    this._inputHandlerPointerUpCallback(args);
                },

                _handleManipulationUpdated: function (args) {
                    this._inputHandlerPointerMoveCallback(args);
                },

                _handleManipulationCompleted: function (args) {
                    this._inputHandlerPointerUpCallback(args);
                },

                _handleBeforeNavigated: function () {
                    this._updateMediaState(true);
                },

                _handleSeekedAfterExitFastForwardOrRewind: function (shouldPlay) {
                    if (this._disposed) {
                        return;
                    }

                    this._mediaElementAdapter.mediaElement.removeEventListener("seeked", this._handleSeekedAfterExitFastForwardOrRewindBind);
                    // Note that we need to reset the playbackRate, because it is possible due to a race condition that the FastForwardRewind timer
                    // will set the playbackRate to zero, before the timer is cleared. This will cause the play to fail and the ended
                    // event will never fire. We always want to set the rate back to the default in this case.
                    if (this._shouldPlayAfterExitingFastForwardOrRewind) {
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.play) {
                            if (this._mediaElementAdapter.mediaElement.playbackRate === 0) {
                                this._mediaElementAdapter.mediaElement.playbackRate = this._mediaElementAdapter.mediaElement.defaultPlaybackRate;
                            }
                            this._mediaElementAdapter.play();
                        }
                    } else {
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.pause) {
                            if (this._mediaElementAdapter.mediaElement.playbackRate === 0) {
                                this._mediaElementAdapter.mediaElement.playbackRate = this._mediaElementAdapter.mediaElement.defaultPlaybackRate;
                            }
                            this._mediaElementAdapter.pause();
                        }
                    }
                },

                // Helper function to call when the start time is reached via a rewind operation
                _handleStartTimeReached: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: We need to subtract an offset to ensure that we never seek past the startTime.
                        // Seeking on the media element is not 100% accurate. It will seek to the nearest frame rather
                        // than an exact timestamp. Therefore if we seek to the startTime, we may seek past the startTime.
                        var media = this._mediaElementAdapter.mediaElement;

                        // We need to make sure that we don't perform a seek if the media src was switch out from under us.
                        // Otherwise there will be an exception.
                        if (!this._isInFastForwardOrRewindMode &&
                            media.readyState >= this._MediaReadyState.MediaReadyState_Have_FutureData) {
                            this._seekInternal(this._startTime + this._SEEK_OFFSET, false);
                        }

                        this._clearMediaCommandFeedbackText();

                        if (media.loop) {
                            this._playFromBeginning();
                        }
                    }
                },

                // Helper function to call when the start time is reached via a fast forward operation or through regular playback
                _handleEndTimeReached: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        !this._endTimeReached) {
                        this._exitFastForwardOrRewind(true);

                        this._endTimeReached = true;

                        // Note: We need to subtract an offset to ensure that we never seek past the endTime.
                        // Seeking on the media element is not 100% accurate. It will seek to the nearest frame rather
                        // than an exact timestamp. Therefore if we seek to the endTime, we may seek past the endTime.
                        var media = this._mediaElementAdapter.mediaElement;

                        // We need to make sure that we don't perform a seek if the media src was switch out from under us.
                        // Otherwise there will be an exception.
                        if (!this._isInFastForwardOrRewindMode &&
                            media.readyState >= this._MediaReadyState.MediaReadyState_Have_FutureData &&
                            !this._wasTimeClampedToEndTime) {
                            this._wasTimeClampedToEndTime = true;
                            this._seekInternal(this._endTime - this._SEEK_OFFSET, false);
                        }

                        if (media.loop) {
                            this._playFromBeginning();
                            this._endTimeReached = false;
                        } else {
                            if (this._wasEndTimeSetProgrammatically) {
                                this.pause();
                            }
                            this._updateMediaState(true);
                        }

                        this._clearMediaCommandFeedbackText();
                    }
                },

                // Handles global speech media-related commands
                _handleSystemTransportControlsButtonPressed: function (ev) {
                    var smtControlsButton = _WinRT.Windows.Media.SystemMediaTransportControlsButton;
                    // get original event
                    ev = ev.detail.originalEvent;
                    switch (ev.button) {
                        case smtControlsButton.play:
                            if (this.playPauseButtonEnabled && this.playPauseButtonVisible) {

                                if (this._mediaElementAdapter.mediaElement.paused) {
                                    this._showPauseButton();
                                    this.play();
                                } else {

                                    // If we are in fast forward / rewind mode, then exit to playing
                                    if (this._isInFastForwardOrRewindMode) {

                                        if (!this._simulatedFastForwardMode) {
                                            this._isInFastForwardOrRewindMode = false;
                                            this._mediaElementAdapter.mediaElement.playbackRate = this._mediaElementAdapter.mediaElement.defaultPlaybackRate;
                                        }

                                        this._showPauseButton();
                                        this.play();
                                    }
                                }
                            }
                            break;
                        case smtControlsButton.pause:
                            if (this.playbackRateButtonEnabled && this.playbackRateButtonVisible) {
                                this._showPlayButton();
                                this.pause();
                            }
                            break;
                        case smtControlsButton.stop:
                            Navigation.back();
                            break;
                        case smtControlsButton.channelUp:
                            // No-op - Windows only
                            break;
                        case smtControlsButton.channelDown:
                            // No-op - Windows only
                            break;
                        case smtControlsButton.back:
                            // No-op - This is handled by the page control
                            break;
                        case smtControlsButton.view:
                            // No-op
                        case smtControlsButton.menu:
                            // No-op
                            break;
                        default:
                            // No-op
                            break;
                    }
                },

                _handleSystemTransportControlsPropertyChanged: function (ev) {
                    // get original event
                    ev = ev.detail.originalEvent;
                    var smtControlsProperty = _WinRT.Windows.Media.SystemMediaTransportControlsProperty;
                    var updater = this._smtControls.displayUpdater;
                    switch (ev.property) {
                        case smtControlsProperty.playbackPosition:
                            if (updater.type === _WinRT.Windows.Media.MediaPlaybackType.video) {
                                var numberOfMilisecondsInASecond = 1000;
                                this._seekInternal(updater.videoProperties.playbackPosition / numberOfMilisecondsInASecond, false);
                            }
                            break;
                        default:
                            break;
                    }
                },

                _handleTimelineArrowKeyDown: function (ev) {
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        (ev.key === "Left" ||
                        ev.key === "Right")) {
                        var newTime = 0;
                        var delta = this._totalTime / 100;
                        if (ev.key === "Left") {
                            newTime = this._mediaElementAdapter.mediaElement.currentTime - delta;
                        } else if (ev.key === "Right") {
                            newTime = this._mediaElementAdapter.mediaElement.currentTime + delta;
                        }
                        this._seekInternal(newTime);
                        // We need to stop propagation otherwise focus will cycle through other toolbar commands
                        // rather than moving the timeline position.
                        ev.stopPropagation();
                    }
                },

                _handleVolumeFlyoutShow: function () {
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        if (this._volumeValue) {
                            this._volumeValue.textContent = this._mediaElementAdapter.mediaElement.volume * 100;
                        }
                        if (this._volumeSlider) {
                            this._volumeSlider.value = this._mediaElementAdapter.mediaElement.volume * 100;
                        }
                    }
                },

                _handleVolumeSliderChange: function () {
                    var newVolume = 0;
                    if (this._volumeSlider) {
                        newVolume = this._volumeSlider.value;
                    }
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        this._mediaElementAdapter.mediaElement.volume = newVolume / 100;
                    }
                    if (this._volumeValue) {
                        this._volumeValue.textContent = newVolume;
                    }
                },

                // Hide the controls bar, this will initiate an slide out + fadeout animation immediately.
                _hideControls: function () {
                    if (!this._controlsVisible ||
                        this._isThumbGrabbed ||
                        this._disposed) {
                        return;
                    }

                    var defaultNotPrevented = this._dispatchCancellableEvent("beforehidecontrols", {});

                    if (defaultNotPrevented) {
                        if (!this._isInFastForwardOrRewindMode && !this._isFlyoutOpen &&
                            !this._areControlsHiding) {

                            this._areControlsHiding = true;
                            this._removeControlsTimer();

                            // Set focus off of the transport controls, otherwise if focus remains on one of
                            // the buttons, when the user presses 'A' to bring up the transport controls they
                            // may invoke one of the transport controls buttons without meaning to.
                            if (_Global.document.activeElement &&
                                this._transportControls.contains(_Global.document.activeElement)) {
                                this._element.focus();
                            }

                            var that = this;
                            this._playHideControlsAnimation()
                                .then(function () {
                                    if (that._disposed) {
                                        return;
                                    }

                                    that._controlsVisible = false;
                                    that._areControlsHiding = false;
                                    addClass(that._controls, "tv-mediaplayer-hidden");
                                    that.dispatchEvent("afterhidecontrols", {});
                                });
                        }
                    } else {
                        // If hiding the controls has been prevented, we need to remove the auto-hide controls timer
                        // otherwise the controls will hide after a period of time.
                        this._removeControlsTimer();
                    }

                    if (!this._wasStartTimeSetProgrammatically &&
                        !this._wasEndTimeSetProgrammatically &&
                        this._markers.length) {
                        this._unsubscribeFromTimeUpdates();
                    }
                },

                _isFastForwardOrRewind: function (playbackRate) {
                    return ((playbackRate !== this._PLAYBACKRATE_PLAYING) && (playbackRate !== this._PLAYBACKRATE_NOT_PLAYING));
                },

                // Returns true if there is a flyout that has focus
                _isFocusOnAVisibleFlyout: function () {
                    var flyouts = _Global.document.querySelectorAll(".tv-mediaplayer-overlay");
                    for (var i = 0, len = flyouts.length; i < len; i++) {
                        var flyoutElement = flyouts[i];
                        if (flyoutElement.contains(_Global.document.activeElement)) {
                            return true;
                        }
                    }

                    return false;
                },

                // Creates a list of chapter markers. This function does not render chapter markers. To do that, call _updateChapterMarkerVisuals.
                // If the media has no chapter markers and is below a certain length (this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS), then we add
                // 11 chapter markers spaced evenly along the timeline. When the user invokes chapter skip back / chapter skip forward, the media
                // will seek to the next / previous chapter marker.
                _initializeChapterMarkers: function (mediaElement) {
                    var textTracks = mediaElement.textTracks;

                    // We need to check if there are any existing chapter markers that were added as text tracks
                    var hasExistingChapterMarkers = false;
                    var textTracksLength = textTracks.length;
                    for (var i = 0; i < textTracksLength; i++) {
                        var currentTextTrack = textTracks[i];
                        if (currentTextTrack.kind === "chapters") {
                            hasExistingChapterMarkers = true;
                            break;
                        }
                    }

                    // We also need to check if there were any chapter markers added by the developer
                    if (!hasExistingChapterMarkers) {
                        var markersLength = this._markers.length;
                        for (var i = 0; i < markersLength; i++) {
                            if (this._markers[i].markerType === markerType.chapter) {
                                hasExistingChapterMarkers = true;
                            }
                        }
                    }

                    if (hasExistingChapterMarkers) {
                        this._initializeCustomChapterMarkers(mediaElement);
                    } else if (this._totalTime > this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS) {
                        this._initializeDefaultChapterMarkers();
                    }
                },

                _handleloadTextTrackCallback: function (eventObject) {
                    var textTrackCueList = eventObject.currentTarget.track.cues;
                    var textTrackCueListLength = textTrackCueList.length;
                    for (var j = 0; j < textTrackCueListLength; j++) {
                        this.addMarker(textTrackCueList[j].startTime, markerType.chapter, textTrackCueList[j].text);
                    }
                },

                _handleFlyoutOpenCallback: function () {
                    // enable the flag to make sure won't hide.
                    this._isFlyoutOpen = true;
                },

                _handleFlyoutCloseCallback: function () {
                    // disable the flag to  hide.
                    this._isFlyoutOpen = false;
                    this._hideControls();
                },

                _initializeCustomChapterMarkers: function (mediaElement) {

                    // Remove default chapter markers
                    this._defaultChapterMarkers.length = 0;
                    var textTracks = mediaElement.textTracks;

                    var tracks = mediaElement.getElementsByTagName("track");
                    var tracksLength = tracks.length;
                    for (var i = 0; i < tracksLength; i++) {
                        if (tracks[i].kind === "chapters") {
                            // Note: We need to mark the track as "hidden" otherwise we will not receive cue-related events.
                            textTracks[i].mode = "hidden";
                            tracks[i].addEventListener("load", this._handleloadTextTrackCallbackBind, false);
                        }
                    }
                    this._isChapterMarkerVisualsDirty = true;
                },

                _initializeDefaultChapterMarkers: function () {

                    // If the chapter skip back and chapter skip forward buttons are not present or hidden then do not create the default chapter markers.
                    // Note: If the buttons are disabled, we should still create the chapter markers, because the buttons may just be temporarily disabled.
                    if ((!this._chapterSkipBackButton ||
                        this._chapterSkipBackButton.hidden) &&
                        (!this._chapterSkipForwardButton ||
                        this._chapterSkipForwardButton.hidden)) {
                        return;
                    }

                    // Remove old default chapter markers
                    this._defaultChapterMarkers.length = 0;

                    var oneTenthOfTotalTime = this._totalTime / 10;

                    // Add the 1st default chapter marker
                    this._defaultChapterMarkers.push({ time: this._startTime, markerType: markerType.chapter, data: {}, extraClass: "tv-mediaplayer-chaptermarker" });

                    // Add default chapter markers spaced evenly every 1/10th of the media
                    var currentMarkerPosition = 0;
                    for (var i = 0; i < 9; i++) {
                        currentMarkerPosition += oneTenthOfTotalTime;
                        this._defaultChapterMarkers.push({ time: currentMarkerPosition, markerType: markerType.chapter, data: {}, extraClass: "tv-mediaplayer-chaptermarker" });
                    }

                    // Add the last default chapter marker
                    this._defaultChapterMarkers.push({ time: this._endTime, markerType: markerType.chapter, data: {}, extraClass: "tv-mediaplayer-chaptermarker" });

                    this._isChapterMarkerVisualsDirty = true;
                },

                _onAudioTracksCommandInvoked: function () {
                    // We don't check in the button is enabled and visible because the button won't show up unless there are audio tracks
                    if (!this._audioTracksFlyout) {
                        var flyoutElement = _Global.document.createElement("div");
                        addClass(flyoutElement, "tv-mediaplayer-audiotracks");
                        addClass(flyoutElement, "tv-mediaplayer-overlay");
                        this._audioTracksFlyout = new _Flyout.Flyout(flyoutElement);
                        this._audioTracksButton.type = "flyout";
                        this._audioTracksButton.flyout = this._audioTracksFlyout;
                        flyoutElement.style.display = "none";
                        _Global.document.body.appendChild(flyoutElement);
                        this._audioTracksFlyout.addEventListener("beforeshow", this._handleFlyoutOpenCallbackBind, false);
                        this._audioTracksFlyout.addEventListener("afterhide", this._handleFlyoutCloseCallbackBind, false);
                    }

                    // Show the flyout
                    if (this._audioTracksButton) {
                        this._refreshAudioTracksMenu();
                        this._audioTracksFlyout.show(this._audioTracksButton, "top");
                    }

                    this._updateUIAndRaiseEvents(mediaCommandEnum.audioTracks, strings.audioTracksMediaCommandDisplayText);
                },

                _onCastCommandInvoked: function () {
                    if (_WinRT.Windows.Media.Casting &&
                        this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this.castButtonEnabled &&
                        this.castButtonVisible) {

                        var castingPicker = new _WinRT.Windows.Media.Casting.CastingDevicePicker();
                        castingPicker.filter.supportedCastingSources.append(this._mediaElementAdapter.mediaElement.msGetAsCastingSource());

                        var that = this;
                        castingPicker.oncastingdeviceselected = function (args) {
                            // Create the casting connection
                            var selectedCastingDevice = args.selectedCastingDevice;
                            var castingConnection = selectedCastingDevice.createCastingConnection();
                            // Begin casting
                            castingConnection.requestStartCastingAsync(that._mediaElementAdapter.mediaElement.msGetAsCastingSource());
                        };

                        var buttonRect = this._castButton.getBoundingClientRect();
                        castingPicker.show({ x: buttonRect.left, y: buttonRect.top, width: buttonRect.width, height: buttonRect.height }, _WinRT.Windows.UI.Popups.Placement.above);

                        this._updateUIAndRaiseEvents(mediaCommandEnum.cast, strings.castMediaCommandDisplayText);
                    }
                },

                _onCanPlay: function () {

                    this._isBusy = false;

                    if (this._startTime !== 0) {
                        this._seekInternal(this._startTime, false);

                        // Note: We need to manually call play if startTime is set otherwise a video or audio 
                        // tag with 'autoplay' set to 'true' will not delay a few seconds before starting to play
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement &&
                            this._mediaElementAdapter.mediaElement.autoplay) {
                            this.play();
                        }
                    }
                },

                _onChapterSkipBackCommandInvoked: function () {
                    if (this.chapterSkipBackButtonEnabled &&
                        this.chapterSkipBackButtonVisible) {
                        this.chapterSkipBack();
                    }
                },

                _onChapterSkipForwardCommandInvoked: function () {
                    if (this.chapterSkipForwardButtonEnabled &&
                        this.chapterSkipForwardButtonVisible) {
                        this.chapterSkipForward();
                    }
                },

                _onClosedCaptionsCommandInvoked: function () {
                    // We don't check the enabled & visible status of this button because the closed captions
                    // button is only visible if there are captions.
                    if (!this._closedCaptionsFlyout) {
                        var flyoutElement = _Global.document.createElement("div");
                        addClass(flyoutElement, "tv-mediaplayer-closedcaptions");
                        addClass(flyoutElement, "tv-mediaplayer-overlay");
                        this._closedCaptionsFlyout = new _Flyout.Flyout(flyoutElement);
                        this._closedCaptionsButton.type = "flyout";
                        this._closedCaptionsButton.flyout = this._closedCaptionsFlyout;
                        flyoutElement.style.display = "none";
                        _Global.document.body.appendChild(flyoutElement);
                        this._closedCaptionsFlyout.addEventListener("beforeshow", this._handleFlyoutOpenCallbackBind, false);
                        this._closedCaptionsFlyout.addEventListener("afterhide", this._handleFlyoutCloseCallbackBind, false);
                    }

                    // Show the flyout
                    if (this._closedCaptionsButton) {
                        this._refreshClosedCaptionsMenu();
                        this._closedCaptionsFlyout.show(this._closedCaptionsButton, "top");
                    }

                    this._updateUIAndRaiseEvents(mediaCommandEnum.closedCaptions, strings.closedCaptionsMediaCommandDisplayText);
                },

                // Handles the back command for controller, SmartGlass, media remote and keyboard input
                // The reason we have a separate event handler for back, is because we need to intercept
                // the event before it reaches the document and navigates back. All our other key input
                // events are meant to be captured at the document level.
                _onControlsKeyupInputHandler: function (ev) {

                    if (ev.key === "GamepadB" ||
                        ev.key === "Escape") {

                        // If the controls are visible then we eat the B event so it
                        // won't bubble up to the page and cause a navigation.
                        if (this._controlsVisible) {
                            this._exitFastForwardOrRewind(true);
                            this._hideControls();
                            ev.stopPropagation();
                        }
                    }
                },

                // Toggles msZoom
                _onZoomCommandInvoked: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this.zoomButtonEnabled &&
                        this.zoomButtonVisible) {
                        var zoomFeebackText = "";
                        if (this._mediaElementAdapter.mediaElement.msZoom) {
                            this._mediaElementAdapter.mediaElement.msZoom = false;
                            zoomFeebackText = "Letterbox";
                        } else {
                            this._mediaElementAdapter.mediaElement.msZoom = true;
                            zoomFeebackText = "Native";
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.zoom, zoomFeebackText);
                    }
                },

                _onDurationChange: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        if (!isFinite(this._mediaElementAdapter.mediaElement.duration)) {
                            this._mediaElementAdapter.isLive = true;
                        }

                        if (!this._wasEndTimeSetProgrammatically) {
                            var newDuration = this._mediaElementAdapter.mediaElement.duration;
                            this._endTime = newDuration;
                            this._totalTime = this._endTime - this._startTime;
                            this._updateTimelineVisuals();

                            this._updateMediaState(false);
                        }
                    }
                },

                // This function is called after the video has ended.
                _onEnded: function () {

                    this._exitFastForwardOrRewind(false);

                    // Reset this value to false because there is code in _handleEndTimeReached that checks if the
                    // end time was reached or not to prevent _handleEndTimeReached from being called again.
                    this._endTimeReached = false;

                    if (this._isThumbGrabbed) {
                        this._onThumbDragStop(null);
                    }

                    this._updateMediaState(false);
                },

                // Remove old markers and clear the time display
                _onEmptied: function () {

                    this._resetInternalState();
                    this._clearTimeDisplay();
                },

                _onError: function (ev) {
                    if (!this._errorFlyout) {
                        var flyoutElement = _Global.document.createElement("div");
                        addClass(flyoutElement, "tv-mediaplayer-errorflyout");
                        addClass(flyoutElement, "tv-mediaplayer-overlay");
                        flyoutElement.innerHTML = '     <div class="tv-mediaplayer-errortext"></div>';
                        this._errorFlyout = new _Flyout.Flyout(flyoutElement);
                        flyoutElement.style.display = "none";
                        _Global.document.body.appendChild(flyoutElement);
                        this._errorText = flyoutElement.querySelector(".tv-mediaplayer-errortext");
                        this._errorFlyout.addEventListener("beforeshow", this._handleFlyoutOpenCallbackBind, false);
                        this._errorFlyout.addEventListener("afterhide", this._handleFlyoutCloseCallbackBind, false);
                    }

                    // Show the flyout
                    if (this._transportControls &&
                        this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.error) {
                        var error = this._mediaElementAdapter.mediaElement.error;
                        var errorText = "";
                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        if (error.msExtendedErrorCode) {
                            switch (mediaElement.error.msExtendedErrorCode) {
                                case 1: // MEDIA_ERR_ABORTED
                                    errorText = strings.mediaErrorAborted;
                                    break;
                                default: // Unknown error
                                    errorText = strings.mediaErrorUnknown;
                                    break;
                            }
                        } else {
                            switch (error.code) {
                                case 1: // MEDIA_ERR_ABORTED
                                    errorText = strings.mediaErrorAborted;
                                    break;
                                case 2: // MEDIA_ERR_NETWORK
                                    errorText = strings.mediaErrorAborted;
                                    break;
                                case 3: // MEDIA_ERR_DECODE
                                    errorText = strings.mediaErrorAborted;
                                    break;
                                case 4: // MEDIA_ERR_SRC_NOT_SUPPORTED
                                    errorText = strings.mediaErrorAborted;
                                    break;
                                default: // Unknown error
                                    errorText = strings.mediaErrorUnknown;
                                    break;
                            }
                        }
                        this._errorText.textContent = errorText;
                        this._errorFlyout.show(this._transportControls, "top");
                    }
                },

                _onFastForwardCommandInvoked: function () {
                    if (this.fastForwardButtonEnabled &&
                        this.fastForwardButtonVisible) {
                        this.fastForward();
                    }
                },

                // This function is called periodically during a fast forward or rewind operation. When the MediaPlayer is fast forwarding or rewinding it is actually
                // paused and cycling thumbnails to simulate a fast forward or rewind. This function updates the targetCurrentTime property and the UI on the timeline.
                _onFastForwardRewindTimerTick: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        var transformName = _BaseUtils._browserStyleEquivalents["transform"].scriptName;

                        var startTime = this._startTime;
                        var endTime = this._endTime;

                        var currentTime = mediaElement.currentTime;
                        var rawElapsedTime = new Date().getTime() - this._lastFastForwardOrRewindTimerTime;
                        var elapsedTimeInSeconds = Math.floor(rawElapsedTime / 100) / 10;

                        this._fastForwardOrRewindTimerElapsedTime += elapsedTimeInSeconds * this._targetPlaybackRate;
                        this._targetCurrentTime = this._fastForwardOrRewindTimerElapsedTime + currentTime;

                        // If we are past the endTime or startTime, then we need to exit fast forward or rewind mode
                        if (this._targetCurrentTime >= endTime) {
                            this._targetCurrentTime = endTime;
                            this._handleEndTimeReached();
                        } else if (this._targetCurrentTime <= startTime) {
                            this._targetCurrentTime = startTime;
                            this._handleStartTimeReached();
                        }

                        // Note: We don't call _updateTimelineVisuals because that would sync the seek progress bar
                        // to the location of the current time, which isn't correct during a thumbnail-based fast forward or rewind.
                        if (this._progress &&
                            this._totalTime !== 0) {
                            var newProgress = (this._targetCurrentTime - startTime) / this._totalTime;
                            var newProgressLeftOffset = newProgress * this._totalSeekBarWidth;
                            if (this._thumbnailImage) {
                                // Otherwise if we're at an edge of the timeline, we move the triangle independently of the image
                                var leftEdgeOfTheSeekbar = this._thumbImageElementWidthDividedByTwo;
                                var rightEdgeOfTheSeekbar = this._totalSeekBarWidth - this._thumbImageElementWidthDividedByTwo;
                                this._moveThumbnail(newProgressLeftOffset, leftEdgeOfTheSeekbar, rightEdgeOfTheSeekbar);
                            }
                            this._progress.style[transformName] = "scaleX(" + newProgress + ")";

                            this._updateTimeDisplay();
                            // Request a new thumbnail and send a time update event
                            this.dispatchEvent("targettimeupdate", {});
                            if (this._thumbnailEnabled) {
                                this.dispatchEvent("thumbnailrequest", { currentTime: this._targetCurrentTime, playbackRate: this._targetPlaybackRate });
                            }
                        }

                        this._lastFastForwardOrRewindTimerTime = new Date().getTime();

                        // It's possible to get into a non-paused state, if the user starts FF or RR while a seek is in progress.
                        // The seek will finish and start the video playing, but if the user is in the FF or RR state we want
                        // the media to be paused.
                        if (this._simulatedFastForwardMode &&
                            mediaElement.playbackRate !== 0) {
                            this._previousPlaybackRate = mediaElement.playbackRate;
                            mediaElement.playbackRate = 0;
                        }
                    }
                },

                _moveThumbnail: function (seekBarOffset, leftEdgeOfTheSeekbar, rightEdgeOfTheSeekbar) {
                    var transformName = _BaseUtils._browserStyleEquivalents["transform"].scriptName;
                    if (seekBarOffset < leftEdgeOfTheSeekbar) {
                        var seekMarkOffset = 1 * (seekBarOffset - leftEdgeOfTheSeekbar);
                        if (seekMarkOffset < -1 * this._thumbImageElementWidthDividedByTwo) {
                            seekMarkOffset = -1 * this._thumbImageElementWidthDividedByTwo;
                        }
                        this._seekMark.style[transformName] = "translateX(" + seekMarkOffset + "px)";
                        this._thumbElement.style[transformName] = "translate(" + (seekMarkOffset) + "px, 3px)";
                        addClass(this._thumbElement, "tv-mediaplayer-thumbnail-lefttriangle");
                        this._currentTimeVisualElements.style[transformName] = "translateX(" + leftEdgeOfTheSeekbar + "px)";
                    } else if (seekBarOffset > rightEdgeOfTheSeekbar) {
                        var seekMarkOffset = seekBarOffset - rightEdgeOfTheSeekbar;
                        if (seekMarkOffset > this._thumbImageElementWidthDividedByTwo) {
                            seekMarkOffset = this._thumbImageElementWidthDividedByTwo;
                        }
                        this._seekMark.style[transformName] = "translateX(" + seekMarkOffset + "px)";
                        this._thumbElement.style[transformName] = "translate(" + (seekMarkOffset - 14) + "px, 6px)";
                        addClass(this._thumbElement, "tv-mediaplayer-thumbnail-righttriangle");
                        this._currentTimeVisualElements.style[transformName] = "translateX(" + rightEdgeOfTheSeekbar + "px)";
                    } else {
                        this._seekMark.style[transformName] = "none";
                        removeClass(this._thumbElement, "tv-mediaplayer-thumbnail-lefttriangle");
                        removeClass(this._thumbElement, "tv-mediaplayer-thumbnail-righttriangle");
                        this._thumbElement.style[transformName] = "rotate(45deg)";
                        this._currentTimeVisualElements.style[transformName] = "translateX(" + seekBarOffset + "px)";
                    }
                },

                _onHideControlsCommandInvoked: function () {
                    if (this._disposed) {
                        return;
                    }

                    // If the controls are ever hidden and the MediaPlayer thinks the user is grabbing the timeline then
                    // we are in an incorrect state and need to cancel the timeline grabbing gesture. This can happen
                    // if we don't receive a pointer up event when the user opens their hand.
                    if (this._isThumbGrabbed) {
                        this._onThumbDragStop(null);
                    }

                    this._hideControls();
                },

                _onInputHandlerKeyDown: function (ev) {
                    if (this._disposed) {
                        return;
                    }

                    switch (ev.keyCode) {
                        case utilities.Key.escape:
                            if (!this._isFocusOnAVisibleFlyout() &&
                                this.isFullScreen) {
                                this.isFullScreen = false;
                            }

                            break;

                        case utilities.Key.space:
                            if (!this._isFocusOnAVisibleFlyout()) {
                                this._showControls(true);
                                this._onPlayPauseCommandInvoked();
                            }

                            break;

                        default:
                            break;
                    }
                },

                _onInputHandlerKeyUp: function (ev) {
                    if (this._disposed) {
                        return;
                    }

                    switch (ev.keyCode) {
                        case utilities.Key.gamepadA:
                            if (!this._controlsVisible &&
                                !this._isFocusOnAVisibleFlyout()) {
                                this._showControls();
                                this._playPauseButton.focus();
                            }

                            break;
                        default:
                            break;
                    }
                },

                // Handles the gesture start event on the input Handler element
                _onInputHandlerPointerDown: function (ev) {
                    // Keep track of the last pointer position allows us to see if the pointer had the same X, Y on
                    // pointer up (meaning the pointer was tapped as opposed to dragged). If the pointer was tapped
                    // then we dismiss the controls.
                    this._lastPointerPosition = ev.x + "," + ev.y;

                    // When the user presses anywhere on the video if we are FF'ing or RR'ing
                    // we should exit FF or RR mode and play.
                    this._exitFastForwardOrRewind(true);

                    if (this._controlsVisible) {
                        this._onThumbStartDrag(ev);
                    } else {
                        this._showControls();
                    }
                },

                // Handles the pointer move event on the input Handler element
                _onInputHandlerPointerMove: function (ev) {
                    this._showControls();
                    if (this._isThumbGrabbed) {
                        this._onThumbDrag(ev);
                    }
                },

                // Handles click on to pause, a feature for advanced users
                _onInputHandlerClick: function (ev) {
                    // If the user clicks on the transports controls, we should not pause here, so just returns.
                    if (this._transportControls.contains(ev.target)) {
                        return;
                    }

                    if (!TVJS._tv) {
                        this._showControls(true);
                    }
                    this._onPlayPauseCommandInvoked();
                },

                _inputHandlerMouseDown: function () {
                    this._isPointerDown = true;
                },

                _inputHandlerMouseOut: function (ev) {
                    if (this._isThumbGrabbed) {
                        // get original event
                        ev = ev.detail.originalEvent;
                        this._isPointerDown = false;
                        this._onThumbDragStop(ev);
                    }
                },

                _inputHandlerMouseUp: function () {
                    this._isPointerDown = false;
                },

                // Handles the gesture end event on the input Handler element
                _onInputHandlerPointerUp: function (ev) {
                    if (this._isThumbGrabbed) {
                        this._onThumbDragStop(ev);
                    }

                    var currentPointerPosition = ev.x + "," + ev.y;
                    var lastPointerPosition = this._lastPointerPosition;
                    if (currentPointerPosition === lastPointerPosition) {
                        this._hideControls();
                    }
                },

                // This function is called whenever a new media source is loaded. This function is the
                // right place to initialize any properties that get set/reset when new media is loaded.
                _onLoadStart: function () {
                    this._clearMediaCommandFeedbackText();
                    this._clearTimeDisplay();

                    if (!this._wasStartTimeSetProgrammatically &&
                        !this._wasEndTimeSetProgrammatically &&
                        !this._hasCustomMarkers) {
                        this._unsubscribeFromTimeUpdates();
                    }

                    // Remove any old markers
                    if (this._doMarkersNeedResetting) {
                        this._markers.length = 0;
                        this._hasCustomMarkers = false;
                        this._doMarkersNeedResetting = false;
                    }

                    this._isChapterMarkerVisualsDirty = true;

                    var that = this;
                    Promise.timeout(this._timeBeforeShowingBusyVisual).done(function afterEnoughTimeHasPassedToShowALoadingSpinner() {
                        if (that._mediaElementAdapter &&
                            that._mediaElementAdapter.mediaElement &&
                            that._mediaElementAdapter.mediaElement.readyState < that._MediaReadyState.MediaReadyState_Have_FutureData) {
                            that._isBusy = true;
                        }
                    });
                },

                _onGoToLiveCommandInvoked: function () {
                    if (this.goToLiveButtonEnabled &&
                        this.goToLiveButtonVisible) {
                        this.goToLive();
                    }
                },

                // This function is called when the media's metadata is loaded. This function is the right
                // place to initialize properties that need to know the duration of the media.
                _onLoadedMetadata: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        if (this._mediaElementAdapter.mediaElement.duration === Number.POSITIVE_INFINITY) {
                            this._mediaElementAdapter.isLive = true;
                        }

                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        this._updateDefaultStartAndEndTime(mediaElement);

                        this._initializeChapterMarkers(mediaElement);

                        // Update any dynamic button state
                        this._updateAudioTracksButtonStateBind();
                        this._updateClosedCaptionsButtonStateBind();
                    }
                },

                _onMarkerCollectionChanged: function () {

                    // The marker logic depends on the markers array always being in sorted order from smallest to largest time.
                    this._markers.sort(function (first, next) {
                        return first.time - next.time;
                    });

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        this._recalculateNextAndPreviousCustomMarkerIndexAndTime(this._mediaElementAdapter.mediaElement.currentTime);
                    }

                    // We wait until the first custom marker is added before subscribing to time updates
                    // That way we won't be listening to time updates when we don't need to.
                    if (this._hasCustomMarkers) {

                        this._subscribeToTimeUpdates();
                    }

                    this._isChapterMarkerVisualsDirty = true;
                    this._updateChapterMarkerVisuals();
                },

                _onMuteCommandInvoked: function () {
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        if (this._mediaElementAdapter.mediaElement.volume === 0) {
                            this._mediaElementAdapter.mediaElement.volume = this._previousVolumeValue;
                            if (this._muteButton) {
                                removeClass(this._muteButton, "tv-mediaplayer-mute-icon");
                                addClass(this._muteButton, "tv-mediaplayer-volume-icon");
                            }
                        } else {
                            this._previousVolumeValue = this._mediaElementAdapter.mediaElement.volume;
                            this._mediaElementAdapter.mediaElement.volume = 0;
                            if (this._muteButton) {
                                removeClass(this._muteButton, "tv-mediaplayer-volume-icon");
                                addClass(this._muteButton, "tv-mediaplayer-mute-icon");
                            }
                        }
                        var newVolume = this._mediaElementAdapter.mediaElement.volume * 100;
                        if (this._volumeSlider) {
                            this._volumeSlider.value = newVolume;
                        }
                        if (this._volumeValue) {
                            this._volumeValue.textContent = newVolume;
                        }
                    }
                    this._updateUIAndRaiseEvents(mediaCommandEnum.mute, strings.mediaPlayerMuteButtonLabel);
                },

                _onNextTrackCommandInvoked: function () {
                    if (this.nextTrackButtonEnabled &&
                        this.nextTrackButtonVisible) {
                        this.nextTrack();
                    }
                },

                _onPause: function () {
                    this._showPlayButton();
                },

                // Note: Instead of following the typical patter where we call a public method on the MediaPlayer,
                // we handle the logic in this function. That was done, because we didn't want to expose a public API
                // called "playFromBeginning". The reason we didn't want to expose that API was because smaller API surface
                // is better and "playFromBeginning" was easily accomplished programmatically with the existing seek and play APIs.
                _onPlayFromBeginningCommandInvoked: function () {
                    if (this.playFromBeginningButtonEnabled &&
                        this.playFromBeginningButtonVisible) {
                        this._playFromBeginning();

                        this._updateUIAndRaiseEvents(mediaCommandEnum.playFromBeginning, strings.playFromBeginningMediaCommandDisplayText);
                    }
                },

                _onPlaybackRateCommandInvoked: function () {
                    if (!this._playbackRateFlyout) {
                        var flyoutElement = _Global.document.createElement("div");
                        addClass(flyoutElement, "tv-mediaplayer-playbackrate");
                        addClass(flyoutElement, "tv-mediaplayer-overlay");
                        flyoutElement.innerHTML = '     <button value="0.5">' + strings.playbackRateHalfSpeedLabel + '</button>' +
                                                    '     <button value="1">' + strings.playbackRateNormalSpeedLabel + '</button>' +
                                                    '     <button value="1.5">' + strings.playbackRateOneAndHalfSpeedLabel + '</button>' +
                                                    '     <button value="2">' + strings.playbackRateDoubleSpeedLabel + '</button>';
                        this._playbackRateFlyout = new _Flyout.Flyout(flyoutElement);
                        this._playbackRateButton.type = "flyout";
                        this._playbackRateButton.flyout = this._playbackRateFlyout;
                        flyoutElement.style.display = "none";
                        _Global.document.body.appendChild(flyoutElement);
                        this._playbackRateFlyout.addEventListener("beforeshow", this._handleFlyoutOpenCallbackBind, false);
                        this._playbackRateFlyout.addEventListener("afterhide", this._handleFlyoutCloseCallbackBind, false);
                        // Set up the event listeners on the buttons
                        var that = this;
                        var playbackRateOptions = flyoutElement.querySelectorAll("button");
                        for (var i = 0, len = playbackRateOptions.length; i < len; i++) {
                            playbackRateOptions[i].addEventListener("click", function (ev) {
                                if (that._mediaElementAdapter &&
                                    that._mediaElementAdapter.mediaElement) {
                                    var button = this;
                                    that._mediaElementAdapter.mediaElement.playbackRate = that._mediaElementAdapter.mediaElement.defaultPlaybackRate * button.value;
                                    ev.stopPropagation();
                                }
                            });
                        }
                    }

                    // Show the flyout
                    if (this._playbackRateButton) {
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement) {
                            var currentPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                            var playbackRateOptions = this._playbackRateFlyout.element.querySelectorAll("button");
                            for (var i = 0, len = playbackRateOptions.length; i < len; i++) {
                                if (playbackRateOptions[i].value === currentPlaybackRate) {
                                    addClass(playbackRateOptions[i], "tv-active");
                                } else {
                                    removeClass(playbackRateOptions[i], "tv-active");
                                }
                            }
                        }

                        this._playbackRateFlyout.show(this._playbackRateButton, "top");
                    }
                    this._updateUIAndRaiseEvents(mediaCommandEnum.playbackRate, strings.mediaPlayerPlaybackRateButtonLabel);
                },

                // Toggles the play / pause state of the media
                _onPlayPauseCommandInvoked: function () {

                    if ((!TVJS._tv || this._controlsVisible) &&
                        this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this.playPauseButtonEnabled &&
                        this.playPauseButtonVisible) {

                        if (this._mediaElementAdapter.mediaElement.paused ||
                            this._mediaElementAdapter.mediaElement.playbackRate === 0) {
                            if (this._mediaElementAdapter.mediaElement.playbackRate === 0) {
                                this._mediaElementAdapter.mediaElement.playbackRate = this._mediaElementAdapter.mediaElement.defaultPlaybackRate;
                            }
                            this._showPauseButton();
                            this.play();
                        } else {

                            // If we are in fast forward / rewind mode, then exit to playing
                            if (this._isInFastForwardOrRewindMode) {

                                if (!this._simulatedFastForwardMode) {
                                    this._isInFastForwardOrRewindMode = false;
                                    this._mediaElementAdapter.mediaElement.playbackRate = this._mediaElementAdapter.mediaElement.defaultPlaybackRate;
                                }

                                this._showPauseButton();
                                this.play();
                            } else {
                                this._showPlayButton();
                                this.pause();
                            }
                        }
                    }
                },

                _onPlay: function () {

                    this._showPauseButton();
                    this._updateMediaState(false);
                },

                _onPlaying: function () {
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        if (this._mediaElementAdapter.mediaElement.playbackRate === this._mediaElementAdapter.mediaElement.defaultPlaybackRate) {
                            this._showPauseButton();
                        }

                        this._updateMediaState(false);
                    }
                },

                _onPreviousTrackCommandInvoked: function () {
                    if (this.previousTrackButtonEnabled &&
                        this.previousTrackButtonVisible) {
                        this.previousTrack();
                    }
                },

                _onProgress: function () {
                    // Update buffering visuals
                    if (this._controlsVisible &&
                        this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        (!wuiv.ApplicationView || (wuiv.ApplicationView && wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped)) &&
                        this._mediaElementAdapter.mediaElement.buffered.length) {
                        // Buffered got different time range buffer in ascending order
                        // We find the range that is atleast one closest to the current time. In most cases it'll be the latest one, so we start
                        // looking at the end and work back to the older ranges.
                        // If we buffer ranges should above or equal to current, then only we update the bufferring with latest range.
                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        var currentTime = mediaElement.currentTime;
                        var indexOfBufferRangeToDisplay = -1;
                        var transformName = _BaseUtils._browserStyleEquivalents["transform"].scriptName;
                        for (var i = mediaElement.buffered.length - 1; i >= 0; i--) {
                            if (currentTime >= mediaElement.buffered.start(i) &&
                                currentTime <= mediaElement.buffered.end(i)) {
                                indexOfBufferRangeToDisplay = i;
                                break;
                            }
                        }

                        if (indexOfBufferRangeToDisplay !== -1) {
                            indexOfBufferRangeToDisplay = mediaElement.buffered.length - 1;
                            var bufferedStart = mediaElement.buffered.start(indexOfBufferRangeToDisplay);
                            var bufferedEnd = mediaElement.buffered.end(indexOfBufferRangeToDisplay);

                            var bufferedRangeAsPercentOfDuration = (bufferedEnd - bufferedStart) / this._totalTime;
                            var bufferPixelLeftOffset = (bufferedStart / this._totalTime) * this._totalSeekBarWidth;

                            this._buffer.style[transformName] = "scaleX(" + bufferedRangeAsPercentOfDuration + ") translateX(" + bufferPixelLeftOffset + "px)";
                        } else {
                            // Don't show buffering visuals
                            this._buffer.style[transformName] = "scaleX(" + 0 + ")";
                        }
                    }
                },

                // Handler for media elements 'ratechange' event. This function updates the UI to react to changes in playRate.
                _onRateChange: function () {
                    // We don't want to change _isInFastForwardOrRewindMode if thumbnail mode is enabled, because the actual playbackRate
                    // is not going to correspond to the perceived playbackRate in the UI.
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        !this._simulatedFastForwardMode) {
                        if (this._mediaElementAdapter.mediaElement.playbackRate === this._mediaElementAdapter.mediaElement.defaultPlaybackRate) {
                            this._isInFastForwardOrRewindMode = false;
                            this._showPauseButton();
                            this._updateInfoDisplay(strings.playMediaCommandDisplayText);
                        } else if (this._mediaElementAdapter.mediaElement.playbackRate === 0) {
                            this._isInFastForwardOrRewindMode = false;
                            this._showPlayButton();
                            this._updateInfoDisplay(strings.pauseMediaCommandDisplayText);
                        } else {
                            this._isInFastForwardOrRewindMode = true;
                            this._showPlayButton();
                            this._setFastForwardOrRewindText();
                        }

                        this._updateMediaState(false);
                    }
                },

                _onRewindCommandInvoked: function () {
                    if (this.rewindButtonEnabled &&
                        this.rewindButtonVisible) {
                        this.rewind();
                    }
                },

                _onSeeked: function () {
                    // Note: We don't call _updateMediaState, because setting _isBusy calls the function
                    // under the covers.
                    this._isBusy = false;

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        // Note: After a seek event, we need to recalculate the _nextMarkerTime, _nextMarkerIndex, _previousMarkerTime and _previousMarkerIndex
                        // because the current time will have changed.
                        this._recalculateNextAndPreviousCustomMarkerIndexAndTime(this._mediaElementAdapter.mediaElement.currentTime);

                        if (this._controlsVisible) {
                            // After a seek, clear any transforms on the currentTime circle visual
                            if (this._simulatedFastForwardMode) {
                                this._seekMark.style[_BaseUtils._browserStyleEquivalents["transform"].scriptName] = "none";
                            }
                            this._updateTimelineVisuals();
                        }
                    }
                },

                // This function is called before a seek operation is attempted
                _onSeeking: function () {

                    // Note: We don't call _updateMediaState, because setting _isBusy calls the function
                    // under the covers.
                    var that = this;
                    Promise.timeout(this._timeBeforeShowingBusyVisual).done(function afterEnoughTimeHasPassedToShowALoadingSpinner() {
                        if (that._mediaElementAdapter &&
                            that._mediaElementAdapter.mediaElement &&
                            that._mediaElementAdapter.mediaElement.seeking) {
                            that._isBusy = true;
                        }
                    });

                    // If there was an outside force that caused a seek operation past the starTime or endTime (for instance, 
                    // someone called seek on the video tag directly, then we need to clamp the time to the startTime or endTime.
                    if (this._wasStartTimeSetProgrammatically ||
                        this._wasEndTimeSetProgrammatically) {

                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement) {
                            var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                            if (currentTime < this._startTime) {
                                this._handleStartTimeReached();
                            } else if (currentTime > this._endTime) {
                                this._handleEndTimeReached();
                            }
                        }
                    }
                },

                // This function is called to show the controls when the user invokes them with voice or gesture input
                _onShowControlsCommandInvoked: function () {
                    if (this._disposed) {
                        return;
                    }

                    if (!TVJS._tv &&
                        !this._controlsVisible &&
                        !this._isFocusOnAVisibleFlyout()) {
                        this._showControls(true, true);
                    }
                },

                // Handles the pointer move event on the input handler element when thumb bar is held down
                _onThumbDrag: function (ev) {
                    if (this._mediaElementAdapter &&
                       !this._mediaElementAdapter.isSeekAllowed) {
                        return;
                    }

                    // Calculate how far the user moved since last time & remember
                    // the current X coordinate of the pointer.
                    var newX = ev.x;
                    var transformName = _BaseUtils._browserStyleEquivalents["transform"].scriptName;
                    var seekBarOffset = newX;
                    var progress = newX / this._totalSeekBarWidth;

                    // Clamp the progress to the timeline
                    if (progress < 0) {
                        progress = 0;
                    } else if (progress > 1) {
                        progress = 1;
                    }

                    this._progress.style[transformName] = "scaleX(" + progress + ")";

                    if (this._thumbnailImage) {
                        if (seekBarOffset < 0) {
                            seekBarOffset = 0;
                        } else if (seekBarOffset > this._totalSeekBarWidth) {
                            seekBarOffset = this._totalSeekBarWidth;
                        }
                        // Otherwise if we're at an edge of the timeline, we move the triangle independently of the image
                        var leftEdgeOfTheSeekbar = 0;
                        if (this.isThumbnailEnabled) {
                            leftEdgeOfTheSeekbar = this._thumbImageElementWidthDividedByTwo;
                        } else {
                            leftEdgeOfTheSeekbar = 50; // This is 1/2 of the width of the seek time indicator visual
                        }
                        var rightEdgeOfTheSeekbar = this._totalSeekBarWidth - leftEdgeOfTheSeekbar;
                        this._moveThumbnail(seekBarOffset, leftEdgeOfTheSeekbar, rightEdgeOfTheSeekbar);
                    }

                    this._seekCurrentTime = progress * this._totalTime;

                    // Clamp the currentTime
                    if (this._seekCurrentTime < 0) {
                        this._seekCurrentTime = 0;
                    } else if (this._seekCurrentTime > this._totalTime) {
                        this._seekCurrentTime = this._totalTime;
                    }

                    // Apply a slight magnetism so that is the user is scrubbing close to a marker the timeline
                    // position will snap to the marker.
                    if (this._markers.length &&
                        (this._lastPosition - newX) < this._MINIMUM_POINTER_DELTA_TO_ENABLE_SNAPPING_TO_NEAREST_MARKER &&
                        this.chapterSkipBackButtonEnabled &&
                        this.chapterSkipBackButtonVisible &&
                        this.chapterSkipForwardButtonEnabled &&
                        this.chapterSkipForwardButtonVisible) {
                        var closeToMarkerThreshold = this._totalTime * this._SNAP_TO_NEAREST_MARKER_THRESHOLD;
                        for (var i = 0, len = this._markers.length; i < len; i++) {
                            if (Math.abs(this._markers[i].time - this._seekCurrentTime) < closeToMarkerThreshold) {

                                // Snap the currentTime to the marker
                                this._seekCurrentTime = this._markers[i].time;
                                var markerOffset = this._seekCurrentTime / this._totalTime;

                                // Snap the UI to the marker location
                                this._progress.style[transformName] = "scaleX(" + markerOffset + "px)";
                                this._currentTimeVisualElements.style[transformName] = "translateX(" + markerOffset + "px)";

                                break;
                            }
                        }
                    }

                    this.dispatchEvent("thumbnailrequest", { currentTime: this._seekCurrentTime, playbackRate: 0 });

                    if (this._thumbnailImage) {
                        this._seekTimeIndicator.textContent = this._timeFormatter(this._seekCurrentTime);
                    }

                    this._lastPosition = newX;
                },

                // Handles the pointer up event on the seek bar thumb
                _onThumbDragStop: function (ev) {
                    if (this._mediaElementAdapter &&
                       !this._mediaElementAdapter.isSeekAllowed) {
                        return;
                    }

                    var mediaElement = this._mediaElementAdapter.mediaElement;
                    var transformName = _BaseUtils._browserStyleEquivalents["transform"].scriptName;

                    if (this._thumbnailImage) {
                        addClass(this._thumbElement, "tv-mediaplayer-hidden");
                        addClass(this._thumbnailImage, "tv-mediaplayer-hidden");

                        this._seekMark.style[transformName] = "none";
                        this._thumbElement.style[transformName] = "rotate(45deg)";
                    }

                    removeClass(this._element, "tv-mediaplayer-scrubbing");

                    // We need to check if the video is loaded before seeking otherwise the video tag will throw an exception.
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.readyState >= this._MediaReadyState.MediaReadyState_Have_FutureData) {
                        this.seek(this._seekCurrentTime);
                    }

                    this._mediaElementAdapter.mediaElement.playbackRate = this._previousPlaybackRate;
                    if (!this._wasPausedBeforeScrubbing &&
                        !mediaElement.ended) {
                        this._mediaElementAdapter.play();
                    }
                    this._setControlsTimer();

                    this._isThumbGrabbed = false;
                },

                // Handles the pointer down event on the seek bar thumb 
                _onThumbStartDrag: function (ev) {
                    if (!this._mediaElementAdapter ||
                        !this._mediaElementAdapter.isSeekAllowed ||
                        !this._mediaElementAdapter.mediaElement) {
                        return;
                    }

                    if (this._controlsVisible) {
                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        this._wasPausedBeforeScrubbing = mediaElement.paused;

                        // Disable the auto-hide timer on the controls while scrubbing
                        if (this._controlHideTimeout) {
                            this._removeControlsTimer();
                        }

                        // Only do this for video otherwise this will stop audio playback
                        // during scrubbing which is undesirable.
                        if (mediaElement.tagName === this._TAG_NAME_VIDEO) {
                            this._mediaElementAdapter.pause();
                            this._previousPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                            this._mediaElementAdapter.mediaElement.playbackRate = 0;
                        }

                        // This is the initial position of the cursor before the user has started
                        // a scrub operation. This value will be mapped to the current timeline position.
                        this._startOffsetX = ev.x;
                        this._lastPosition = this._startOffsetX;

                        // Need to also calculate the offset of the timeline
                        var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        this._relativeTimelineStartOffset = currentTime / this._totalTime;

                        this._isThumbGrabbed = true;

                        // Show the thumbnails if thumbnail mode is enabled
                        if (this._thumbnailImage) {
                            removeClass(this._thumbElement, "tv-mediaplayer-hidden");
                            removeClass(this._thumbnailImage, "tv-mediaplayer-hidden");

                            // We need this value for scrubbing to make sure the thumbnail image doesn't go past the timeline.
                            if (!this._thumbImageElementWidthDividedByTwo) {
                                this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;
                            }
                        }

                        addClass(this._element, "tv-mediaplayer-scrubbing");
                    }
                },

                _onTimeSkipForwardCommandInvoked: function () {
                    if (this.timeSkipForwardButtonEnabled &&
                        this.timeSkipForwardButtonVisible) {
                        this.timeSkipForward();
                    }
                },

                _onTimeSkipBackCommandInvoked: function () {
                    if (this.timeSkipBackButtonEnabled &&
                        this.timeSkipBackButtonVisible) {
                        this.timeSkipBack();
                    }
                },

                // This function is called approximately every 200 milliseconds.
                // This function should only be called if (1) the timeline controls are visible or (2) there are custom markers
                _onTimeUpdate: function () {
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        // If current time has passed the start or end time, then we clamp the current time to the start or end time.
                        var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        if (this._mediaElementAdapter.mediaElement.readyState >= this._MediaReadyState.MediaReadyState_Have_FutureData) {
                            if (currentTime < this._startTime) {
                                this._handleStartTimeReached();
                            } else if (currentTime > this._endTime) {
                                this._handleEndTimeReached();
                            }
                        }

                        // Check Fire marker event if there is one
                        if (this._nextCustomMarkerTime !== -1 &&
                            !this._isInFastForwardOrRewindMode &&
                            Math.abs(this._nextCustomMarkerTime - currentTime) < this._MARKER_PROXIMITY_THRESHOLD) {

                            // We need to check that there is still a valid marker to fire an event on, otherwise we
                            // could run into a race condition where the markers was removed in between us capturing
                            // the currentTime and firing the event.
                            if (this._markers[this._nextCustomMarkerIndex]) {
                                this.dispatchEvent("markerreached", this._markers[this._nextCustomMarkerIndex]);
                            }

                            // It's possible that there are more markers in close proximity to the current marker
                            // we need to fire those markers as well, otherwise they will get skipped over by the
                            // next 'timeupdate', since 'timeupdate' fires only about every 200 milliseconds.
                            var markersLength = this._markers.length;
                            var indexOfLastMarkerFired = this._nextCustomMarkerIndex;
                            for (var i = indexOfLastMarkerFired + 1; i < markersLength; i++) {
                                if ((this._markers[i].time - currentTime) < this._MARKER_PROXIMITY_THRESHOLD) {

                                    // We do not need to check to see if the marker is valid before firing the event like
                                    // we did above, because we already check the validity of the markers in the for loop
                                    // with this statement "this._markers[i].time".
                                    this.dispatchEvent("markerreached", this._markers[i]);
                                    indexOfLastMarkerFired = i;
                                } else {
                                    break;
                                }
                            }

                            // Reset the next/previous marker state variables
                            if (indexOfLastMarkerFired + 1 < this._markers.length &&
                                this._markers[indexOfLastMarkerFired + 1]) {
                                this._nextCustomMarkerIndex = indexOfLastMarkerFired + 1;
                                this._nextCustomMarkerTime = this._markers[this._nextCustomMarkerIndex].time;
                            } else {
                                this._nextCustomMarkerIndex = -1;
                                this._nextCustomMarkerTime = -1;
                            }

                            if (indexOfLastMarkerFired >= 0 &&
                                this._markers.length &&
                                this._markers[indexOfLastMarkerFired]) {
                                this._previousCustomMarkerIndex = indexOfLastMarkerFired;
                                this._previousCustomMarkerTime = this._markers[this._previousCustomMarkerIndex].time;
                            } else {
                                this._previousCustomMarkerIndex = -1;
                                this._previousCustomMarkerTime = -1;
                            }

                        }

                        if (this._mediaElementAdapter &&
                            this._controlsVisible) {

                            // Update the time display for non-live streams
                            if (!this._mediaElementAdapter.isLive) {
                                this._syncTimeAndProgress(false);
                                this._updateTimeDisplay();
                            }
                        }
                    }
                },

                _onToggleFullscreenCommandInvoked: function () {
                    
                    var currentClosedCaptionTrack = this._getActiveTrack();

                    if (this.isFullScreen) {
                        this.isFullScreen = false;
                    } else {
                        this.isFullScreen = true;
                    }

                    if (currentClosedCaptionTrack >= 0)
                        this._setActiveTextTrack(currentClosedCaptionTrack);
                },

                _onStopCommandInvoked: function () {
                    if (this.stopButtonEnabled &&
                        this.stopButtonVisible) {
                        this.stop();
                    }
                },

                _onVolumeCommandInvoked: function () {
                    if (!this._volumeFlyout) {
                        var flyoutElement = _Global.document.createElement("div");
                        addClass(flyoutElement, "tv-mediaplayer-volume");
                        addClass(flyoutElement, "tv-mediaplayer-overlay");
                        flyoutElement.innerHTML = '     <div class="tv-mediaplayer-volume-heading">Speakers</div>' +
                                                    '     <div class="tv-mediaplayer-volume-controls">' +
                                                    '       <button class="tv-mediaplayer-mutebutton"></button>' +
                                                    '       <input class=" tv-slider tv-mediaplayer-volume-slider" type="range" />' +
                                                    '       <div class="tv-mediaplayer-volume-value"></div>' +
                                                    '     </div>';
                        this._volumeFlyout = new _Flyout.Flyout(flyoutElement);
                        this._volumeButton.type = "flyout";
                        this._volumeButton.flyout = this._volumeFlyout;
                        flyoutElement.style.display = "none";
                        _Global.document.body.appendChild(flyoutElement);

                        this._muteButton = flyoutElement.querySelector(".tv-mediaplayer-mutebutton");
                        if (this._muteButton) {
                            if (this._mediaElementAdapter.mediaElement.volume === 0) {
                                addClass(this._muteButton, "tv-mediaplayer-mute-icon");
                            } else {
                                addClass(this._muteButton, "tv-mediaplayer-volume-icon");
                            }
                        }
                        this._volumeSlider = flyoutElement.querySelector(".tv-mediaplayer-volume-slider");
                        this._volumeValue = flyoutElement.querySelector(".tv-mediaplayer-volume-value");

                        // Attach overlay event handlers
                        this._volumeFlyout.addEventListener("aftershow", this._handleVolumeFlyoutShowCallback, false);
                        this._volumeFlyout.addEventListener("beforeshow", this._handleFlyoutOpenCallbackBind, false);
                        this._volumeFlyout.addEventListener("afterhide", this._handleFlyoutCloseCallbackBind, false);
                        this._volumeSlider.addEventListener("change", this._handleVolumeSliderChangeCallback, false);
                        this._addButtonEventHandler(this._muteButton, "click", this._onMuteCommandInvoked);

                        this._volumeSlider.value = this._mediaElementAdapter.mediaElement.volume * 100;
                    }

                    // Show the flyout
                    if (this._volumeButton) {
                        this._volumeFlyout.show(this._volumeButton, "top");
                    }

                    this._updateUIAndRaiseEvents(mediaCommandEnum.volume, strings.mediaPlayerVolumeButtonLabel);
                },

                _playFromBeginning: function () {
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        if (mediaElement.ended) {
                            mediaElement.load();
                        }

                        if (mediaElement.currentTime !== this._startTime &&
                            mediaElement.readyState >= this._MediaReadyState.MediaReadyState_Have_FutureData) {
                            this._seekInternal(this._startTime, false);
                            mediaElement.playbackRate = mediaElement.defaultPlaybackRate;
                            this._mediaElementAdapter.play();

                            this._endTimeReached = false;
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.playFromBeginning, strings.replayMediaCommandDisplayText);
                    }
                },

                // Recalculate the index of the next custom marker based on the current time
                _recalculateNextAndPreviousCustomMarkerIndexAndTime: function (currentTime) {
                    var markersLength = this._markers.length;
                    var previousCustomMarkerIndexAndTimeSet = false;
                    var nextCustomMarkerIndexAndTimeSet = false;
                    for (var i = 0; i < markersLength; i++) {

                        if (previousCustomMarkerIndexAndTimeSet &&
                            nextCustomMarkerIndexAndTimeSet) {
                            return;
                        }

                        if (!nextCustomMarkerIndexAndTimeSet &&
                            this._markers[i].time >= currentTime) {
                            this._nextCustomMarkerIndex = i;
                            this._nextCustomMarkerTime = this._markers[i].time;

                            nextCustomMarkerIndexAndTimeSet = true;
                        }
                        if (!previousCustomMarkerIndexAndTimeSet &&
                            this._markers[i].time <= currentTime) {
                            this._previousCustomMarkerIndex = i;
                            this._previousCustomMarkerTime = this._markers[i].time;

                            previousCustomMarkerIndexAndTimeSet = true;
                        }
                    }
                },

                // Get sizes for the UI elements used for seeking logic.
                _recalculateCachedUIElementSizes: function () {
                    setImmediate(function () {
                        if (this._disposed) {
                            return;
                        }

                        this._totalSeekBarWidth = this._seekBar.clientWidth;
                        this._seekBarLeftOffset = this._seekBar.offsetLeft;
                        this._thumbElementWidthDividedByTwo = this._thumbElement.clientWidth / 2;
                        this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;
                    }.bind(this));
                },

                _refreshAudioTracksMenu: function () {
                    // Programmatically remove all old buttons
                    var oldButtons = this._audioTracksFlyout.element.querySelectorAll("button");
                    for (var i = 0, len = oldButtons.length; i < len; i++) {
                        oldButtons[i].parentNode.removeChild(oldButtons[i]);
                    }
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.audioTracks) {
                        var audioTracks = this._mediaElementAdapter.mediaElement.audioTracks;
                        for (var i = 0, len = audioTracks.length; i < len; i++) {
                            var currentTrack = audioTracks[i];
                            var audioTrackOption = _Global.document.createElement("button");
                            audioTrackOption.textContent = currentTrack.label || currentTrack.language;
                            if (_WinRT.Windows.Globalization.Language && !currentTrack.label) {
                                if (currentTrack.language) {
                                    var language = new _WinRT.Windows.Globalization.Language(currentTrack.language);
                                    audioTrackOption.textContent = language.displayName;
                                }
                            }
                            if (currentTrack.enabled) {
                                addClass(audioTrackOption, "tv-active");
                            }
                            audioTrackOption.addEventListener("click", (function generatedClickHandler(metadata) {
                                return function handleClick() {
                                    if (metadata &&
                                        !metadata.enabled) {
                                        metadata.enabled = true;
                                        this._refreshAudioTracksMenu();
                                    }
                                }.bind(this);
                            }.bind(this))(currentTrack));
                            this._audioTracksFlyout.element.appendChild(audioTrackOption);
                        }
                    }
                },

                _refreshClosedCaptionsMenu: function () {
                    // Programmatically remove all old buttons
                    var oldButtons = this._closedCaptionsFlyout.element.querySelectorAll("button");
                    for (var i = 0, len = oldButtons.length; i < len; i++) {
                        oldButtons[i].parentNode.removeChild(oldButtons[i]);
                    }
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.textTracks) {
                        var textTracks = this._mediaElementAdapter.mediaElement.textTracks;

                        for (var i = 0, len = textTracks.length; i < len; i++) {
                            var currentTrack = textTracks[i];
                            if (currentTrack.kind === "captions" ||
                                currentTrack.kind === "subtitles") {
                                var closedCaptionsOption = _Global.document.createElement("button");
                                closedCaptionsOption.textContent = currentTrack.label;
                                if (currentTrack.mode === "showing") {
                                    addClass(closedCaptionsOption, "tv-active");
                                    closedCaptionsOption.textContent += " " + strings.mediaPlayerOverlayActiveOptionIndicator;
                                } else if (currentTrack.mode === "hidden") {
                                    addClass(closedCaptionsOption, "tv-mediaplayer-hidden");
                                }
                                closedCaptionsOption.addEventListener("click", (function generatedClickHandler(currentTrack, i) {
                                    return function handleClick() {
                                        this._setActiveTextTrack(i);
                                    }.bind(this);
                                }.bind(this))(currentTrack, i));
                                this._closedCaptionsFlyout.element.appendChild(closedCaptionsOption);
                            }
                        }

                        // Create the menu option for turning closed captions off entirely
                        var closedCaptionsOption = _Global.document.createElement("button");
                        closedCaptionsOption.textContent = strings.closedCaptionsLabelNone;
                        closedCaptionsOption.addEventListener("click", function handleClick() {
                            this._setActiveTextTrack(null);
                        }.bind(this));
                        this._closedCaptionsFlyout.element.appendChild(closedCaptionsOption);
                    }
                },

                _refreshTransportBarButtons: function () {
                    // Remove old commands
                    var children = this._commandsContainer.children;
                    for (var i = children.length - 1; i >= 0; i--) {
                        children[i].parentNode.removeChild(children[i]);
                    }

                    // Replace with new commands list
                    var commands = this._commandsInternal;
                    for (var i = 0, len = commands.length; i < len; i++) {
                        this._commandsContainer.appendChild(commands[i]);
                    }
                },

                _removeButtonEventHandlers: function () {

                    if (this._buttonEventSubscriptions) {
                        for (var i = 0; i < this._buttonEventSubscriptions.length; i++) {
                            var button = this._buttonEventSubscriptions[i].button;
                            var eventName = this._buttonEventSubscriptions[i].eventName;
                            var handler = this._buttonEventSubscriptions[i].handler;
                            button.removeEventListener(eventName, handler);
                        }

                        this._buttonEventSubscriptions = [];
                    }
                },

                // Remove the auto hide timer for hiding controls
                _removeControlsTimer: function () {

                    if (this._controlHideTimeout) {
                        _Global.clearTimeout(this._controlHideTimeout);
                        this._controlHideTimeout = null;
                    }
                },

                _removeGestureEventHandlers: function () {

                    if (this._gestureEventSubscriptions) {
                        for (var i = 0; i < this._gestureEventSubscriptions.length; i++) {
                            var owner = this._gestureEventSubscriptions[i].owner;
                            var eventName = this._gestureEventSubscriptions[i].eventName;
                            var handler = this._gestureEventSubscriptions[i].handler;
                            owner.removeEventListener(eventName, handler);
                        }

                        this._gestureEventSubscriptions = [];
                    }
                },

                // Reset the auto hide timer of the controls if available
                _resetAutoHideControlsTimer: function () {

                    if (this._controlHideTimeout) {
                        var that = this;

                        _Global.clearTimeout(this._controlHideTimeout);

                        this._controlHideTimeout = _Global.setTimeout(function () {
                            that._hideControls();
                        }, this._CONTROLS_AUTO_HIDE_DURATION);
                    }
                },

                // Resets both the controls timer 
                _resetAutoHideTimers: function () {

                    this._resetAutoHideControlsTimer();
                },

                // This function should be called whenever the media source changes
                _resetInternalState: function () {

                    this._isBusy = false;
                    this._isChapterMarkerVisualsDirty = false;
                    this._doesEndTimeNeedResetting = true;
                    this._doesStartTimeNeedResetting = true;
                    this._doMarkersNeedResetting = true;
                    this._defaultChapterMarkers = [];
                    this._endTime = 0;
                    this._endTimeReached = false;
                    this._hasCustomMarkers = false;
                    this._lastFastForwardOrRewindTimerTime = 0;
                    this._fastForwardOrRewindTimerElapsedTime = 0;
                    this._isInFastForwardOrRewindMode = false;
                    this._nextCustomMarkerIndex = -1;
                    this._nextCustomMarkerTime = -1;
                    this._previousCustomMarkerIndex = -1;
                    this._previousCustomMarkerTime = -1;
                    this._startTime = 0;
                    this._targetPlaybackRate = 0;
                    this._targetCurrentTime = 0;
                    this._totalTimeInternal = 0;
                    this._wasStartTimeSetProgrammatically = false;
                    this._wasEndTimeSetProgrammatically = false;
                    this._wasTimeClampedToEndTime = false;

                    // Reset the progress bar
                    this._progress.style[_BaseUtils._browserStyleEquivalents["transform"].scriptName] = "scaleX(0)";
                },

                _seekInternal: function (newTime, wasCalledProgrammatically) {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.seek &&
                        this._mediaElementAdapter.isSeekAllowed) {

                        this._exitFastForwardOrRewind(true);

                        if (newTime < this._startTime) {
                            newTime = this._startTime;
                        } else if (newTime > this._endTime) {
                            newTime = this._endTime;
                        }

                        if (this._mediaElementAdapter.isLive) {
                            if (newTime > this._liveTime) {
                                newTime = this._liveTime;
                            } else if (newTime > this._endTime) {
                                newTime = this._endTime;
                            }
                        }

                        // Checking if the seek time is a valid number saves us from possible crashes. Also, if it was a user initiated
                        // seek, then we check to make sure the MediaElement is in a valid state & can seek without throwing an exception.
                        // Note: we don't perform this check if the developer calls seek programmatically, because hiding the exception and
                        // failing silently would create hard to track down bugs for the developer.
                        if (!isNaN(newTime) &&
                           (wasCalledProgrammatically ||
                           (!wasCalledProgrammatically &&
                            this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement &&
                            this._mediaElementAdapter.mediaElement.readyState >= this._MediaReadyState.MediaReadyState_Have_FutureData))) {
                            this._mediaElementAdapter.seek(newTime);
                        }

                        if (wasCalledProgrammatically) {
                            this._updateUIAndRaiseEvents(mediaCommandEnum.seek, null);
                        }
                    }
                },

                _getActiveTrack: function () {
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.textTracks) {
                        var textTracks = this._mediaElementAdapter.mediaElement.textTracks;
                        for (var i = 0, len = textTracks.length; i < len; i++) {
                            var currentTrack = textTracks[i];
                            if ((currentTrack.kind === "captions" || currentTrack.kind === "subtitles")  && currentTrack.mode == "showing" ) {
                                return i;
                            }                         
                        }
                    }
                    return -1;
                },
                
                _setActiveTextTrack: function (index) {
                    var closedCaptionsOptions = this._closedCaptionsFlyout.element.querySelectorAll("button");
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.textTracks) {
                        var textTracks = this._mediaElementAdapter.mediaElement.textTracks;
                        for (var i = 0, len = textTracks.length; i < len; i++) {
                            var currentTrack = textTracks[i];
                            if (currentTrack.kind === "captions" ||
                                    currentTrack.kind === "subtitles") {
                                var correspondingClosedCaptionsOption = closedCaptionsOptions[i];
                                correspondingClosedCaptionsOption.textContent = currentTrack.label;
                                if (i === index) {
                                    currentTrack.mode = "showing";
                                    addClass(correspondingClosedCaptionsOption, "tv-active");
                                    correspondingClosedCaptionsOption.textContent += " " + strings.mediaPlayerOverlayActiveOptionIndicator;
                                } else {
                                    textTracks[i].mode = "hidden";
                                    removeClass(correspondingClosedCaptionsOption, "tv-active");
                                }
                            }
                        }
                    }
                },

                // Start an auto hide timer for hiding controls
                _setControlsTimer: function () {

                    var that = this;
                    this._controlHideTimeout = _Global.setTimeout(function () {
                        that._hideControls();
                    }, this._CONTROLS_AUTO_HIDE_DURATION);
                    this._lastControlsResetTimeStamp = Date.now();
                },

                _setFastForwardOrRewindText: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        var currentPlaybackRate = this._PLAYBACKRATE_NOT_PLAYING;

                        if (this._simulatedFastForwardMode) {
                            currentPlaybackRate = this._targetPlaybackRate;
                        } else {
                            currentPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                        }

                        var playbackSpeedText = "";
                        var mediaCommand = "";
                        if (currentPlaybackRate >= this._PLAYBACKRATE_FAST_FORWARD_2X) {
                            var fastForwardAmount = Math.floor(currentPlaybackRate / this._mediaElementAdapter.mediaElement.defaultPlaybackRate);
                            mediaCommand = mediaCommandEnum.fastForward;
                            playbackSpeedText = _Resources._formatString(strings.fastForwardFeedbackDisplayText, fastForwardAmount);
                        } else if (currentPlaybackRate <= this._PLAYBACKRATE_REWIND_2X) {
                            var rewindAmount = Math.floor(currentPlaybackRate / (-1 * this._mediaElementAdapter.mediaElement.defaultPlaybackRate));
                            mediaCommand = mediaCommandEnum.rewind;
                            playbackSpeedText = _Resources._formatString(strings.rewindFeedbackDisplayText, rewindAmount);
                        } else if (currentPlaybackRate === this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE) {
                            mediaCommand = mediaCommandEnum.fastForward;
                            playbackSpeedText = strings.fastForwardFeedbackSlowMotionDisplayText;
                        } else if (currentPlaybackRate === this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE) {
                            mediaCommand = mediaCommandEnum.rewind;
                            playbackSpeedText = strings.rewindFeedbackSlowMotionDisplayText;
                        } else {
                            mediaCommand = mediaCommandEnum.play;
                            playbackSpeedText = strings.playMediaCommandDisplayText;
                        }

                        this._playbackSpeedIndicator.textContent = playbackSpeedText;
                        this.dispatchEvent("mediacommandexecuted", { mediaCommand: mediaCommand });
                        this._updateMediaState(false);
                    }
                },

                _setupNewMediaElement: function (newMediaElement, oldMediaElement) {
                    // If there's an old mediaElement, we need to remove event listeners and CSS classes from it
                    if (oldMediaElement) {
                        this._resetInternalState();
                        this._unsubscribeFromMediaEvents(oldMediaElement);
                        removeClass(oldMediaElement, "tv-mediaplayer-video");
                    }

                    // Add the new mediaElement to the tree
                    if (newMediaElement &&
                        this._element) {

                        // Make sure it's not showing controls
                        newMediaElement.controls = false;
                        addClass(newMediaElement, "tv-mediaplayer-video");

                        // The following adds the appropriate classes based on whether 
                        // we're full screen or not
                        if (this._fullScreen) {
                            this.isFullScreen = true;
                        } else {
                            this.isFullScreen = false;
                            this.element.tabIndex = 0;
                        }

                        this._recalculateCachedUIElementSizes();
                        var elementToInsertMediaElementBefore = null;
                        elementToInsertMediaElementBefore = this._element.querySelector(".tv-mediaplayer-controls");
                       
                        if (elementToInsertMediaElementBefore &&
                            elementToInsertMediaElementBefore.parentNode &&
                            !newMediaElement._mockMediaElement) { // The last clause is added for testing so we don't have to have an actual DOM element when running unit tests
                            elementToInsertMediaElementBefore.parentNode.insertBefore(newMediaElement, elementToInsertMediaElementBefore);
                        }

                        if (newMediaElement) {

                            if (newMediaElement.tagName === this._TAG_NAME_AUDIO) {
                                if (this._smtControls) {
                                    this._smtControls.displayUpdater.type = _WinRT.Windows.Media.MediaPlaybackType.audio;
                                }
                            } else {
                                if (this._smtControls) {
                                    this._smtControls.displayUpdater.type = _WinRT.Windows.Media.MediaPlaybackType.video;
                                }
                            }

                            // If the new media element is already loaded, we need to update MediaPlayer properties
                            if (newMediaElement.readyState > this._MediaReadyState.MediaReadyState_Have_Metadata) {
                                this._updateDefaultStartAndEndTime(newMediaElement);
                            }

                            if (this._controlsVisible) {
                                this._subscribeToTimeUpdates();
                            }

                            // Update timeline
                            this._updateTimelineVisuals();
                        }
                    }

                    // Set initial button state
                    if (newMediaElement) {
                        if (newMediaElement.paused) {
                            this._showPlayButton();
                        } else {
                            this._showPauseButton();
                        }
                    }

                    // If the video has already loaded it's metadata, then we need to set the startTime, endTime, and clear markers
                    if (newMediaElement &&
                        newMediaElement.readyState >= this._MediaReadyState.MediaReadyState_Have_FutureData) {

                        if (oldMediaElement) {
                            this._doesEndTimeNeedResetting = false;
                            this._doesStartTimeNeedResetting = false;
                            this._doMarkersNeedResetting = false;
                        }

                        this._updateDefaultStartAndEndTime(newMediaElement);

                        if (!this._wasEndTimeSetProgrammatically) {
                            this._totalTime = newMediaElement.duration - this._startTime;
                            this._updateTimelineVisuals();
                        }

                        // We need to clear any existing markers, so that _initializeChapterMarkers does
                        // not think that the developer already specified chapter markers when they did not.
                        this._markers.length = 0;
                        this._initializeChapterMarkers(newMediaElement);
                    } else {
                        if (oldMediaElement) {
                            this._doesEndTimeNeedResetting = true;
                            this._doesStartTimeNeedResetting = true;
                            this._doMarkersNeedResetting = true;
                        }
                    }

                    // We do not need to check if the newMediaElement is null, because one of the sub-functions
                    // in this._subscribeToMediaEvents will do that check.
                    this._subscribeToMediaEvents(newMediaElement);

                    if (this._smtControls) {
                        this._smtControls.isNextEnabled = (this.chapterSkipForwardButtonEnabled && this.chapterSkipForwardButtonVisible) || (this.nextTrackButtonEnabled && this.nextTrackButtonVisible);
                        this._smtControls.isPreviousEnabled = (this.chapterSkipBackButtonEnabled && this.chapterSkipBackButtonVisible) || (this.previousTrackButtonEnabled && this.previousTrackButtonVisible);
                    }
                },

                // Show the controls bar, controls bar will slide/fade in, but will auto hide automatically.
                // force tried to alway show controls irrespective playback happening or not.
                _showControls: function (force, doNotAutoHide) {
                    if ((this._controlsVisible &&
                        !force) ||
                        this._disposed) {
                        return;
                    }

                    if (!this._totalSeekBarWidth) {
                        this._totalSeekBarWidth = this._seekBar.clientWidth;
                        this._seekBarLeftOffset = this._seekBar.offsetLeft;
                        this._thumbElementWidthDividedByTwo = this._thumbElement.clientWidth / 2;
                        this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;
                    }

                    // Only show the controls if we actually playing back something
                    if ((this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.currentSrc) ||
                        force) {

                        var defaultNotPrevented = this._dispatchCancellableEvent("beforeshowcontrols", {});

                        if (defaultNotPrevented) {
                            removeClass(this._controls, "tv-mediaplayer-hidden");
                            this._controlsVisible = true;
                            this._updateChapterMarkerVisuals();

                            if (!this._controlHideTimeout) {
                                this._controlsHideTimeout = this._setControlsTimer();
                            }

                            this._transportControls.style.opacity = 1;

                            // Visible transport bar buttons
                            var visibleAllTransportBarButtons = [];
                            // Grab all the buttons
                            var allTransportBarButtons = this._transportControls.querySelectorAll("button");
                            for (var i = 0, len = allTransportBarButtons.length; i < len; i++) {
                                var currentButton = allTransportBarButtons[i];
                                if (currentButton.winControl && !currentButton.winControl.hidden) {
                                    visibleAllTransportBarButtons.push(allTransportBarButtons[i]);
                                }
                            }

                            var that = this;
                            Animations._mediaPlayerShowControlsAnimation({
                                skipAnimations: this._skipAnimations,
                                compact: this._compact,
                                progressContainer: this._progressContainer,
                                mediacontrols: this._controls,
                                visibleTransportBarButtons: visibleAllTransportBarButtons
                            }).then(function () {
                                if (that._disposed) {
                                    return;
                                }
                                that.dispatchEvent("aftershowcontrols", {});
                            });

                            if ((!wuiv.ApplicationView ||
                                (wuiv.ApplicationView && wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped)) &&
                                !this._isInFastForwardOrRewindMode &&
                                !doNotAutoHide) {
                                this._setControlsTimer();
                            }

                            // Subscribe to media position change events again
                            this._subscribeToTimeUpdates();

                            this._updateTimelineVisuals();
                        }
                    }
                },

                _playHideControlsAnimation: function () {
                    if (this._skipAnimations) {
                        return Promise.wrap();
                    }

                    // Grab all the buttons
                    var allTransportBarButtons = this._transportControls.querySelectorAll("button");
                    var visibleTransportBarButtons = [];
                    for (var i = 0, len = allTransportBarButtons.length; i < len; i++) {
                        var currentButton = allTransportBarButtons[i];
                        if (currentButton.winControl && !currentButton.winControl.hidden) {
                            visibleTransportBarButtons.push(allTransportBarButtons[i]);
                        }
                    }

                    var animationPromises = [];
                    // Do an animation on them
                    animationPromises.push(_TransitionAnimation.executeAnimation(visibleTransportBarButtons, [{
                        property: _BaseUtils._browserStyleEquivalents["transform"].cssName,
                        delay: 0,
                        duration: 333,
                        timing: "cubic-bezier(0.71, 0.01, 0.84, 0)",
                        from: "none",
                        to: "translateY(100px)"
                    }]));

                    // Animate the timeline
                    animationPromises.push(_TransitionAnimation.executeAnimation(this._progressContainer, [{
                        property: _BaseUtils._browserStyleEquivalents["transform"].cssName,
                        delay: 0,
                        duration: 333,
                        timing: "cubic-bezier(0.71, 0.01, 0.84, 0)",
                        from: "none",
                        to: "translateY(100px)"
                    }]));

                    animationPromises.push(_TransitionAnimation.executeTransition(this._controls, [{
                        property: "opacity",
                        delay: 0,
                        duration: 333,
                        timing: "linear",
                        from: 1,
                        to: 0
                    }]));

                    return Promise.join(animationPromises);
                },

                _startFastForwardOrRewind: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.pause &&
                        this._mediaElementAdapter.mediaElement) {

                        // Set the playbackRate to zero & pause the video
                        this._previousPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                        this._mediaElementAdapter.mediaElement.playbackRate = 0;
                        this._mediaElementAdapter.pause();

                        // Start the fastForwardAndRewind timer
                        this._fastForwardOrRewindTimerElapsedTime = 0;
                        this._lastFastForwardOrRewindTimerTime = new Date().getTime();

                        var that = this;
                        this._onFastForwardRewindTimerTick();
                        this._fastForwardOrRewindTimer = _Global.setInterval(function () { that._onFastForwardRewindTimerTick(); }, this._FAST_FORWARD_OR_REWIND_TIMER_INTERVAL);

                        // Show the thumbnails if thumbnail mode is enabled
                        if (this._thumbnailImage) {
                            removeClass(this._thumbElement, "tv-mediaplayer-hidden");
                            removeClass(this._thumbnailImage, "tv-mediaplayer-hidden");

                            if (this._targetPlaybackRate === 0 ||
                                this._targetPlaybackRate === 1) {
                                removeClass(this._element, "tv-mediaplayer-scrubbing");
                                removeClass(this._element, "tv-mediaplayer-rewind");
                                removeClass(this._element, "tv-mediaplayer-fastforward");
                            } else if (this._targetPlaybackRate > 0) {
                                removeClass(this._element, "tv-mediaplayer-scrubbing");
                                removeClass(this._element, "tv-mediaplayer-rewind");
                                addClass(this._element, "tv-mediaplayer-fastforward");
                            } else if (this._targetPlaybackRate < 0) {
                                removeClass(this._element, "tv-mediaplayer-scrubbing");
                                removeClass(this._element, "tv-mediaplayer-fastforward");
                                addClass(this._element, "tv-mediaplayer-rewind");
                            }

                            // We need this value for scrubbing to make sure the thumbnail image doesn't go past the timeline.
                            if (!this._thumbImageElementWidthDividedByTwo) {
                                this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;
                            }
                        }

                        this._isInFastForwardOrRewindMode = true;

                        // If we are starting a new FF or RR operation we need to set this variable to false, otherwise
                        // the user will be unable to FF all the way to the end.
                        this._wasTimeClampedToEndTime = false;
                    }
                },

                // Turns the playpause toggle button into a pause button
                _showPauseButton: function () {
                    this._playPauseButtonIcon.classList.remove("tv-mediaplayer-playicon");
                    this._playPauseButtonIcon.classList.add("tv-mediaplayer-pauseicon");
                    if (this._smtControls) {
                        this._smtControls.isPauseEnabled = true;
                        this._smtControls.isPlayEnabled = false;
                    }
                },

                // Turns the playpause toggle button into a play button
                _showPlayButton: function () {
                    this._playPauseButtonIcon.classList.remove("tv-mediaplayer-pauseicon");
                    this._playPauseButtonIcon.classList.add("tv-mediaplayer-playicon");
                    if (this._smtControls) {
                        this._smtControls.isPauseEnabled = false;
                        this._smtControls.isPlayEnabled = true;
                    }
                },

                // Subscribes to the 'timeupdate' event
                _subscribeToTimeUpdates: function () {

                    // Make sure there is only one 'timeupdate' event ever, so we remove it first every time
                    var that = this;
                    this._unsubscribeFromTimeUpdates();
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        this._addMediaEventListener(this._mediaElementAdapter.mediaElement, "timeupdate", function () {
                            that._onTimeUpdate();
                        });
                    }
                },

                _subscribeToMediaEvents: function (mediaElement) {
                    var that = this;

                    this._addMediaEventListener(mediaElement, "addtrack", function () {
                        that._updateAudioTracksButtonStateBind();
                        that._updateClosedCaptionsButtonStateBind();
                    });

                    this._addMediaEventListener(mediaElement, "canplay", function () {
                        that._onCanPlay();
                    });

                    this._addMediaEventListener(mediaElement, "change", function () {
                        that._updateAudioTracksButtonStateBind();
                        that._updateClosedCaptionsButtonStateBind();
                    });

                    this._addMediaEventListener(mediaElement, "durationchange", function () {
                        that._onDurationChange();
                    });

                    this._addMediaEventListener(mediaElement, "emptied", function () {
                        that._onEmptied();
                    });

                    this._addMediaEventListener(mediaElement, "ended", function () {
                        that._onEnded();
                    });

                    this._addMediaEventListener(mediaElement, "error", function (ev) {
                        that._onError(ev);
                    });

                    this._addMediaEventListener(mediaElement, "loadstart", function () {
                        that._onLoadStart();
                    });

                    this._addMediaEventListener(mediaElement, "loadedmetadata", function () {
                        that._onLoadedMetadata();
                    });

                    this._addMediaEventListener(mediaElement, "pause", function () {
                        that._onPause();
                    });

                    this._addMediaEventListener(mediaElement, "play", function () {
                        that._onPlay();
                    });

                    this._addMediaEventListener(mediaElement, "playing", function () {
                        that._onPlaying();
                    });

                    this._addMediaEventListener(mediaElement, "progress", function () {
                        that._onProgress();
                    });

                    this._addMediaEventListener(mediaElement, "ratechange", function () {
                        that._onRateChange();
                    });

                    this._addMediaEventListener(mediaElement, "removetrack", function () {
                        that._updateAudioTracksButtonStateBind();
                        that._updateClosedCaptionsButtonStateBind();
                    });

                    this._addMediaEventListener(mediaElement, "seeked", function () {
                        that._onSeeked();
                    });

                    this._addMediaEventListener(mediaElement, "seeking", function () {
                        that._onSeeking();
                    });
                },

                // Updates the seek bar position to match the current media play time
                _syncTimeAndProgress: function (force) {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        (!wuiv.ApplicationView || (wuiv.ApplicationView && wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped))) {

                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        var startTime = this._startTime;
                        var endTime = this._endTime;
                        var currentTime = mediaElement.currentTime - startTime;
                        var transformName = _BaseUtils._browserStyleEquivalents["transform"].scriptName;

                        var progress = 0;
                        if (!this._mediaElementAdapter.mediaElement.paused || force) {
                            if (!this._isThumbGrabbed &&
                                !this._isInFastForwardOrRewindMode &&
                                (force || this._controlsVisible)) {

                                if (!this._totalSeekBarWidth &&
                                    this._seekBar.clientWidth) {
                                    this._totalSeekBarWidth = this._seekBar.clientWidth;
                                }
                                progress = currentTime / this._totalTime;
                                var amountToMoveSeekVisuals = progress * this._totalSeekBarWidth;
                                this._currentTimeVisualElements.style[transformName] = "translateX(" + amountToMoveSeekVisuals + "px)";
                            }

                            if (currentTime > endTime) {
                                currentTime = endTime;
                            }

                            if (this._progress &&
                                !this._isThumbGrabbed) {
                                if (this._totalTime !== 0) {
                                    this._progress.style[transformName] = "scaleX(" + progress + ")";
                                } else {
                                    // If the totalTime is zero (this typically happens while the video is buffering for the 1st time)
                                    // then instead of showing a full progress bar (0/0) we show an empty one.
                                    this._progress.style[transformName] = "scaleX(0)";
                                }
                            }
                        }
                    }
                },

                _timelineClickHandler: function (ev) {
                    var newPosition = (ev.x / this._totalSeekBarWidth) * this._totalTime;
                    this._seekInternal(newPosition);
                },

                // Unsubscribe from previously subscribed media events
                _unsubscribeFromMediaEvents: function (mediaElement) {

                    if (mediaElement) {
                        var mediaEventSubscriptionsLength = this._mediaEventSubscriptions.length;
                        for (var i = 0; i < mediaEventSubscriptionsLength; i++) {
                            mediaElement.removeEventListener(this._mediaEventSubscriptions[i].eventName, this._mediaEventSubscriptions[i].handler);
                        }
                    }

                    this._mediaEventSubscriptions = [];
                },

                // Unsubscribe a specific media event
                _unsubscribeFromMediaEvent: function (eventName) {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        var mediaEventSubscriptionsLength = this._mediaEventSubscriptions.length;
                        for (var i = 0, len = mediaEventSubscriptionsLength; i < len; i++) {
                            var otherEventName = this._mediaEventSubscriptions[i].eventName;
                            if (eventName === otherEventName) {
                                this._mediaElementAdapter.mediaElement.removeEventListener(otherEventName, this._mediaEventSubscriptions[i].handler);
                                this._mediaEventSubscriptions.splice(i, 1);
                                break;
                            }
                        }
                    }
                },

                // Unsubscribe to "timeupdate" events from MPT
                _unsubscribeFromTimeUpdates: function () {

                    if (!this._hasCustomMarkers &&
                        !this._controlsVisible) {
                        this._unsubscribeFromMediaEvent("timeupdate");
                    }
                },

                _updateAudioTracksButtonState: function () {
                    // If there are any text tracks then enable and show the audio tracks button
                    var hasAtLeastTwoAudioTracksTrack = false;
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.audioTracks &&
                        this._mediaElementAdapter.mediaElement.audioTracks.length > 1) {
                        hasAtLeastTwoAudioTracksTrack = true;
                    }
                    this._audioTracksButton.style.display = hasAtLeastTwoAudioTracksTrack ? "inline-block" : "none";
                },

                // This method actually updates all marker visuals, not just chapter marker visuals
                _updateChapterMarkerVisuals: function () {
                    if (this._isChapterMarkerVisualsDirty ||
                            this._totalSeekBarWidth != this._seekBar.clientWidth) {
                        var markers = null;
                        if (this._defaultChapterMarkers.length) {
                            markers = this._markers.concat(this._defaultChapterMarkers);
                        } else {
                            markers = this._markers;
                        }

                        // Remove existing markers from the timeline
                        if (this._seekBar.parentNode) {
                            var oldMarkers = this._seekBar.parentNode.querySelectorAll(".tv-mediaplayer-marker");
                            var oldMarkersLength = oldMarkers.length;
                            for (var i = 0; i < oldMarkersLength; i++) {
                                oldMarkers[i].parentNode.removeChild(oldMarkers[i]);
                            }
                        }

                        // Add markers to the timeline
                        var currentMarkerTime = null;
                        var markersLength = markers.length;
                        for (var i = 0; i < markersLength; i++) {

                            currentMarkerTime = markers[i].time;
                            // Note: We check if currentMarkerTime is 'null' rather than checking "if (currentMarkerTime)", 
                            // because currentMarkerTime with a value of zero is valid.
                            if (markers[i].extraClass &&
                                typeof currentMarkerTime === "number") {

                                // The totalSeekBarWidth is sometimes calculated when controls are shown for the 1st time.
                                // That means it is possible that the seek bar width has not been calculated and we need to calculate it.
                                if (!this._totalSeekBarWidth) {
                                    this._totalSeekBarWidth = this._seekBar.clientWidth;
                                    this._thumbElementWidthDividedByTwo = this._thumbElement.clientWidth / 2;
                                    this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;
                                }

                                // Create a DOM element for each marker
                                var marker = _Global.document.createElement("div");
                                marker.id = "ms__marker" + (currentMarkerTime.toString()).replace(".", "_");
                                addClass(marker, "tv-mediaplayer-marker");
                                addClass(marker, markers[i].extraClass);

                                var percentageTime = currentMarkerTime / this._totalTime;
                                var currentTimeLeftOffset = percentageTime * this._totalSeekBarWidth;
                                marker.style.left = currentTimeLeftOffset + "px";

                                if (this._seekBar.parentNode) {
                                    this._seekBar.parentNode.insertBefore(marker, this._seekBar.nextElementSibling);
                                }
                            }
                        }

                        // If the total width of the seekbar is zero (meaning it hasn't been calculated), then
                        // we need to leave _isChapterMarkerVisualsDirty as true, otherwise all markers will have
                        // a position of zero on the timeline.
                        this._isChapterMarkerVisualsDirty = (this._totalSeekBarWidth === 0);
                    }
                },

                _updateClosedCaptionsButtonState: function () {
                    // If there are any text tracks then enable and show the closed captions button
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        this._mediaElementAdapter.mediaElement.textTracks) {
                        var hasAtLeastOneCaptionsTrack = false;
                        var textTracks = this._mediaElementAdapter.mediaElement.textTracks;
                        for (var i = 0, len = textTracks.length; i < len; i++) {
                            var currentTrack = textTracks[i];
                            if (currentTrack.kind === "captions" ||
                                currentTrack.kind === "subtitles") {
                                hasAtLeastOneCaptionsTrack = true;
                                break;
                            }
                        }
                        this._closedCaptionsButton.style.display = hasAtLeastOneCaptionsTrack ? "inline-block" : "none";
                    }
                },

                _updateDefaultStartAndEndTime: function (mediaElement) {

                    // Note: We are not worried that by calling 'this.startTime = ' rather than 'this._endTime' we will
                    // set _wasStartTimeSetProgrammatically to 'true' incorrectly, because we reset those values to false later in the function. 
                    if (!this._wasStartTimeSetProgrammatically) {
                        this._startTime = mediaElement.initialTime || 0;

                        // Reset default chapter markers
                        if (this._defaultChapterMarkers.length) {
                            this._initializeDefaultChapterMarkers();
                        }

                        // Update the time display
                        this._updateTimelineVisuals();
                    }
                    if (!this._wasEndTimeSetProgrammatically) {
                        this._endTime = mediaElement.duration;

                        // Reset default chapter markers
                        if (this._defaultChapterMarkers.length) {
                            this._initializeDefaultChapterMarkers();
                        }

                        // Update the time display
                        this._updateTimelineVisuals();
                    }

                    // Note: We need to reset these values because when a new media src is loaded
                    // we don't care if someone previously set startTime or endTime programmatically.
                    // Since it is a new src, we want these values to be clean.
                    if (this._doesStartTimeNeedResetting) {
                        this._wasStartTimeSetProgrammatically = false;
                    }
                    if (this._doesEndTimeNeedResetting) {
                        this._wasEndTimeSetProgrammatically = false;
                    }

                    this._updateTimeDisplay();
                },

                // When the DOM for the MediaPlayer changes, call this function to re-attach event listeners
                _initializeDomElements: function () {
                    this._removeButtonEventHandlers();

                    var mediaPlaybackContent = this._element.querySelector(".tv-mediaplayer");
                    if (!mediaPlaybackContent) {
                        mediaPlaybackContent = _Global.document.createElement("div");
                        addClass(mediaPlaybackContent, "tv-mediaplayer");
                    }

                    // Query for any developer-added custom buttons. The reason we do this before setting the MediaPlayer's innerHTML
                    // is because if we querySelector for all the TVJS.UI.Command objects we'll get the developer added buttons in
                    // addition to the built in ones.
                    this._customButtons = this._element.querySelectorAll("button, .tv-mediaplayer-button");

                    mediaPlaybackContent.innerHTML = this._mediaPlayerHtml;
                    this._element.appendChild(mediaPlaybackContent);

                    // Get references to all the UI elements
                    this._buffer = this._element.querySelector(".tv-mediaplayer-buffer");
                    this._busyIndicator = this._element.querySelector(".tv-mediaplayer-busy");
                    this._commandsContainer = this._element.querySelector(".tv-mediaplayer-transportcontrols-commands");
                    this._controls = this._element.querySelector(".tv-mediaplayer-controls");
                    this._currentTimeIndicator = this._element.querySelector(".tv-mediaplayer-currenttimeindicator");
                    this._currentTimeVisualElements = this._element.querySelector(".tv-mediaplayer-seekbarvisualelements-container");
                    this._inputHandlerElement = this._element.querySelector(".tv-mediaplayer-inputhandler");
                    this._mediaCommandFeedbackText = this._element.querySelector(".tv-mediaplayer-inputfeedback");
                    this._mediaPlayerContainer = this._element.querySelector(".tv-mediaplayer-container");
                    this._playbackSpeedIndicator = this._element.querySelector(".tv-mediaplayer-playbackspeedindicator");
                    this._progress = this._element.querySelector(".tv-mediaplayer-seekprogress");
                    this._progressContainer = this._element.querySelector(".tv-mediaplayer-progresscontainer");
                    this._metadataTitle = this._element.querySelector(".tv-mediaplayer-mediatitle");
                    this._metadataDescription = this._element.querySelector(".tv-mediaplayer-mediadescription");
                    this._seekBar = this._element.querySelector(".tv-mediaplayer-seekbar");
                    this._seekMark = this._element.querySelector(".tv-mediaplayer-seek-mark");
                    this._seekWindowLeftEdgeElement = this._element.querySelector(".tv-mediaplayer-seek-leftboundary");
                    this._seekWindowRightEdgeElement = this._element.querySelector(".tv-mediaplayer-seek-rightboundary");
                    this._seekTimeIndicator = this._element.querySelector(".tv-mediaplayer-seektimeindicator");
                    this._thumbnailImage = this._element.querySelector(".tv-mediaplayer-thumbnail");
                    this._thumbnailImageVisual = this._element.querySelector(".tv-mediaplayer-thumbnailvisual");
                    this._thumbElement = this._element.querySelector(".tv-mediaplayer-thumb");
                    this._timeline = this._element.querySelector(".tv-mediaplayer-timeline");
                    this._timeRemainingIndicator = this._element.querySelector(".tv-mediaplayer-timeremainingindicator");
                    this._transportControls = this._element.querySelector(".tv-mediaplayer-transportcontrols");
                    this._snappedOverlay = this._element.querySelector(".tv-mediaplayer-snapped-overlay");

                    this._handleFlyoutOpenCallbackBind = this._handleFlyoutOpenCallback.bind(this);
                    this._handleFlyoutCloseCallbackBind = this._handleFlyoutCloseCallback.bind(this);

                    var that = this;
                    // Note: the order the buttons are created in code will be the order they show up in the UI.
                    if (this._commandsContainer) {
                        // Get references to all transport bar buttons.
                        this._chapterSkipBackButton = this._commandsContainer.querySelector("#tv-mediaplayer-chapterskipbackbutton");
                        this._chapterSkipForwardButton = this._commandsContainer.querySelector("#tv-mediaplayer-chapterskipforwardbutton");
                        this._fastForwardButton = this._commandsContainer.querySelector("#tv-mediaplayer-fastforwardbutton");
                        this._nextTrackButton = this._commandsContainer.querySelector("#tv-mediaplayer-nexttrackbutton");
                        this._playFromBeginningButton = this._commandsContainer.querySelector("#tv-mediaplayer-playfrombeginningbutton");
                        this._playPauseButton = this._commandsContainer.querySelector("#tv-mediaplayer-playpausebutton");
                        this._playbackRateButton = this._commandsContainer.querySelector("#tv-mediaplayer-playbackratebutton");
                        this._previousTrackButton = this._commandsContainer.querySelector("#tv-mediaplayer-previoustrackbutton");
                        this._rewindButton = this._commandsContainer.querySelector("#tv-mediaplayer-rewindbutton");
                        this._stopButton = this._commandsContainer.querySelector("#tv-mediaplayer-stopbutton");
                        this._timeSkipBackButton = this._commandsContainer.querySelector("#tv-mediaplayer-timeskipbackbutton");
                        this._timeSkipForwardButton = this._commandsContainer.querySelector("#tv-mediaplayer-timeskipforwardbutton");
                        this._audioTracksButton = this._commandsContainer.querySelector("#tv-mediaplayer-audiotracksbutton");
                        this._closedCaptionsButton = this._commandsContainer.querySelector("#tv-mediaplayer-closedcaptionsbutton");
                        this._goToLiveButton = this._commandsContainer.querySelector("#tv-mediaplayer-livebutton");
                        this._toggleFullScreenButton = this._commandsContainer.querySelector("#tv-mediaplayer-fullscreenbutton");
                        this._castButton = this._commandsContainer.querySelector("#tv-mediaplayer-playonremotedevicebutton");
                        this._volumeButton = this._commandsContainer.querySelector("#tv-mediaplayer-volumebutton");
                        this._zoomButton = this._commandsContainer.querySelector("#tv-mediaplayer-zoombutton");

                        this._playPauseButtonIcon = this._commandsContainer.querySelector(".tv-mediaplayer-playpausetogglevisual");
                        this._fullscreenButtonIcon = this._toggleFullScreenButton.querySelector(".tv-mediaplayer-icon");

                        this._initializeTransportBarButtons();

                        // Logic so that using directional navigation and click will reset the auto-hide timer.
                        this._handleTransportBarButtonFocus = function transportBarButtonFocusHandler(ev) {
                            that._resetAutoHideTimers();
                        };
                        this._handleTransportBarButtonClick = function transportBarButtonClickHandler(ev) {
                            that._resetAutoHideTimers();
                        };

                        // Because we don't key click events on gamepadA
                        this._handleTransportBarButtonKeyDown = function transportBarButtonKeyDownHandler(ev) {
                            if (ev.key === "GamepadA") {
                                addClass(ev.target, "tv-mediaplayer-transportbarbutton-active");
                            }
                        };
                        this._handleTransportBarButtonKeyUp = function transportBarButtonKeyUpHandler(ev) {
                            if (ev.key === "GamepadA") {
                                removeClass(ev.target, "tv-mediaplayer-transportbarbutton-active");
                            }
                        };
                    }

                    var buttonElements = this._transportControls.getElementsByTagName("button");
                    for (var i = 0, buttonElementsLength = buttonElements.length; i < buttonElementsLength; i++) {
                        this._subscribeControlsEvents(buttonElements[i]);
                    }

                    // PlayPause Index in the builtInButtonsList
                    for (var i = 0, len = buttonElements.length; i < len; i++) {
                        if (buttonElements[i].id === "tv-mediaplayer-playpause") {
                            this._playPauseFullIndex = i;
                            break;
                        }
                    }

                    // Attach event handlers
                    this._addButtonEventHandler(this._chapterSkipBackButton, "click", this._onChapterSkipBackCommandInvoked);
                    this._addButtonEventHandler(this._chapterSkipForwardButton, "click", this._onChapterSkipForwardCommandInvoked);
                    this._addButtonEventHandler(this._fastForwardButton, "click", this._onFastForwardCommandInvoked);
                    this._addButtonEventHandler(this._nextTrackButton, "click", this._onNextTrackCommandInvoked);
                    this._addButtonEventHandler(this._playFromBeginningButton, "click", this._onPlayFromBeginningCommandInvoked);
                    this._addButtonEventHandler(this._playPauseButton, "click", this._onPlayPauseCommandInvoked);
                    this._addButtonEventHandler(this._playbackRateButton, "click", this._onPlaybackRateCommandInvoked);
                    this._addButtonEventHandler(this._previousTrackButton, "click", this._onPreviousTrackCommandInvoked);
                    this._addButtonEventHandler(this._rewindButton, "click", this._onRewindCommandInvoked);
                    this._addButtonEventHandler(this._stopButton, "click", this._onStopCommandInvoked);
                    this._addButtonEventHandler(this._timeSkipBackButton, "click", this._onTimeSkipBackCommandInvoked);
                    this._addButtonEventHandler(this._timeSkipForwardButton, "click", this._onTimeSkipForwardCommandInvoked);
                    this._addButtonEventHandler(this._audioTracksButton, "click", this._onAudioTracksCommandInvoked);
                    this._addButtonEventHandler(this._closedCaptionsButton, "click", this._onClosedCaptionsCommandInvoked);
                    this._addButtonEventHandler(this._goToLiveButton, "click", this._onGoToLiveCommandInvoked);
                    this._addButtonEventHandler(this._toggleFullScreenButton, "click", this._onToggleFullscreenCommandInvoked);
                    this._addButtonEventHandler(this._castButton, "click", this._onCastCommandInvoked);
                    this._addButtonEventHandler(this._volumeButton, "click", this._onVolumeCommandInvoked);
                    this._addButtonEventHandler(this._zoomButton, "click", this._onZoomCommandInvoked);

                    this._inputHandlerPointerDownCallback = this._onInputHandlerPointerDown.bind(this);
                    this._inputHandlerPointerMoveCallback = this._onInputHandlerPointerMove.bind(this);
                    this._inputHandlerPointerUpCallback = this._onInputHandlerPointerUp.bind(this);
                    this._inputHandlerClickCallback = this._onInputHandlerClick.bind(this);
                    this._inputHandlerMouseDownCallback = this._inputHandlerMouseDown.bind(this);
                    this._inputHandlerMouseOutCallback = this._inputHandlerMouseOut.bind(this);
                    this._inputHandlerMouseUpCallback = this._inputHandlerMouseUp.bind(this);

                    this._handleVolumeFlyoutShowCallback = this._handleVolumeFlyoutShow.bind(this);
                    this._handleVolumeSliderChangeCallback = this._handleVolumeSliderChange.bind(this);

                    // The following events feed pointer input to the gesture recognizer
                    this._addGestureEventHandler(this._mediaPlayerContainer, "click", this._inputHandlerClickCallback);
                    this._addGestureEventHandler(this._progressContainer, "pointerdown", this._inputHandlerPointerDownCallback);
                    this._addGestureEventHandler(this.element, "pointerover", this._handlePointerHover);
                    this._addGestureEventHandler(this.element, "pointermove", this._inputHandlerPointerMoveCallback);
                    this._addGestureEventHandler(this._controls, "pointerup", this._inputHandlerPointerUpCallback);

                    document.body.addEventListener("mouseleave", this._inputHandlerMouseOutCallback, false);

                    // Set the enabled and visible states for all buttons

                    // Is*Visible properties
                    if (TVJS._tv) {
                        this.chapterSkipBackButtonVisible = false;
                        this.chapterSkipForwardButtonVisible = false;
                        this.fastForwardButtonVisible = true;
                        this.nextTrackButtonVisible = false;
                        this.playFromBeginningButtonVisible = false;
                        this.playPauseButtonVisible = true;
                        this.playbackRateButtonVisible = false;
                        this.previousTrackButtonVisible = false;
                        this.rewindButtonVisible = true;
                        this.stopButtonVisible = false;
                        this.timeSkipBackButtonVisible = false;
                        this.timeSkipForwardButtonVisible = false;
                        this.zoomButtonVisible = false;
                        this.goToLiveButtonVisible = false;
                        this.fullScreenButtonVisible = false;
                        this.castButtonVisible = false;
                        this.playbackRateButtonVisible = false;
                        this.muteButtonVisible = false;
                        this.volumeButtonVisible = false;
                        this.seekBarVisible = true;
                    } else {
                        this.chapterSkipBackButtonVisible = false;
                        this.chapterSkipForwardButtonVisible = false;
                        this.fastForwardButtonVisible = false;
                        this.nextTrackButtonVisible = false;
                        this.playFromBeginningButtonVisible = false;
                        this.playPauseButtonVisible = true;
                        this.playbackRateButtonVisible = false;
                        this.previousTrackButtonVisible = false;
                        this.rewindButtonVisible = false;
                        this.stopButtonVisible = false;
                        this.timeSkipBackButtonVisible = false;
                        this.timeSkipForwardButtonVisible = false;
                        this.zoomButtonVisible = true;
                        this.goToLiveButtonVisible = false;
                        this.fullScreenButtonVisible = true;
                        this.castButtonVisible = true;
                        this.playbackRateButtonVisible = false;
                        this.muteButtonVisible = false;
                        this.volumeButtonVisible = true;
                        this.seekBarVisible = true;
                    }

                    // Is*Enabled properties
                    this.chapterSkipBackButtonEnabled = true;
                    this.chapterSkipForwardButtonEnabled = true;
                    this.fastForwardButtonEnabled = true;
                    this.nextTrackButtonEnabled = true;
                    this.playFromBeginningButtonEnabled = true;
                    this.playPauseButtonEnabled = true;
                    this.previousTrackButtonEnabled = true;
                    this.rewindButtonEnabled = true;
                    this.stopButtonEnabled = true;
                    this.timeSkipBackButtonEnabled = true;
                    this.timeSkipForwardButtonEnabled = true;
                    this.zoomButtonEnabled = true;
                    this.goToLiveButtonEnabled = true;
                    this.castButtonEnabled = true;
                    this.fullScreenButtonEnabled = true;
                    this.playbackRateButtonEnabled = true;
                    this.volumeButtonEnabled = true;
                    this.muteButtonEnabled = true;
                    this.seekingEnabled = true;

                    // Listen for clicks on the seek bar
                    this._addGestureEventHandler(this._progressContainer, "click", this._timelineClickHandler);

                    // For accessibility we listen for arrow keys on the timeline
                    this._timeline.addEventListener("keydown", this._handleTimelineArrowKeyDownBind, false);

                    this._element.addEventListener("keyup", this._controlsKeyupInputHandler, false);

                    _Res.processAll(this._element);
                },

                _subscribeControlsEvents: function (buttonElement) {
                    if (buttonElement) {
                        this._addButtonEventHandler(buttonElement, "focus", this._handleTransportBarButtonFocus);
                        this._addButtonEventHandler(buttonElement, "click", this._handleTransportBarButtonClick);
                        this._addButtonEventHandler(buttonElement, "keydown", this._handleTransportBarButtonKeyDown);
                        this._addButtonEventHandler(buttonElement, "keyup", this._handleTransportBarButtonKeyUp);
                    }
                },

                _updateFastForwardAndRewindState: function (oldPlaybackRate, newPlaybackRate) {

                    if (!this._isFastForwardOrRewind(oldPlaybackRate) &&
                        this._isFastForwardOrRewind(newPlaybackRate)) {
                        this._startFastForwardOrRewind();
                    } else if (this._isFastForwardOrRewind(oldPlaybackRate) &&
                               !this._isFastForwardOrRewind(newPlaybackRate)) {
                        this._exitFastForwardOrRewind(true);
                    } else {
                        // Do nothing
                    }

                    this.dispatchEvent("targetratechange", {});
                    this._updateMediaState(false);
                },

                _updateInfoDisplay: function (mediaCommand) {

                    this._mediaCommandFeedbackText.textContent = mediaCommand;
                },

                // This function updates the state of the SystemMediaTarnsportControls
                _updateMediaState: function (isStopped) {

                    // Return if we are running in an iframe or not on an Xbox
                    if (!wuiv.ApplicationView ||
                        !_WinRT.Windows.Xbox ||
                        !this._smtControls) {
                        return;
                    }

                    var numberOfMilisecondsInASecond = 1000;
                    var playbackStatus = _WinRT.Windows.Media.MediaPlaybackStatus;
                    var updater = this._smtControls.displayUpdater;

                    // We need to set the contentId on every update because there could be cases where there are multiple
                    // concurrent videos. Because there is only one smtc, the two videos will override each other's state.
                    // For SmartGlass to be able to differentiate between the two video streams, we need to send the contentId
                    // along with each update.
                    if (updater &&
                        this._mediaMetadata) {
                        updater.appMediaId = this._mediaMetadata.contentId;
                    }

                    // Assign MediaTransportState
                    if (!this._mediaElementAdapter ||
                        !this._mediaElementAdapter.mediaElement ||
                        !this._mediaElementAdapter.mediaElement.src) {
                        this._smtControls.playbackStatus = playbackStatus.closed;
                    } else if (isStopped ||
                        this._mediaElementAdapter.mediaElement.ended) {
                        this._smtControls.playbackStatus = playbackStatus.stopped;
                    } else if (this._isBusy) {
                        if (this._mediaElementAdapter.mediaElement.readyState <= this._MediaReadyState.MediaReadyState_Have_FutureData) {
                            this._smtControls.playbackStatus = playbackStatus.changing;
                        }
                    } else if (!this._isInFastForwardOrRewindMode) {
                        if (this._mediaElementAdapter.mediaElement.paused) {
                            this._smtControls.playbackStatus = playbackStatus.paused;
                        } else {
                            this._smtControls.playbackStatus = playbackStatus.playing;
                        }
                    } else if (this._isInFastForwardOrRewindMode) {
                        this._smtControls.playbackStatus = playbackStatus.playing;
                    } else {
                        this._smtControls.playbackStatus = playbackStatus.closed;
                    }

                    this._smtControls.isFastForwardEnabled = this.fastForwardButtonEnabled && this.fastForwardButtonVisible;
                    this._smtControls.isNextEnabled = (this.chapterSkipForwardButtonEnabled && this.chapterSkipForwardButtonVisible) || (this.nextTrackButtonEnabled && this.nextTrackButtonVisible);

                    if (this.playPauseButtonEnabled && this.playPauseButtonVisible) {
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement) {

                            if (this._mediaElementAdapter.mediaElement.paused) {
                                this._smtControls.isPlayEnabled = true;
                                this._smtControls.isPauseEnabled = false;
                            } else {
                                this._smtControls.isPlayEnabled = false;
                                this._smtControls.isPauseEnabled = true;
                            }
                        }
                    }

                    this._smtControls.isPreviousEnabled = (this.chapterSkipBackButtonEnabled && this.chapterSkipBackButtonVisible) || (this.previousTrackButtonEnabled && this.previousTrackButtonVisible);
                    this._smtControls.isRewindEnabled = this.rewindButtonEnabled && this.rewindButtonVisible;
                    this._smtControls.isStopEnabled = this.stopButtonEnabled && this.stopButtonVisible;

                    // Note: The duration is NaN before the video stream has loaded it's metadata, which will cause
                    // the MediaPlayer to fall into "live" mode. We need to check the state of the mediaElement to
                    // make sure that metadata is loaded before setting isLive to true.
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        !isFinite(this._mediaElementAdapter.mediaElement.duration) &&
                        this._mediaElementAdapter.mediaElement.readyState > this._MediaReadyState.MediaReadyState_Have_Metadata) {
                        this._mediaElementAdapter.isLive = true;
                    }

                    if (updater.type === _WinRT.Windows.Media.MediaPlaybackType.video) {
                        updater.videoProperties.mediaStart = 0;
                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.isSeekAllowed) {
                            if (isFinite(this._startTime)) {
                                updater.videoProperties.minSeek = this._startTime * numberOfMilisecondsInASecond;
                            }
                            // We use -1 to indicate to the SystemMediaTransportControl that the
                            // media represents a live event
                            if (this._mediaElementAdapter.isLive) {
                                if (isFinite(this.targetCurrentTime) &&
                                    isFinite(this._startTime)) {
                                    updater.videoProperties.maxSeek = (this.targetCurrentTime - this._startTime) * numberOfMilisecondsInASecond;
                                } else {
                                    updater.videoProperties.maxSeek = 0;
                                }
                            } else {
                                if (isFinite(this._endTime)) {
                                    updater.videoProperties.maxSeek = this._endTime * numberOfMilisecondsInASecond;
                                }
                            }
                        } else {
                            updater.videoProperties.minSeek = 0;
                            updater.videoProperties.maxSeek = 0;
                        }
                        if (isFinite(this.targetCurrentTime)) {
                            updater.videoProperties.playbackPosition = this.targetCurrentTime * numberOfMilisecondsInASecond;
                        } else {
                            updater.videoProperties.playbackPosition = 0;
                        }
                        updater.videoProperties.playbackRate = this.targetPlaybackRate;

                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement &&
                            updater.type) {
                            // We use -1 to indicate to the SystemMediaTransportControl that the
                            // media represents a live event
                            if (this._mediaElementAdapter.isLive) {
                                updater.videoProperties.mediaStart = 0;
                                updater.videoProperties.mediaEnd = -1;
                            } else {
                                if (this._mediaElementAdapter.mediaElement.duration &&
                                    isFinite(this._mediaElementAdapter.mediaElement.duration)) {
                                    updater.videoProperties.mediaStart = 0;
                                    updater.videoProperties.mediaEnd = this._mediaElementAdapter.mediaElement.duration * numberOfMilisecondsInASecond;
                                }
                            }
                        }
                    }

                    updater.update();
                },

                _updateTimeDisplay: function () {

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement &&
                        (!wuiv.ApplicationView || (wuiv.ApplicationView.value !== wuiv.ApplicationViewState.snapped))) {
                        if (this._mediaElementAdapter.mediaElement.readyState < this._MediaReadyState.MediaReadyState_Have_FutureData) {
                            this._clearTimeDisplay();
                        } else {
                            var elapsedTime = this._getElapsedTimeText();
                            this._currentTimeIndicator.textContent = elapsedTime;
                            this._timeRemainingIndicator.textContent = this._getRemainingTimeText();

                            if (this._isInFastForwardOrRewindMode) {
                                this._seekTimeIndicator.textContent = elapsedTime;
                            }
                        }
                    }
                },

                // Helper function to update all the UI on the timeline
                _updateTimelineVisuals: function () {

                    this._syncTimeAndProgress(true);
                    this._updateTimeDisplay();
                },

                _initializeTransportBarButtons: function () {
                    // If there are any custom buttons, put them in the transport controls. Custom buttons go at the end.
                    var customButtons = this._customButtons;
                    for (var i = 0, len = customButtons.length; i < len; i++) {
                        this._commandsContainer.appendChild(customButtons[i]);
                    }

                    this._totalSeekBarWidth = this._seekBar.clientWidth;
                    this._thumbElementWidthDividedByTwo = this._thumbElement.clientWidth / 2;
                    this._thumbImageElementWidthDividedByTwo = this._thumbnailImage.clientWidth / 2;

                    // Populate the commands array
                    var commands = this._commandsContainer.querySelectorAll("button, .tv-mediaplayer-button");
                    for (var i = 0, len = commands.length; i < len; i++) {
                        this._commandsInternal.push(commands[i]);
                    }
                },

                _updateUIAndRaiseEvents: function (mediaCommand, mediaCommandDisplayString) {
                    this.dispatchEvent("mediacommandexecuted", { mediaCommand: mediaCommand });
                    this._updateMediaState(false);
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.controlsVisible" helpKeyword="TVJS.MediaPlayer.controlsVisible">
                /// Gets a property that specifies whether the transport controls are visible.
                /// </field>
                controlsVisible: {

                    get: function () {
                        return this._controlsVisible;
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.isControlsVisible" helpKeyword="TVJS.MediaPlayer.isControlsVisible">
                /// Exists for legacy migration.
                /// </field>
                isControlsVisible: {

                    get: function () {
                        return this.controlsVisible;
                    }
                },


                /// <field type="Object" locid="TVJS.MediaPlayer.endTime" helpKeyword="TVJS.MediaPlayer.endTime">
                /// Gets or sets maximum playback position of the media. By default, the value is the duration of the media.
                /// </field>
                endTime: {

                    get: function () {
                        if (this._endTime) {
                            return this._endTime;
                        } else if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement) {
                            return this._mediaElementAdapter.mediaElement.duration;
                        } else {
                            return undefined;
                        }
                    },

                    set: function (value) {
                        if (value < 0 ||
                            isNaN(value) ||
                            !isFinite(value)) {
                            throw new _ErrorFromName("TVJS.MediaPlayer.invalidTimeValue", strings.mediaPlayerInvalidTimeValue);
                        }

                        this._endTime = value;
                        this._wasEndTimeSetProgrammatically = true;

                        this._totalTime = this._endTime - this._startTime;

                        // Setting this value ensures that if the developer has added custom markers before the media's 'loadstart' event, the 'loadstart'
                        // will not erase the old value of startTime.
                        if (!this._mediaElementAdapter ||
                            !this._mediaElementAdapter.mediaElement ||
                            this._mediaElementAdapter.mediaElement.readyState < this._MediaReadyState.MediaReadyState_Have_Metadata) {
                            this._doesEndTimeNeedResetting = false;
                        }

                        this._subscribeToTimeUpdates();

                        // Update the time display
                        this._updateTimelineVisuals();

                        this._updateMediaState(false);
                    },
                },

                /// <field type="HTMLElement" domElement="true" hidden="true" locid="TVJS.MediaPlayer.element" helpKeyword="TVJS.MediaPlayer.element">
                /// The DOM element that hosts the MediaPlayer control.
                /// </field>
                element: {
                    get: function () {
                        return this._element;
                    }
                },

                /// <field type="Object" hidden="true" locid="TVJS.MediaPlayer.commands" helpKeyword="TVJS.MediaPlayer.commands">
                /// Gets or sets the commands that appear in the transport controls. The collection is a binding list of TVJS.UI.Command objects.
                /// </field>
                commands: {
                    get: function () {
                        var that = this;
                        var commands = {
                            getAt: function (index) {
                                return that._commandsInternal[index];
                            },
                            copyWithin: that._commandsInternal.copyWithin,
                            fill: that._commandsInternal.fill,
                            pop: function () {
                                var returnValue = that._commandsInternal.pop();
                                that._refreshTransportBarButtons();
                                return returnValue;
                            },
                            push: function (command) {
                                var returnValue = that._commandsInternal.push(command);
                                that._refreshTransportBarButtons();
                                return returnValue;
                            },
                            reverse: that._commandsInternal.reverse,
                            shift: function (command) {
                                var returnValue = that._commandsInternal.shift();
                                that._refreshTransportBarButtons();
                                return returnValue;
                            },
                            sort: that._commandsInternal.sort,
                            splice: function (index, howManyToRemove, command1, command2, command3, command4, command5, command6, command7, command8, command9) {
                                var returnValue;
                                if (command1 && command2 && command3 && command4 && command5 && command6 && command7 && command8 && command9) {
                                    returnValue = that._commandsInternal.splice(index, howManyToRemove, command1, command2, command3, command4, command5, command6, command7, command8, command9);
                                } else if (command1 && command2 && command3 && command4 && command5 && command6 && command7 && command8) {
                                    returnValue = that._commandsInternal.splice(index, howManyToRemove, command1, command2, command3, command4, command5, command6, command7, command8);
                                } else if (command1 && command2 && command3 && command4 && command5 && command6 && command7) {
                                    returnValue = that._commandsInternal.splice(index, howManyToRemove, command1, command2, command3, command4, command5, command6, command7);
                                } else if (command1 && command2 && command3 && command4 && command5 && command6) {
                                    returnValue = that._commandsInternal.splice(index, howManyToRemove, command1, command2, command3, command4, command5, command6);
                                } else if (command1 && command2 && command3 && command4 && command5) {
                                    returnValue = that._commandsInternal.splice(index, howManyToRemove, command1, command2, command3, command4, command5);
                                } else if (command1 && command2 && command3 && command4) {
                                    returnValue = that._commandsInternal.splice(index, howManyToRemove, command1, command2, command3, command4);
                                } else if (command1 && command2 && command3) {
                                    returnValue = that._commandsInternal.splice(index, howManyToRemove, command1, command2, command3);
                                } else if (command1 && command2) {
                                    returnValue = that._commandsInternal.splice(index, howManyToRemove, command1, command2);
                                } else if (command1) {
                                    returnValue = that._commandsInternal.splice(index, howManyToRemove, command1);
                                }
                                that._refreshTransportBarButtons();
                                return returnValue;
                            },
                            unshift: function (command1, command2, command3, command4, command5, command6, command7, command8, command9) {
                                var returnValue;
                                if (command1 && command2 && command3 && command4 && command5 && command6 && command7 && command8 && command9) {
                                    returnValue = that._commandsInternal.unshift(command1, command2, command3, command4, command5, command6, command7, command8, command9);
                                } else if (command1 && command2 && command3 && command4 && command5 && command6 && command7 && command8) {
                                    returnValue = that._commandsInternal.unshift(command1, command2, command3, command4, command5, command6, command7, command8);
                                } else if (command1 && command2 && command3 && command4 && command5 && command6 && command7) {
                                    returnValue = that._commandsInternal.unshift(command1, command2, command3, command4, command5, command6, command7);
                                } else if (command1 && command2 && command3 && command4 && command5 && command6) {
                                    returnValue = that._commandsInternal.unshift(command1, command2, command3, command4, command5, command6);
                                } else if (command1 && command2 && command3 && command4 && command5) {
                                    returnValue = that._commandsInternal.unshift(command1, command2, command3, command4, command5);
                                } else if (command1 && command2 && command3 && command4) {
                                    returnValue = that._commandsInternal.unshift(command1, command2, command3, command4);
                                } else if (command1 && command2 && command3) {
                                    returnValue = that._commandsInternal.unshift(command1, command2, command3);
                                } else if (command1 && command2) {
                                    returnValue = that._commandsInternal.unshift(command1, command2);
                                } else if (command1) {
                                    returnValue = that._commandsInternal.unshift(command1);
                                }
                                that._refreshTransportBarButtons();
                                return returnValue;
                            },
                            concat: that._commandsInternal.concat,
                            join: that._commandsInternal.join,
                            slice: that._commandsInternal.slice,
                            toString: that._commandsInternal.toString,
                            indexOf: that._commandsInternal.indexOf,
                            lastIndexOf: that._commandsInternal.lastIndexOf,
                            forEach: that._commandsInternal.forEach,
                            entries: that._commandsInternal.entries,
                            every: that._commandsInternal.every,
                            some: that._commandsInternal.some,
                            filter: that._commandsInternal.filter,
                            find: that._commandsInternal.find,
                            findIndex: that._commandsInternal.findIndex,
                            keys: that._commandsInternal.keys,
                            map: that._commandsInternal.map,
                            reduce: that._commandsInternal.reduce,
                            reduceRight: that._commandsInternal.reduceRight,
                            values: that._commandsInternal.values,
                        };
                        Object.defineProperty(commands, "length", {
                            get: function () { return that._commandsInternal.length; },
                            enumerable: true,
                            configurable: true
                        });
                        return commands;
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.compact" helpKeyword="TVJS.MediaPlayer.compact">
                /// Gets or sets a value indicating whether the MediaPlayer is using a layout that minimized space used, but only has room for a limited number of
                /// commands or a layout that has room for a lot of commands, but takes up more space.
                /// </field>
                compact: {
                    get: function () {
                        return this._compact;
                    },

                    set: function (value) {
                        if (this._isCommandsSetByUser) {
                            throw new _ErrorFromName("TVJS.MediaPlayer.unSupportedOperation", strings.unSupportedOperation);
                        }
                        this._compact = value;
                        if (this._compact) {

                            // TODO - make sure compact mode still works

                            removeClass(this._element, "tv-mediaplayer-doublerow");
                            addClass(this._element, "tv-mediaplayer-singlerow");
                        } else {

                            // TODO - make sure compact mode still works

                            removeClass(this._element, "tv-mediaplayer-singlerow");
                            addClass(this._element, "tv-mediaplayer-doublerow");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.fullScreen" helpKeyword="TVJS.MediaPlayer.fullScreen">
                /// Gets or sets a value indicating whether the MediaPlayer is full screen.
                /// </field>
                fullScreen: {
                    get: function () {
                        return this._fullScreen;
                    },

                    set: function (fullScreen) {
                        var elementToMakeFullscreen = _Global.document.body;
                        if (fullScreen) {
                            addClass(this._element, "tv-mediaplayer-fullscreen");
                            this.element.tabIndex = -1;

                            this._element.removeEventListener("keydown", this._keydownInputHandler);
                            this._element.removeEventListener("keyup", this._keyupInputHandler);
                            document.addEventListener("keydown", this._keydownInputHandler, false);
                            document.addEventListener("keyup", this._keyupInputHandler, false);
                            if (this._fullscreenButtonIcon) {
                                removeClass(this._fullscreenButtonIcon, "tv-mediaplayer-fullscreenicon");
                                addClass(this._fullscreenButtonIcon, "tv-mediaplayer-backtowindowicon");
                            }

                            // Go into full screen
                            if (!TVJS._tv) {
                                if (_WinRT.Windows.UI.ViewManagement.ApplicationView) {
                                    var applicationView = _WinRT.Windows.UI.ViewManagement.ApplicationView.getForCurrentView();
                                    applicationView.tryEnterFullScreenMode();
                                } else {
                                    if (elementToMakeFullscreen.requestFullscreen) {
                                        elementToMakeFullscreen.requestFullscreen();
                                        document.addEventListener("fullscreenchange", this._fullScreenChangeHandler, false);
                                        document.addEventListener("fullscreenerror", this._fullScreenErrorHandler, false);
                                    } else if (elementToMakeFullscreen.msRequestFullscreen) {
                                        elementToMakeFullscreen.msRequestFullscreen();
                                        document.addEventListener("MSFullscreenChange", this._fullScreenChangeHandler, false);
                                        document.addEventListener("MSFullscreenError", this._fullScreenErrorHandler, false);
                                    } else if (elementToMakeFullscreen.mozRequestFullScreen) {
                                        elementToMakeFullscreen.mozRequestFullScreen();
                                        document.addEventListener("mozfullscreenchange", this._fullScreenChangeHandler, false);
                                        document.addEventListener("mozfullscreenerror", this._fullScreenErrorHandler, false);
                                    } else if (elementToMakeFullscreen.webkitRequestFullscreen) {
                                        elementToMakeFullscreen.webkitRequestFullscreen();
                                        document.addEventListener("webkitfullscreenchange", this._fullScreenChangeHandler, false);
                                        document.addEventListener("webkitfullscreenerror", this._fullScreenErrorHandler, false);
                                    }
                                }

                                // set the MediaPlayer to the child of the body object, we might lose parent styling in fullscreen.
                                if (_Global.document.body !== this._element.parentNode) {
                                    this._originalParent = this._element.parentNode;
                                    this._nextSibiling = this._element.nextSibling;
                                    _Global.document.body.appendChild(this._element);
                                }

                                this._recalculateCachedUIElementSizes();
                            }
                        } else {
                            removeClass(this._element, "tv-mediaplayer-fullscreen");
                            this.element.tabIndex = 0;

                            document.removeEventListener("keydown", this._keydownInputHandler);
                            document.removeEventListener("keyup", this._keyupInputHandler);

                            this._element.addEventListener("keydown", this._keydownInputHandler, false);
                            this._element.addEventListener("keyup", this._keyupInputHandler, false);

                            if (this._fullscreenButtonIcon) {
                                addClass(this._fullscreenButtonIcon, "tv-mediaplayer-fullscreenicon");
                                removeClass(this._fullscreenButtonIcon, "tv-mediaplayer-backtowindowicon");
                            }

                            // Exit full screen
                            if (!TVJS._tv) {
                                if (_WinRT.Windows.UI.ViewManagement.ApplicationView) {
                                    var applicationView = _WinRT.Windows.UI.ViewManagement.ApplicationView.getForCurrentView();
                                    applicationView.exitFullScreenMode();
                                } else {
                                    if (_Global.document.exitFullscreen) {
                                        document.removeEventListener(this._element, "fullscreenchange", this._fullScreenChangeHandler);
                                        document.removeEventListener(this._element, "fullscreenerror", this._fullScreenErrorHandler);
                                        _Global.document.exitFullscreen();
                                    } else if (_Global.document.msExitFullscreen) {
                                        document.removeEventListener(this._element, "MSFullscreenChange", this._fullScreenChangeHandler);
                                        document.removeEventListener(this._element, "MSFullscreenError", this._fullScreenErrorHandler);
                                        _Global.document.msExitFullscreen();
                                    } else if (_Global.document.mozCancelFullScreen) {
                                        document.removeEventListener(this._element, "mozfullscreenchange", this._fullScreenChangeHandler);
                                        document.removeEventListener(this._element, "mozfullscreenerror", this._fullScreenErrorHandler);
                                        _Global.document.mozCancelFullScreen();
                                    } else if (_Global.document.webkitCancelFullScreen) {
                                        document.removeEventListener(this._element, "webkitfullscreenchange", this._fullScreenChangeHandler);
                                        document.removeEventListener(this._element, "webkitfullscreenerror", this._fullScreenErrorHandler);
                                        _Global.document.webkitCancelFullScreen();
                                    }
                                }

                                if (this._originalParent) {
                                    // Reset back to the original parent
                                    if (this._nextSibiling) {
                                        this._originalParent.insertBefore(this._element, this._nextSibiling);
                                        this._nextSibiling = null;
                                    } else {
                                        this._originalParent.appendChild(this._element);
                                    }
                                    this._originalParent = null;
                                }
                                this._recalculateCachedUIElementSizes();
                            }
                        }

                        this._fullScreen = fullScreen;
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.isFullScreen" helpKeyword="TVJS.MediaPlayer.isFullScreen">
                /// Old property name kept for legacy compatability.
                /// </field>
                isFullScreen: {
                    get: function () {
                        return this.fullScreen;
                    },
                    set: function (fullScreen) {
                        this.fullScreen = fullScreen;
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.thumbnailEnabled" helpKeyword="TVJS.MediaPlayer.thumbnailEnabled">
                /// Gets or sets a value indicating whether to use thumbnails for fast forward, rewind and scrubbing. If true, the fast forward, rewind and scrub operations
                /// will pause the mediaElement and cycle thumbnails as the user changes position. If false, the fast forward, rewind operations will increase or decrease
                /// the mediaElement's playbackRate and the scrub operation will move the position.
                /// </field>
                thumbnailEnabled: {

                    get: function () {
                        return this._thumbnailEnabled;
                    },

                    set: function (value) {
                        if (value) {
                            addClass(this._timeline, "tv-mediaplayer-thumbnailmode");
                        } else {
                            removeClass(this._timeline, "tv-mediaplayer-thumbnailmode");
                        }
                        this._thumbnailEnabled = value;
                    },
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.isThumbnailEnabled" helpKeyword="TVJS.MediaPlayer.isThumbnailEnabled">
                /// Old property names kept for legacy compatability.
                /// </field>
                isThumbnailEnabled: {

                    get: function () {
                        return this.thumbnailEnabled;
                    },

                    set: function (value) {
                        this.thumbnailEnabled = value;
                    },
                },

                /// <field type="Object" locid="TVJS.MediaPlayer.markers" helpKeyword="TVJS.MediaPlayer.markers">
                /// Gets or sets the MediaPlayer's marker collection.
                /// </field>
                markers: {

                    get: function () {
                        return this._markers;
                    },

                    set: function (value) {

                        // Clear any existing markers
                        this._markers.length = 0;
                        this._markers = value;

                        // Setting this value ensures that if the developer has added custom markers before the media's 'loadstart' event, the 'loadstart'
                        // will not delete those markers.
                        if (!this._mediaElementAdapter ||
                            !this._mediaElementAdapter.mediaElement ||
                            this._mediaElementAdapter.mediaElement.readyState < this._MediaReadyState.MediaReadyState_Have_Metadata) {
                            this._doMarkersNeedResetting = false;
                        }

                        // Unsubscribe from time update if there are no markers in the array
                        if (!this._markers.length) {
                            this._hasCustomMarkers = false;
                            this._unsubscribeFromTimeUpdates();
                        }  else {
                            this._hasCustomMarkers = true;
                        }

                        this._onMarkerCollectionChanged();
                    }
                },

                /// <field type="Object" locid="TVJS.MediaPlayer.mediaElementAdapter" helpKeyword="TVJS.MediaPlayer.mediaElementAdapter">
                /// Gets or sets an interface that your application can implement to have more control over synchronization between
                /// the MediaPlayer and your media.
                /// </field>
                mediaElementAdapter: {

                    get: function () {
                        return this._mediaElementAdapter;
                    },

                    set: function (value) {

                        var oldMediaElement = null;
                        var newMediaElement = null;

                        if (this._mediaElementAdapter &&
                            this._mediaElementAdapter.mediaElement) {
                            oldMediaElement = this._mediaElementAdapter.mediaElement;
                        }

                        if (value &&
                            value.mediaElement) {
                            newMediaElement = value.mediaElement;
                        }

                        this._setupNewMediaElement(newMediaElement, oldMediaElement);

                        this._mediaElementAdapter = value;
                    }
                },

                /// <field type="Object" locid="TVJS.MediaPlayer.startTime" helpKeyword="TVJS.MediaPlayer.startTime">
                /// Gets or sets minimum playback position of the media. By default the value is zero.
                /// </field>
                startTime: {

                    get: function () {
                        return this._startTime || 0;
                    },

                    set: function (value) {
                        if (value < 0 ||
                            isNaN(value) ||
                            !isFinite(value)) {
                            throw new _ErrorFromName("TVJS.MediaPlayer.invalidTimeValue", strings.mediaPlayerInvalidTimeValue);
                        }

                        this._startTime = value;
                        this._wasStartTimeSetProgrammatically = true;

                        this._totalTime = this._endTime - this._startTime;

                        // Setting this value ensures that if the developer has added custom markers before the media's 'loadstart' event, the 'loadstart'
                        // will not erase the old value of startTime.
                        if (!this._mediaElementAdapter ||
                            !this._mediaElementAdapter.mediaElement ||
                            this._mediaElementAdapter.mediaElement.readyState < this._MediaReadyState.MediaReadyState_Have_Metadata) {
                            this._doesStartTimeNeedResetting = false;
                        }

                        this._subscribeToTimeUpdates();
                        // Update the time display
                        this._updateTimelineVisuals();

                        this._updateMediaState(false);
                    },
                },

                /// <field type="Object" locid="TVJS.MediaPlayer.targetCurrentTime" helpKeyword="TVJS.MediaPlayer.targetCurrentTime">
                /// Gets the current time as it is represented in the UI. While fast forwarding or rewinding, this property may be different than the video or audio
                /// tag's 'currentTime' property. This is because during a fast forward or rewind operation, the media is paused while the timeline animates to
                /// simulate a fast forward or rewind operation.
                /// </field>
                targetCurrentTime: {

                    get: function () {

                        var targetCurrentTime = 0;

                        if (this._simulatedFastForwardMode &&
                            this._isInFastForwardOrRewindMode) {
                            targetCurrentTime = this._targetCurrentTime;
                        } else {
                            if (this._mediaElementAdapter &&
                                this._mediaElementAdapter.mediaElement) {
                                targetCurrentTime = this._mediaElementAdapter.mediaElement.currentTime;
                            }
                        }

                        return targetCurrentTime;
                    }
                },

                /// <field type="Object" locid="TVJS.MediaPlayer.targetPlaybackRate" helpKeyword="TVJS.MediaPlayer.targetPlaybackRate">
                /// Gets the playbackRate as it is represented in the UI. While fast forwarding or rewinding, this property may be different than the video or audio
                /// tag's 'playbackRate' property. This is because during a fast forward or rewind operation, the media is paused while the timeline animates to
                /// simulate a fast forward or rewind operation.
                /// </field>
                targetPlaybackRate: {

                    get: function () {

                        var targetPlaybackRate = 0;

                        if (this._simulatedFastForwardMode &&
                            this._isInFastForwardOrRewindMode) {
                            targetPlaybackRate = this._targetPlaybackRate;
                        } else {
                            if (this._mediaElementAdapter &&
                                this._mediaElementAdapter.mediaElement) {
                                targetPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                            }
                        }

                        return targetPlaybackRate;
                    }
                },

                /// <field type="Object" locid="TVJS.MediaPlayer.timeFormatter" helpKeyword="TVJS.MediaPlayer.timeFormatter">
                /// Gets or sets a function that converts raw time data from the video or audio tag into text to display in the UI of the MediaPlayer.
                /// </field>
                timeFormatter: {

                    get: function () {
                        return this._timeFormatter;
                    },

                    set: function (value) {

                        if (value) {
                            this._timeFormatter = value;
                        } else {
                            // If timeFormatter is 'null', then use the default timeFormatter
                            this._timeFormatter = this._defaultTimeFormatter;
                        }
                    }
                },

                /// <field type="Object" locid="TVJS.MediaPlayer.thumbnailImage" helpKeyword="TVJS.MediaPlayer.thumbnailImage">
                /// Sets the path to the current thumbnail image to display.
                /// </field>
                thumbnailImage: {
                    set: function (value) {
                        this._thumbnailImageVisual.style.backgroundImage = "url(" + value + ")";
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.castButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.castButtonVisible">
                /// Gets or sets whether the CAST button is visible.
                /// </field>
                castButtonVisible: {
                    get: function () {
                        return this._castButtonVisible;
                    },

                    set: function (value) {
                        this._castButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._castButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._castButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.castButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.castButtonEnabled">
                /// Gets or sets whether the cast button is enabled.
                /// </field>
                castButtonEnabled: {
                    get: function () {
                        return this._castButtonEnabled;
                    },

                    set: function (value) {
                        this._castButtonEnabled = value ? true : false;
                        if (this._castButtonEnabled) {
                            this._castButton.disabled = false;
                        } else {
                            this._castButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.chapterSkipBackButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.chapterSkipBackButtonVisible">
                /// Gets or sets whether the chapter skip back button is visible.
                /// </field>
                chapterSkipBackButtonVisible: {
                    get: function () {
                        return this._chapterSkipBackButtonVisible;
                    },

                    set: function (value) {
                        this._chapterSkipBackButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._chapterSkipBackButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._chapterSkipBackButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.chapterSkipBackButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.chapterSkipBackButtonEnabled">
                /// Gets or sets whether the chapter skip back button is enabled.
                /// </field>
                chapterSkipBackButtonEnabled: {
                    get: function () {
                        return this._chapterSkipBackButtonEnabled;
                    },

                    set: function (value) {
                        this._chapterSkipBackButtonEnabled = value ? true : false;
                        if (this._chapterSkipBackButtonEnabled) {
                            this._chapterSkipBackButton.disabled = false;
                        } else {
                            this._chapterSkipBackButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.chapterSkipForwardButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.chapterSkipForwardButtonVisible">
                /// Gets or sets whether the chapter skip forward button is visible.
                /// </field>
                chapterSkipForwardButtonVisible: {
                    get: function () {
                        return this._chapterSkipForwardButtonVisible;
                    },

                    set: function (value) {
                        this._chapterSkipForwardButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._chapterSkipForwardButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._chapterSkipForwardButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.chapterSkipForwardButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.chapterSkipForwardButtonEnabled">
                /// Gets or sets whether the chapter skip forward button is enabled.
                /// </field>
                chapterSkipForwardButtonEnabled: {
                    get: function () {
                        return this._chapterSkipForwardButtonEnabled;
                    },

                    set: function (value) {
                        this._chapterSkipForwardButtonEnabled = value ? true : false;
                        if (this._chapterSkipForwardButtonEnabled) {
                            this._chapterSkipForwardButton.disabled = false;
                        } else {
                            this._chapterSkipForwardButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.fastForwardButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.fastForwardButtonVisible">
                /// Gets or sets whether the fast forward button is visible.
                /// </field>
                fastForwardButtonVisible: {
                    get: function () {
                        return this._fastForwardButtonVisible;
                    },

                    set: function (value) {
                        this._fastForwardButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._fastForwardButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._fastForwardButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.fastForwardButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.fastForwardButtonEnabled">
                /// Gets or sets whether the fast forward button is enabled.
                /// </field>
                fastForwardButtonEnabled: {
                    get: function () {
                        return this._fastForwardButtonEnabled;
                    },

                    set: function (value) {
                        this._fastForwardButtonEnabled = value ? true : false;
                        if (this._fastForwardButtonEnabled) {
                            this._fastForwardButton.disabled = false;
                        } else {
                            this._fastForwardButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.fullscreenButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.fullscreenButtonVisible">
                /// Gets or sets whether the full screen button is visible.
                /// </field>
                fullscreenButtonVisible: {
                    get: function () {
                        return this._fullscreenButtonVisible;
                    },

                    set: function (value) {
                        this._fullscreenButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._toggleFullScreenButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._toggleFullScreenButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.fullscreenButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.fullscreenButtonEnabled">
                /// Gets or sets whether the more button is enabled.
                /// </field>
                fullscreenButtonEnabled: {
                    get: function () {
                        return this._fullscreenButtonEnabled;
                    },

                    set: function (value) {
                        this._fullscreenButtonEnabled = value ? true : false;
                        if (this._fullscreenButtonEnabled) {
                            this._toggleFullScreenButton.disabled = false;
                        } else {
                            this._toggleFullScreenButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.goToLiveButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.goToLiveButtonVisible">
                /// Gets or sets whether the LIVE button is visible.
                /// </field>
                goToLiveButtonVisible: {
                    get: function () {
                        return this._goToLiveButtonVisible;
                    },

                    set: function (value) {
                        this._goToLiveButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._goToLiveButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._goToLiveButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.goToLiveButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.goToLiveButtonEnabled">
                /// Gets or sets whether the LIVE button is enabled.
                /// </field>
                goToLiveButtonEnabled: {
                    get: function () {
                        return this._goToLiveButtonEnabled;
                    },

                    set: function (value) {
                        this._goToLiveButtonEnabled = value ? true : false;
                        if (this._goToLiveButtonEnabled) {
                            this._goToLiveButton.disabled = false;
                        } else {
                            this._goToLiveButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.nextTrackButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.nextTrackButtonVisible">
                /// Gets or sets whether the next track button is visible.
                /// </field>
                nextTrackButtonVisible: {
                    get: function () {
                        return this._nextTrackButtonVisible;
                    },

                    set: function (value) {
                        this._nextTrackButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._nextTrackButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._nextTrackButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.nextTrackButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.nextTrackButtonEnabled">
                /// Gets or sets whether the next track button is enabled.
                /// </field>
                nextTrackButtonEnabled: {
                    get: function () {
                        return this._nextTrackButtonEnabled;
                    },

                    set: function (value) {
                        this._nextTrackButtonEnabled = value ? true : false;
                        if (this._nextTrackButtonEnabled) {
                            this._nextTrackButton.disabled = false;
                        } else {
                            this._nextTrackButton.disabled = true;
                        }

                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.playFromBeginningButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.playFromBeginningButtonVisible">
                /// Gets or sets whether the play from beginning button is visible.
                /// </field>
                playFromBeginningButtonVisible: {
                    get: function () {
                        return this._playFromBeginningButtonVisible;
                    },

                    set: function (value) {
                        this._playFromBeginningButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._playFromBeginningButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._playFromBeginningButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.playFromBeginningButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.playFromBeginningButtonEnabled">
                /// Gets or sets whether the play from beginning button is enabled.
                /// </field>
                playFromBeginningButtonEnabled: {
                    get: function () {
                        return this._playFromBeginningButtonEnabled;
                    },

                    set: function (value) {
                        this._playFromBeginningButtonEnabled = value ? true : false;
                        if (this._playFromBeginningButtonEnabled) {
                            this._playFromBeginningButton.disabled = false;
                        } else {
                            this._playFromBeginningButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.playPauseButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.playPauseButtonVisible">
                /// Gets or sets whether the play / pause button is visible.
                /// </field>
                playPauseButtonVisible: {
                    get: function () {
                        return this._playPauseButtonVisible;
                    },

                    set: function (value) {
                        this._playPauseButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._playPauseButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._playPauseButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.playPauseButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.playPauseButtonEnabled">
                /// Gets or sets whether the play / pause button is enabled.
                /// </field>
                playPauseButtonEnabled: {
                    get: function () {
                        return this._playPauseButtonEnabled;
                    },

                    set: function (value) {
                        this._playPauseButtonEnabled = value ? true : false;
                        if (this._playPauseButtonEnabled) {
                            this._playPauseButton.disabled = false;
                        } else {
                            this._playPauseButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.playbackRateButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.playbackRateButtonVisible">
                /// Gets or sets whether the playback rate button is visible.
                /// </field>
                playbackRateButtonVisible: {
                    get: function () {
                        return this._playbackRateButtonVisible;
                    },

                    set: function (value) {
                        this._playbackRateButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._playbackRateButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._playbackRateButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.playbackRateButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.playbackRateButtonEnabled">
                /// Gets or sets whether the playback rate button is enabled.
                /// </field>
                playbackRateButtonEnabled: {
                    get: function () {
                        return this._playbackRateButtonEnabled;
                    },

                    set: function (value) {
                        this._playPauseButtonEnabled = value ? true : false;
                        if (this._playbackRateButtonEnabled) {
                            this._playbackRateButton.disabled = false;
                        } else {
                            this._playbackRateButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.previousTrackButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.previousTrackButtonVisible">
                /// Gets or sets whether the previous track button is visible.
                /// </field>
                previousTrackButtonVisible: {
                    get: function () {
                        return this._previousTrackButtonVisible;
                    },

                    set: function (value) {
                        this._previousTrackButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._previousTrackButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._previousTrackButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.previousTrackButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.previousTrackButtonEnabled">
                /// Gets or sets whether the previous track button is enabled.
                /// </field>
                previousTrackButtonEnabled: {
                    get: function () {
                        return this._previousTrackButtonEnabled;
                    },

                    set: function (value) {
                        this._previousTrackButtonEnabled = value ? true : false;
                        if (this._previousTrackButtonEnabled) {
                            this._previousTrackButton.disabled = false;
                        } else {
                            this._previousTrackButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.rewindButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.rewindButtonVisible">
                /// Gets or sets whether the rewind button is visible.
                /// </field>
                rewindButtonVisible: {
                    get: function () {
                        return this._rewindButtonVisible;
                    },

                    set: function (value) {
                        this._rewindButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._rewindButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._rewindButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.rewindButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.rewindButtonEnabled">
                /// Gets or sets whether the rewind button is enabled.
                /// </field>
                rewindButtonEnabled: {
                    get: function () {
                        return this._rewindButtonEnabled;
                    },

                    set: function (value) {
                        this._rewindButtonEnabled = value ? true : false;
                        if (this._rewindButtonEnabled) {
                            this._rewindButton.disabled = false;
                        } else {
                            this._rewindButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.seekBarVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.seekBarVisible">
                /// Gets or sets whether the seek bar is visible.
                /// </field>
                seekBarVisible: {
                    get: function () {
                        return this._seekBarVisible;
                    },

                    set: function (value) {
                        this._seekBarVisible = value ? true : false;
                        if (this._seekBarVisible) {
                            removeClass(this._progressContainer, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._progressContainer, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.seekingEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.seekingEnabled">
                /// Gets or sets whether the seeking is enabled.
                /// </field>
                seekingEnabled: {
                    get: function () {
                        if (this._mediaElementAdapter) {
                            return this._mediaElementAdapter.isSeekAllowed;
                        }
                        return false;
                    },

                    set: function (value) {
                        if (this._mediaElementAdapter) {
                            if (value) {
                                this._mediaElementAdapter.isSeekAllowed = true;
                            } else {
                                this._mediaElementAdapter.isSeekAllowed = false;
                            }
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.stopButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.stopButtonVisible">
                /// Gets or sets whether the stop button is visible.
                /// </field>
                stopButtonVisible: {
                    get: function () {
                        return this._stopButtonVisible;
                    },

                    set: function (value) {
                        this._stopButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._stopButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._stopButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.stopButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.stopButtonEnabled">
                /// Gets or sets whether the stop button is enabled.
                /// </field>
                stopButtonEnabled: {
                    get: function () {
                        return this._stopButtonEnabled;
                    },

                    set: function (value) {
                        this._stopButtonEnabled = value ? true : false;
                        if (this._stopButtonEnabled) {
                            this._stopButton.disabled = false;
                        } else {
                            this._stopButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.timeSkipBackButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.timeSkipBackButtonVisible">
                /// Gets or sets whether the time skip back button is visible.
                /// </field>
                timeSkipBackButtonVisible: {
                    get: function () {
                        return this._timeSkipBackButtonVisible;
                    },

                    set: function (value) {
                        this._timeSkipBackButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._timeSkipBackButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._timeSkipBackButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.timeSkipBackButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.timeSkipBackButtonEnabled">
                /// Gets or sets whether the time skip back button is enabled.
                /// </field>
                timeSkipBackButtonEnabled: {
                    get: function () {
                        return this._timeSkipBackButtonEnabled;
                    },

                    set: function (value) {
                        this._timeSkipBackButtonEnabled = value ? true : false;
                        if (this._timeSkipBackButtonEnabled) {
                            this._timeSkipBackButton.disabled = false;
                        } else {
                            this._timeSkipBackButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.timeSkipForwardButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.timeSkipForwardButtonVisible">
                /// Gets or sets whether the time skip forward button is visible.
                /// </field>
                timeSkipForwardButtonVisible: {
                    get: function () {
                        return this._timeSkipForwardButtonVisible;
                    },

                    set: function (value) {
                        this._timeSkipForwardButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._timeSkipForwardButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._timeSkipForwardButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.timeSkipForwardButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.timeSkipForwardButtonEnabled">
                /// Gets or sets whether the time skip forward button is enabled.
                /// </field>
                timeSkipForwardButtonEnabled: {
                    get: function () {
                        return this._timeSkipForwardButtonEnabled;
                    },

                    set: function (value) {
                        this._timeSkipForwardButtonEnabled = value ? true : false;
                        if (this._timeSkipForwardButtonEnabled) {
                            this._timeSkipForwardButton.disabled = false;
                        } else {
                            this._timeSkipForwardButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.volumeButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.volumeButtonVisible">
                /// Gets or sets whether the volume button is visible.
                /// </field>
                volumeButtonVisible: {
                    get: function () {
                        return this._volumeButtonVisible;
                    },

                    set: function (value) {
                        this._volumeButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._volumeButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._volumeButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.volumeButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.volumeButtonEnabled">
                /// Gets or sets whether the volume button is enabled.
                /// </field>
                volumeButtonEnabled: {
                    get: function () {
                        return this._volumeButtonEnabled;
                    },

                    set: function (value) {
                        this._volumeButtonEnabled = value ? true : false;
                        if (this._volumeButtonEnabled) {
                            this._volumeButton.disabled = false;
                        } else {
                            this._volumeButton.disabled = true;
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.zoomButtonVisible" helpKeyword="TVJS.MediaPlayer.TransportControls.zoomButtonVisible">
                /// Gets or sets whether the zoom button is visible.
                /// </field>
                zoomButtonVisible: {
                    get: function () {
                        return this._zoomButtonVisible;
                    },

                    set: function (value) {
                        this._zoomButtonVisible = value ? true : false;
                        if (value) {
                            removeClass(this._zoomButton, "tv-mediaplayer-hidden");
                        } else {
                            addClass(this._zoomButton, "tv-mediaplayer-hidden");
                        }
                    }
                },

                /// <field type="Boolean" locid="TVJS.MediaPlayer.TransportControls.zoomButtonEnabled" helpKeyword="TVJS.MediaPlayer.TransportControls.zoomButtonEnabled">
                /// Gets or sets whether the zoom button is enabled.
                /// </field>
                zoomButtonEnabled: {
                    get: function () {
                        return this._zoomButtonEnabled;
                    },

                    set: function (value) {
                        this._zoomButtonEnabled = value ? true : false;
                        if (this._zoomButtonEnabled) {
                            this._zoomButton.disabled = false;
                        } else {
                            this._zoomButton.disabled = true;
                        }
                    }
                },

                // Public methods
                addMarker: function (time, type, data, extraClass) {
                    /// <signature helpKeyword="TVJS.MediaPlayer.addMarker">
                    /// <summary locid="TVJS.MediaPlayer.addMarker">
                    /// Adds a new timeline marker.
                    /// </summary>
                    /// <param name="time" type="Number" locid="TVJS.MediaPlayer.addMarker_p:time">
                    /// The marker time.
                    /// </param>
                    /// <param name="type" type="String" locid="TVJS.MediaPlayer.addMarker_p:type">
                    /// The marker type.
                    /// </param>
                    /// <param name="data" type="Object" locid="TVJS.MediaPlayer.addMarker_p:data">
                    /// The marker data.
                    /// </param>
                    /// <param name="extraClass" type="String" optional="true" locid="TVJS.MediaPlayer.addMarker_p:extraClass">
                    /// An extra class that can be used to style the marker.
                    /// </param>
                    /// </signature>
                    if (!this._mediaElementAdapter ||
                        !this._mediaElementAdapter.mediaElement) {
                        return;
                    }

                    if ((!time &&
                        time !== 0) ||
                        isNaN(time)) {

                        throw new _ErrorFromName("TVJS.MediaPlayer.timeNotANumber", strings.mediaPlayerInvalidTimeValue);
                    }

                    if (!type) {
                        type = markerType.chapter;
                    }

                    if (type !== markerType.advertisement &&
                        type !== markerType.chapter &&
                        type !== markerType.custom) {
                        throw new _ErrorFromName("TVJS.MediaPlayer.InvalidMarkerType", strings.mediaPlayerAddMarkerErrorInvalidMarkerType);
                    }

                    // If it's a chapter marker, clear out the default chapter markers
                    if (type === markerType.chapter) {
                        if (!extraClass) {
                            extraClass = "tv-mediaplayer-chaptermarker";
                        }

                        if (this._defaultChapterMarkers.length) {
                            this._clearDefaultChapterMarkers();
                        }
                    } else if (type === markerType.advertisement) {
                        if (!extraClass) {
                            extraClass = "tv-mediaplayer-advertisementmarker";
                        }

                        if (this._defaultChapterMarkers.length) {
                            this._clearDefaultChapterMarkers();
                        }
                    }

                    // Remove the marker if a marker with the same time already exists
                    var markersLength = this._markers.length;
                    for (var i = 0; i < markersLength; i++) {
                        if (this._markers[i].time === time) {
                            this._markers.splice(i, 1);
                            break;
                        }
                    }

                    this._markers.push({ time: time, markerType: type, data: data, extraClass: extraClass });
                    // Also make a call to add the marker to the browser
                    
                    // Setting this value ensures that if the developer has added custom markers before the media's 'loadstart' event, the 'loadstart'
                    // will not delete those markers.
                    if (!this._mediaElementAdapter ||
                        !this._mediaElementAdapter.mediaElement ||
                        this._mediaElementAdapter.mediaElement.readyState < this._MediaReadyState.MediaReadyState_Have_Metadata) {
                        this._doMarkersNeedResetting = false;
                    }
                    if (!this._hasCustomMarkers) {
                        this._hasCustomMarkers = true;
                    }

                    this._onMarkerCollectionChanged();
                },

                chapterSkipBack: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.chapterSkipBack">
                    /// <summary locid="TVJS.MediaPlayer.chapterSkipBack">
                    /// Seeks to the previous chapter marker.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: We're handling the logic for chapterSkipForward at the MediaPlayer level rather than in the
                        // MediaElementAdapater layer, because we want the experience to be consistent.

                        // Figure out where the next marker is
                        var newSeekTime = -1;
                        var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        var chapterMarkers = null;

                        if (this._defaultChapterMarkers.length) {
                            chapterMarkers = this._defaultChapterMarkers;
                        } else {
                            chapterMarkers = this._markers;
                        }

                        var chapterMarkersLength = chapterMarkers.length;
                        for (var i = chapterMarkersLength - 1; i >= 0; i--) {
                            if ((chapterMarkers[i].markerType === markerType.chapter ||
                                chapterMarkers[i].markerType === markerType.advertisement) &&
                                chapterMarkers[i].time + this._CHAPTER_SKIP_THRESHOLD < currentTime) {
                                newSeekTime = chapterMarkers[i].time;
                                break;
                            }
                        }

                        if (newSeekTime !== -1) {
                            this._seekInternal(newSeekTime, false);
                        } else {
                            this._seekInternal(this._startTime, false);
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.chapterSkipBack, strings.chapterSkipBackMediaCommandDisplayText);
                    }
                },

                chapterSkipForward: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.chapterSkipForward">
                    /// <summary locid="TVJS.MediaPlayer.chapterSkipForward">
                    /// Seeks to the next chapter marker.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: We're handling the logic for chapterSkipForward at the MediaPlayer level rather than in the
                        // MediaElementAdapater layer, because we want the experience to be consistent.

                        // Figure out where the next marker is
                        var newSeekTime = -1;
                        var currentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        var chapterMarkers = null;

                        if (this._defaultChapterMarkers.length) {
                            chapterMarkers = this._defaultChapterMarkers;
                        } else {
                            chapterMarkers = this._markers;
                        }

                        var chapterMarkersLength = chapterMarkers.length;
                        for (var i = 0; i < chapterMarkersLength; i++) {
                            if ((chapterMarkers[i].markerType === markerType.chapter ||
                                chapterMarkers[i].markerType === markerType.advertisement) &&
                                chapterMarkers[i].time - this._CHAPTER_SKIP_THRESHOLD > currentTime) {
                                newSeekTime = chapterMarkers[i].time;
                                break;
                            }
                        }

                        if (newSeekTime !== -1) {
                            this._seekInternal(newSeekTime, false);
                        } else {
                            this._seekInternal(this._endTime, false);
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.chapterSkipForward, strings.chapterSkipForwardMediaCommandDisplayText);
                    }
                },

                dispose: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.dispose">
                    /// <summary locid="TVJS.MediaPlayer.dispose">
                    /// Releases MediaPlayer resources.
                    /// </summary>
                    /// </signature>
                    if (this._disposed) {
                        return;
                    }
                    this._disposed = true;

                    // Remove event listeners
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        this._mediaElementAdapter.mediaElement.removeEventListener("seeked", this._handleSeekedAfterExitFastForwardOrRewindBind);
                    }
                    this._handleSeekedAfterExitFastForwardOrRewindBind = null;

                    utilities._resizeNotifier.unsubscribe(this._element, this._windowResizeCallback);
                    this._windowResizeCallback = null;

                    if (this._contentRestrictions && _WinRT.Windows.Xbox) {
                        this._contentRestrictions.removeEventListener("restrictionschanged", this._checkParentalControlsBind);
                    }

                    document.removeEventListener(this._element, "keydown", this._keydownInputHandler);
                    document.removeEventListener(this._element, "keyup", this._keyupInputHandler);
                    this._controlsKeyupInputHandler = null;
                    document.removeEventListener(this._element, "fullscreenchange", this._fullScreenChangeHandler);
                    document.removeEventListener(this._element, "MSFullscreenChange", this._fullScreenChangeHandler);
                    document.removeEventListener(this._element, "mozfullscreenchange", this._fullScreenChangeHandler);
                    document.removeEventListener(this._element, "webkitfullscreenchange", this._fullScreenChangeHandler);
                    document.removeEventListener(this._element, "fullscreenerror", this._fullScreenErrorHandler);
                    document.removeEventListener(this._element, "MSFullscreenError", this._fullScreenErrorHandler);
                    document.removeEventListener(this._element, "mozfullscreenerror", this._fullScreenErrorHandler);
                    document.removeEventListener(this._element, "webkitfullscreenerror", this._fullScreenErrorHandler);
                    this._fullScreenChangeHandler = null;
                    this._fullScreenErrorHandler = null;

                    this._timeline.removeEventListener("keydown", this._handleTimelineArrowKeyDownBind);
                    this._handleTimelineArrowKeyDownBind = null;

                    if (_WinRT.Windows.Media.SystemMediaTransportControls) {
                        this._smtControls.removeEventListener(this.element, "buttonpressed", this._handleSystemTransportControlsButtonPressedBind);
                        this._smtControls.removeEventListener(this.element, "propertychanged", this._handleSystemTransportControlsPropertyChangedBind);
                    }
                    this._handleSystemTransportControlsButtonPressedBind = null;
                    this._handleSystemTransportControlsPropertyChangedBind = null;
                    this._smtControls = null;

                    document.body.removeEventListener(this.element, "pointerout", this._inputHandlerMouseOutCallback);
                    window.removeEventListener(this.element, "pointermove", this._inputHandlerPointerMoveCallback);
                    window.removeEventListener(this.element, "pointerup", this._inputHandlerMouseUpCallback);

                    if (this._element) {
                        this._element.removeEventListener("keydown", this._keydownInputHandler);
                        this._element.removeEventListener("keyup", this._keyupInputHandler);
                        this._keydownInputHandler = null;
                        this._keyupInputHandler = null;
                    }

                    if (this._volumeFlyout) {
                        this._volumeFlyout.removeEventListener("aftershow", this._handleVolumeFlyoutShowCallback);
                        this._volumeFlyout.removeEventListener("beforeshow", this._handleFlyoutOpenCallbackBind);
                        this._volumeFlyout.removeEventListener("afterhide", this._handleFlyoutCloseCallbackBind);
                    }
                    if (this._volumeSlider) {
                        this._volumeSlider.removeEventListener("change", this._handleVolumeSliderChangeCallback);
                    }

                    // Remove any dynamically inserted elements from the DOM
                    if (this._audioTracksFlyout) {
                        this._audioTracksFlyout.removeEventListener("beforeshow", this._handleFlyoutOpenCallbackBind);
                        this._audioTracksFlyout.removeEventListener("afterhide", this._handleFlyoutCloseCallbackBind);
                        _Global.document.body.removeChild(this._audioTracksFlyout.element);
                        this._audioTracksFlyout.dispose();
                    }
                    if (this._closedCaptionsFlyout) {
                        this._closedCaptionsFlyout.removeEventListener("beforeshow", this._handleFlyoutOpenCallbackBind);
                        this._closedCaptionsFlyout.removeEventListener("afterhide", this._handleFlyoutCloseCallbackBind);
                        _Global.document.body.removeChild(this._closedCaptionsFlyout.element);
                        this._closedCaptionsFlyout.dispose();
                    }
                    if (this._errorFlyout) {
                        this._errorFlyout.removeEventListener("beforeshow", this._handleFlyoutOpenCallbackBind);
                        this._errorFlyout.removeEventListener("afterhide", this._handleFlyoutCloseCallbackBind);
                        _Global.document.body.removeChild(this._errorFlyout.element);
                        this._errorFlyout.dispose();
                    }
                    if (this._playbackRateFlyout) {
                        this._playbackRateFlyout.removeEventListener("beforeshow", this._handleFlyoutOpenCallbackBind);
                        this._playbackRateFlyout.removeEventListener("afterhide", this._handleFlyoutCloseCallbackBind);
                        _Global.document.body.removeChild(this._playbackRateFlyout);
                        this._playbackRateFlyout.dispose();
                    }
                    if (this._volumeFlyout) {
                        _Global.document.body.removeChild(this._volumeFlyout.element);
                        this._volumeFlyout.dispose();
                    }

                    // Clear timers
                    this._removeControlsTimer();
                    _Global.clearInterval(this._fastForwardOrRewindTimer);
                    _Global.clearInterval(this._updateMediaStateTimerCookie);
                    this._updateMediaStateTimerCookie = null;
                    this._unsubscribeFromTimeUpdates();

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        this._unsubscribeFromMediaEvents(this._mediaElementAdapter.mediaElement);
                    }
                    this._mediaEventSubscriptions = null;

                    this._removeButtonEventHandlers();
                    this._buttonEventSubscriptions = null;

                    this._removeGestureEventHandlers();
                    this._gestureEventSubscriptions = null;

                    // Remove text track event listeners
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {
                        var mediaElement = this._mediaElementAdapter.mediaElement;
                        var textTracks = mediaElement.textTracks;
                        if (textTracks) {
                            var tracks = mediaElement.getElementsByTagName("track");
                            var tracksLength = tracks.length;
                            for (var i = 0; i < tracksLength; i++) {
                                if (tracks[i].kind === "chapters") {
                                    tracks[i].removeEventListener("load", this._handleloadTextTrackCallbackBind);
                                }
                            }
                        }
                    }
                    this._handleFlyoutOpenCallbackBind = null;
                    this._handleFlyoutCloseCallbackBind = null;
                    this._handleloadTextTrackCallbackBind = null;
                    this._adjustedContentType = null;
                    this._audioTracksButton = null;
                    this._audioTracksFlyout = null;
                    this._busyIndicator = null;
                    this._castButton = null;
                    this._chapterSkipBackButton = null;
                    this._chapterSkipForwardButton = null;
                    this._checkParentalControlsBind = null;
                    this._checkParentalControlsAvailableBind = null;
                    this._closedCaptionsButton = null;
                    this._closedCaptionsFlyout = null;
                    this._contentRestrictions = null;
                    this._controlHideTimeout = null;
                    this._controls = null;
                    this._currentScrubbingVelocity = null;
                    this._currentTimeIndicator = null;
                    this._currentTimeVisualElements = null;
                    this._defaultChapterMarkers = [];
                    this._defaultChapterMarkers = null;
                    this._endTime = null;
                    this._errorFlyout = null;
                    this._errorText = null;
                    this._fastForwardButton = null;
                    this._fastForwardOrRewindTimer = null;
                    this._fastForwardOrRewindTimerElapsedTime = null;
                    this._gestureRecognizer = null;
                    this._goToLiveButton = null;
                    this._handleTransportBarButtonClick = null;
                    this._handleTransportBarButtonFocus = null;
                    this._handleTransportBarButtonKeyDown = null;
                    this._handleTransportBarButtonKeyUp = null;
                    this._inputHandlerElement = null;
                    this._inputHandlerClickCallback = null;
                    this._inputHandlerPointerDownCallback = null;
                    this._inputHandlerPointerMoveCallback = null;
                    this._inputHandlerPointerUpCallback = null;
                    this._lastControlsResetTimeStamp = null;
                    this._lastFastForwardOrRewindTimerTime = null;
                    this._lastControlsResetTimeStamp = null;
                    this._lastPointerPosition = null;
                    this._lastPosition = null;
                    this._markers = null;
                    this._mediaCommandFeedbackText = null;

                    if (this._mediaElementAdapter) {
                        this._mediaElementAdapter.dispose();
                    }

                    this._mediaElementAdapter = null;
                    this._mediaMetadata = null;
                    this._mediaPlayerContainer = null;
                    this._mediaPlayerHtml = null;
                    this._mediaState = null;
                    this._metadataTitle = null;
                    this._metadataDescription = null;
                    this._minimumSeekableRangeInPixels = null;
                    this._muteButton = null;
                    this._nextCustomMarkerIndex = null;
                    this._nextCustomMarkerTime = null;
                    this._previousCustomMarkerIndex = null;
                    this._previousCustomMarkerTime = null;
                    this._nextTrackButton = null;
                    this._playbackRateButton = null;
                    this._playbackRateFlyout = null;
                    this._playbackSpeedIndicator = null;
                    this._playPauseButton = null;
                    this._playFromBeginningButton = null;
                    this._previousPlaybackRate = null;
                    this._previousTrackButton = null;
                    this._previousVolumeValue = null;
                    this._progress = null;
                    this._progressContainer = null;
                    this._updateMediaStateBind = null;
                    this._relativeTimelineStartOffset = null;
                    this._rewindButton = null;
                    this._seekBar = null;
                    this._seekMark = null;
                    this._seekTimeIndicator = null;
                    this._seekWindowLeftEdgeElement = null;
                    this._seekWindowRightEdgeElement = null;
                    this._skipAnimations = false;
                    this._startTime = null;
                    this._startOffsetX = null;
                    this._stopButton = null;
                    this._smtControls = null;
                    this._targetCurrentTime = null;
                    this._targetPlaybackRate = null;
                    this._thumbnailImage = null;
                    this._thumbnailImageVisual = null;
                    this._thumbElement = null;
                    this._thumbElementWidthDividedByTwo = null;
                    this._timeFormatter = null;
                    this._thumbImageElementWidthDividedByTwo = null;
                    this._timeBeforeShowingBusyVisual = null;
                    this._timeRemainingIndicator = null;
                    this._timeSeparator = null;
                    this._timeSkipBackButton = null;
                    this._timeSkipForwardButton = null;
                    this._timeline = null;
                    this._toggleFullScreenButton = null;
                    this._totalSeekBarWidth = null;
                    this._totalTimeInternal = null;
                    this._transportControls = null;
                    this._updateAudioTracksButtonStateBind = null;
                    this._updateClosedCaptionsButtonStateBind = null;
                    this._volumeButton = null;
                    this._volumeFlyout = null;
                    this._volumeSlider = null;
                    this._volumeValue = null;
                    this._zoomButton = null;
                    this._originalParent = null;
                    this._nextSibiling = null;

                    // Constants
                    this._CHAPTER_SKIP_THRESHOLD = null;

                    this._FAST_FORWARD_OR_REWIND_TIMER_INTERVAL = null;
                    this._MINIMUM_ACCURATE_SEEKABLE_RANGE = null;
                    this._MINIMUM_POINTER_DELTA_TO_ENABLE_SNAPPING_TO_NEAREST_MARKER = null;
                    this._GESTURE_REGION_FOR_MOVING_THE_SEEKABLE_WINDOW = null;
                    this._REPORT_MEDIA_STATE_INTERVAL = null;
                    this._SNAP_TO_NEAREST_MARKER_THRESHOLD = null;

                    this._CONTROLS_AUTO_HIDE_DURATION = null;
                    this._MARKER_PROXIMITY_THRESHOLD = null;
                    // We won't add chapter markers for media under 1 minute
                    this._MINIMUM_MEDIA_LENGTH_FOR_DEFAULT_MARKERS = null;
                    this._MOUSE_LEFT_BUTTON = null;
                    this._MOUSE_POINTER_TYPE = null;
                    this._SEEK_OFFSET = null;
                    this._SKIP_BACK_INTERVAL = null;
                    this._SKIP_FORWARD_INTERVAL = null;

                    this._TAG_NAME_AUDIO = null;
                    this._TAG_NAME_VIDEO = null;

                    _Dispose.disposeSubTree(this._element);

                    this._element.tvControl = null;
                    this._element = null;
                },

                fastForward: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.fastForward">
                    /// <summary locid="TVJS.MediaPlayer.fastForward">
                    /// Increases the playback rate of the media.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        if (this._mediaElementAdapter.mediaElement.readyState < this._MediaReadyState.MediaReadyState_Have_FutureData) {
                            return;
                        }

                        // We show the controls, because we need to give visual feedback to the user regarding timeline
                        // movement event if the API is called programmatically.
                        if (!this._controlsVisible) {
                            this._showControls();
                        }

                        var newPlaybackRate = null;
                        if (!this._isInFastForwardOrRewindMode) {
                            this._targetPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                            this._targetCurrentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        }

                        var currentPlaybackRate = null;
                        if (this._simulatedFastForwardMode) {
                            currentPlaybackRate = this._targetPlaybackRate;
                        } else {
                            currentPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                        }

                        if (!this._isInFastForwardOrRewindMode &&
                            this._mediaElementAdapter.mediaElement.paused &&
                            currentPlaybackRate === this._PLAYBACKRATE_REWIND_2X) {
                            newPlaybackRate = this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE;
                        } else if (this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE) {
                            newPlaybackRate = this._PLAYBACKRATE_PLAYING;
                        } else if (!this._isInFastForwardOrRewindMode &&
                                   this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_PLAYING) {
                            newPlaybackRate = this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE;
                        } else if (this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE) {
                            newPlaybackRate = this._PLAYBACKRATE_FAST_FORWARD_2X;
                        } else if (currentPlaybackRate < this._PLAYBACKRATE_FAST_FORWARD_MAX_RATE &&
                                   currentPlaybackRate >= this._PLAYBACKRATE_FAST_FORWARD_2X) {
                            newPlaybackRate = Math.min(Math.floor(currentPlaybackRate) * 2, this._PLAYBACKRATE_FAST_FORWARD_MAX_RATE);
                        } else if (currentPlaybackRate < this._PLAYBACKRATE_FAST_FORWARD_2X &&
                                   currentPlaybackRate >= this._PLAYBACKRATE_PLAYING) {
                            newPlaybackRate = this._PLAYBACKRATE_FAST_FORWARD_2X;
                        } else if (currentPlaybackRate < this._PLAYBACKRATE_PLAYING &&
                                   currentPlaybackRate >= this._PLAYBACKRATE_REWIND_2X) {
                            newPlaybackRate = this._PLAYBACKRATE_PLAYING;
                        } else if (currentPlaybackRate < this._PLAYBACKRATE_REWIND_2X &&
                                   currentPlaybackRate >= this._PLAYBACKRATE_REWIND_MAX_RATE) {
                            newPlaybackRate = Math.max(Math.floor(currentPlaybackRate) / 2, this._PLAYBACKRATE_REWIND_MAX_RATE);
                        }

                        if (newPlaybackRate) {
                            if (this._simulatedFastForwardMode) {
                                if (this._isFastForwardOrRewind(newPlaybackRate)) {
                                    var oldPlaybackRate = currentPlaybackRate;
                                    this._targetPlaybackRate = newPlaybackRate;
                                    this._updateFastForwardAndRewindState(oldPlaybackRate, newPlaybackRate);
                                } else {
                                    this._exitFastForwardOrRewind(true);
                                }
                            } else {
                                if (this._mediaElementAdapter.mediaElement.paused &&
                                    newPlaybackRate !== this._PLAYBACKRATE_PLAYING) {
                                    this._mediaElementAdapter.play();
                                }

                                this._mediaElementAdapter.mediaElement.playbackRate = newPlaybackRate;
                            }
                        }

                        this._setFastForwardOrRewindText();
                    }
                },

                goToLive: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.goToLive">
                    /// <summary locid="TVJS.MediaPlayer.goToLive">
                    /// Navigates to the real-time position in live streamed media.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter) {

                        this._exitFastForwardOrRewind(true);

                        // We try to handle all time movements as seeks so there are fewer
                        // one code paths to have to worry about for ad skipping.
                        this._seekInternal(this._mediaElementAdapter.liveTime, false);

                        this._updateUIAndRaiseEvents(mediaCommandEnum.goToLive, strings.goToLiveMediaCommandDisplayText);
                    }
                },

                hideControls: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.hideControls">
                    /// <summary locid="TVJS.MediaPlayer.hideControls">
                    /// Hides all the UI associated with the MediaPlayer.
                    /// </summary>
                    /// </signature>

                    this._hideControls();
                },

                nextTrack: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.nextTrack">
                    /// <summary locid="TVJS.MediaPlayer.nextTrack">
                    /// Plays the next track.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.nextTrack) {

                        this._exitFastForwardOrRewind(true);

                        this._mediaElementAdapter.nextTrack();

                        this._updateUIAndRaiseEvents(mediaCommandEnum.nextTrack, strings.nextTrackMediaCommandDisplayText);
                    }
                },

                pause: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.pause">
                    /// <summary locid="TVJS.MediaPlayer.pause">
                    /// Pauses the media.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.pause) {
                        // if currently FF/RR mode then we should exit the mode with pause.
                        if (this._simulatedFastForwardMode &&
                            this._isFastForwardOrRewind(this.targetPlaybackRate)) {
                            this._exitFastForwardOrRewind(false);
                        } else {
                            this._mediaElementAdapter.pause();
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.pause, strings.pauseMediaCommandDisplayText);
                    }
                },

                play: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.play">
                    /// <summary locid="TVJS.MediaPlayer.play">
                    /// Sets the playbackRate to the default playbackRate for the media and plays the media.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.play) {

                        if (this._simulatedFastForwardMode &&
                            this._isInFastForwardOrRewindMode) {
                            this._exitFastForwardOrRewind(true);
                        } else if (this._mediaElementAdapter.mediaElement &&
                                   this._mediaElementAdapter.mediaElement.ended ||
                                   this._endTimeReached) {
                            this._playFromBeginning();
                        } else {
                            this._mediaElementAdapter.play();
                        }

                        this._updateUIAndRaiseEvents(mediaCommandEnum.play, strings.playMediaCommandDisplayText);
                    }
                },

                previousTrack: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.previousTrack">
                    /// <summary locid="TVJS.MediaPlayer.previousTrack">
                    /// Plays the previous track.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.previousTrack) {
                        this._mediaElementAdapter.previousTrack();

                        this._exitFastForwardOrRewind(true);

                        this._updateUIAndRaiseEvents(mediaCommandEnum.previousTrack, strings.previousTrackMediaCommandDisplayText);
                    }
                },

                removeMarker: function (time) {
                    /// <signature helpKeyword="TVJS.MediaPlayer.removeMarker">
                    /// <summary locid="TVJS.MediaPlayer.removeMarker">
                    /// Removes all chapter markers at the specified time.
                    /// </summary>
                    /// <param name="time" type="Object" locid="TVJS.MediaPlayer.removeMarker_p:time">
                    /// The time of the marker to remove.
                    /// </param>
                    /// </signature>
                    var markersLength = this._markers.length;
                    for (var i = 0; i < markersLength; i++) {
                        if (this._markers[i].time === time) {
                            this._markers.splice(i, 1);
                            break;
                        }
                    }

                    // We need to reset the markersLength because a marker may have been removed
                    // so the length of the array has changed.
                    markersLength = this._markers.length;

                    // If we removed any of the markers that correspond to _nextCustomMarkerTime or  _previousCustomMarkerTime
                    // then we need to reset _nextCustomMarkerTime and _previousCustomMarkerTime. Otherwise we could fire
                    // an event for a non-existent marker.
                    if (this._nextCustomMarkerTime === time) {
                        if (this._nextCustomMarkerIndex < markersLength &&
                                this._markers[this._nextCustomMarkerIndex]) {
                            this._nextCustomMarkerTime = this._markers[this._nextCustomMarkerIndex].time;
                        } else {
                            this._nextCustomMarkerIndex = -1;
                            this._nextCustomMarkerTime = -1;
                        }
                    }
                    if (this._previousCustomMarkerTime === time) {
                        if (this._previousCustomMarkerIndex > 0 &&
                            this._markers[this._previousCustomMarkerTime]) {
                            this._previousCustomMarkerIndex--;
                            this._previousCustomMarkerTime = this._markers[this._previousCustomMarkerTime].time;
                        } else {
                            this._previousCustomMarkerIndex = -1;
                            this._previousCustomMarkerTime = -1;
                        }
                    }

                    if (this._markers.length === 0) {
                        this._hasCustomMarkers = false;
                        this._unsubscribeFromTimeUpdates();
                    }

                    this._isChapterMarkerVisualsDirty = true;
                    this._onMarkerCollectionChanged();
                },

                rewind: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.rewind">
                    /// <summary locid="TVJS.MediaPlayer.rewind">
                    /// Decreases the playbackRate of the media.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        if (this._mediaElementAdapter.mediaElement.readyState < this._MediaReadyState.MediaReadyState_Have_FutureData) {
                            return;
                        }

                        // We show the controls, because we need to give visual feedback to the user regarding timeline
                        // movement event if the API is called programmatically.
                        if (!this._controlsVisible) {
                            this._showControls();
                        }

                        var newPlaybackRate = null;
                        if (!this._isInFastForwardOrRewindMode) {
                            this._targetPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                            this._targetCurrentTime = this._mediaElementAdapter.mediaElement.currentTime;
                        }

                        var currentPlaybackRate = this._PLAYBACKRATE_NOT_PLAYING;
                        if (this._simulatedFastForwardMode) {
                            currentPlaybackRate = this._targetPlaybackRate;
                        } else {
                            currentPlaybackRate = this._mediaElementAdapter.mediaElement.playbackRate;
                        }

                        // We have special behavior for pause. If the user is in the playing state and presses
                        // rewind, they will go into a slow motion state.
                        if (!this._isInFastForwardOrRewindMode &&
                            this._mediaElementAdapter.mediaElement.paused &&
                            currentPlaybackRate === this._PLAYBACKRATE_FAST_FORWARD_2X) {
                            newPlaybackRate = this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE;
                        } else if (this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_FAST_FORWARD_SLOW_MOTION_RATE) {
                            newPlaybackRate = this._PLAYBACKRATE_PLAYING;
                        } else if (!this._isInFastForwardOrRewindMode &&
                                   this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_PLAYING) {
                            newPlaybackRate = this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE;
                        } else if (this._mediaElementAdapter.mediaElement.paused &&
                                   currentPlaybackRate === this._PLAYBACKRATE_REWIND_SLOW_MOTION_RATE) {
                            newPlaybackRate = this._PLAYBACKRATE_REWIND_2X;
                        } else if (currentPlaybackRate > this._PLAYBACKRATE_REWIND_MAX_RATE &&
                                   currentPlaybackRate <= this._PLAYBACKRATE_REWIND_2X) {
                            newPlaybackRate = Math.max(Math.floor(currentPlaybackRate) * 2, this._PLAYBACKRATE_REWIND_MAX_RATE);
                        } else if (currentPlaybackRate > this._PLAYBACKRATE_REWIND_2X &&
                                   currentPlaybackRate <= this._PLAYBACKRATE_PLAYING) {
                            newPlaybackRate = this._PLAYBACKRATE_REWIND_2X;
                        } else if (currentPlaybackRate > this._PLAYBACKRATE_PLAYING &&
                                   currentPlaybackRate <= this._PLAYBACKRATE_FAST_FORWARD_2X) {
                            newPlaybackRate = this._PLAYBACKRATE_PLAYING;
                        } else if (currentPlaybackRate > this._PLAYBACKRATE_FAST_FORWARD_2X &&
                                   currentPlaybackRate <= this._PLAYBACKRATE_FAST_FORWARD_MAX_RATE) {
                            newPlaybackRate = Math.min(Math.floor(currentPlaybackRate) / 2, this._PLAYBACKRATE_FAST_FORWARD_2X);
                        }

                        if (newPlaybackRate) {
                            if (this._simulatedFastForwardMode) {
                                if (this._isFastForwardOrRewind(newPlaybackRate)) {
                                    var oldPlaybackRate = currentPlaybackRate;
                                    this._targetPlaybackRate = newPlaybackRate;
                                    this._updateFastForwardAndRewindState(oldPlaybackRate, newPlaybackRate);
                                } else {
                                    this._exitFastForwardOrRewind(true);
                                }
                            } else {
                                if (this._mediaElementAdapter.mediaElement.paused &&
                                    newPlaybackRate !== this._PLAYBACKRATE_PLAYING) {
                                    this._mediaElementAdapter.play();
                                }

                                this._mediaElementAdapter.mediaElement.playbackRate = newPlaybackRate;
                            }
                        }

                        this._setFastForwardOrRewindText();
                    }
                },

                seek: function (time) {
                    /// <signature helpKeyword="TVJS.MediaPlayer.seek">
                    /// <summary locid="TVJS.MediaPlayer.seek">
                    /// Navigates to the specified position in the media.
                    /// </summary>
                    /// <param name="time" type="Number" locid="TVJS.MediaPlayer.seek_p:time">
                    /// The position in seconds to seek to.
                    /// </param>
                    /// </signature>
                    this._seekInternal(time, true);
                },

                setContentMetadata: function (metadata) {
                    /// <signature helpKeyword="TVJS.MediaPlayer.setContentMetadata">
                    /// <summary locid="TVJS.MediaPlayer.setContentMetadata">
                    /// Sets the metadata fields for the given peice of media. This method should be called before changing the video stream.
                    /// </summary>
                    /// <param name="metadata" type="Object" locid="TVJS.MediaPlayer.setContentMetadata:metadata">
                    /// A collection of name value pairs that provide additional information about the current media.
                    /// </param>
                    /// <returns type="TVJS.Promise" locid="TVJS.MediaPlayer.setContentMetadata_returnValue"> 
                    /// A promise which is successfully update the Content Metadata.The completion value indicates
                    /// content allowed to view based on family safety policy. Otherwise promise returns an error.
                    /// </returns>
                    /// </signature>
                    if (!metadata) {
                        throw new _ErrorFromName("TVJS.MediaPlayer.nullMetadata", strings.mediaPlayerNullMetadata);
                    }

                    // Set the title & description in the UI
                    this._mediaMetadata = metadata;
                    this._metadataTitle.textContent = this._mediaMetadata.title || "";
                    this._metadataDescription.textContent = this._mediaMetadata.description || "";

                    if (this._smtControls) {
                        var updater = this._smtControls.displayUpdater;
                        if (this._mediaElementAdapter.mediaElement &&
                            this._mediaElementAdapter.mediaElement.tagName === this._TAG_NAME_AUDIO) {
                            updater.type = _WinRT.Windows.Media.MediaPlaybackType.audio;
                        } else {
                            updater.type = _WinRT.Windows.Media.MediaPlaybackType.video;
                        }
                        updater.appMediaId = this._mediaMetadata.contentId;

                        // Set video properties
                        if (updater.type === _WinRT.Windows.Media.MediaPlaybackType.video) {
                            updater.videoProperties.title = this._mediaMetadata.title;
                        }

                        updater.update();
                    }

                    var that = this;
                    var isAllowedToViewContentBasedOnFamilySafetyPolicy = false;

                    return new Promise(function (complete, error, progress) {

                        var checkParentalControlsPromise = that._checkParentalControls()
                            .then(
                                function afterContentRatingCheckReturns(result) {
                                    if (result) {
                                        isAllowedToViewContentBasedOnFamilySafetyPolicy = true;
                                    } else {
                                        isAllowedToViewContentBasedOnFamilySafetyPolicy = false;
                                    }
                                });

                        Promise.join(checkParentalControlsPromise)
                            .then(
                                function success() {
                                    if (isAllowedToViewContentBasedOnFamilySafetyPolicy) {
                                        complete();
                                    } else {
                                        error();
                                    }
                                },
                                function errorHandler() {
                                    error();
                                });
                    });
                },

                showControls: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.showControls">
                    /// <summary locid="TVJS.MediaPlayer.showControls">
                    /// Displays the UI associated with the MediaPlayer.
                    /// </summary>
                    /// </signature>

                    this._showControls(false);
                },

                stop: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.stop">
                    /// <summary locid="TVJS.MediaPlayer.stop">
                    /// Stops the media.
                    /// </summary>
                    /// </signature>

                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.stop) {
                        this._mediaElementAdapter.stop();
                        this._updateUIAndRaiseEvents(mediaCommandEnum.stop, strings.stopMediaCommandDisplayText);
                    }
                },

                timeSkipBack: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.timeSkipBack">
                    /// <summary locid="TVJS.MediaPlayer.timeSkipBack">
                    /// Moves the current timeline position backward by a short interval.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: Unlike the other media commands, which simply pass the command through to the MediaElementAdapter,
                        // the timeSkipBack command's logic is handled at the MediaPlayer layer, to ensure the interval of time
                        // to skip back is the same no matter what MediaElementAdapter is used.
                        var newTime = this._mediaElementAdapter.mediaElement.currentTime - this._SKIP_BACK_INTERVAL;

                        if (newTime < this._startTime) {
                            newTime = this._startTime;
                        }

                        this._seekInternal(newTime, false);

                        this._updateUIAndRaiseEvents(mediaCommandEnum.timeSkipBack, strings.timeSkipBackMediaCommandDisplayText);
                    }
                },

                timeSkipForward: function () {
                    /// <signature helpKeyword="TVJS.MediaPlayer.timeSkipForward">
                    /// <summary locid="TVJS.MediaPlayer.timeSkipForward">
                    /// Moves the current timeline position forward by a short interval.
                    /// </summary>
                    /// </signature>
                    if (this._mediaElementAdapter &&
                        this._mediaElementAdapter.mediaElement) {

                        this._exitFastForwardOrRewind(true);

                        // Note: Unlike the other media commands, which simply pass the command through to the MediaElementAdapter,
                        // the timeSkipForward command's logic is handled at the MediaPlayer layer, to ensure the interval of time
                        // to skip forward is the same no matter what MediaElementAdapter is used.
                        var newTime = this._mediaElementAdapter.mediaElement.currentTime + this._SKIP_FORWARD_INTERVAL;

                        if (newTime > this._endTime) {
                            newTime = this._endTime;
                        }

                        this._seekInternal(newTime, false);

                        this._updateUIAndRaiseEvents(mediaCommandEnum.timeSkipForward, strings.timeSkipForwardMediaCommandDisplayText);
                    }
                },
                _MediaReadyState: {
                    MediaReadyState_Have_Nothing: 0,
                    MediaReadyState_Have_Metadata: 1,
                    MediaReadyState_Have_CurrentData: 2,
                    MediaReadyState_Have_FutureData: 3,
                    MediaReadyState_Have_EnoughData: 4
                }
            },
                {
                    // keep it for Xbox Legacy..
                    _sounds: {
                        initialized: false,
                        elementFocus1: null,
                        elementFocus2: null,
                        elementFocus3: null,
                        elementFocus4: null,
                        selectButtonClick: null,
                        overlayIn: null,
                        overlayOut: null,
                    },
                });
            _Base.Class.mix(MediaPlayer, _Events.createEventProperties(
               "beforeshowcontrols",
               "aftershowcontrols",
               "beforehidecontrols",
               "afterhidecontrols",
               "markerreached",
               "mediacommandexecuted",
               "targetratechange",
               "targettimeupdate",
               "thumbnailrequest"));
            _Base.Class.mix(MediaPlayer, _Control.DOMEventMixin);
            return MediaPlayer;
        })
    });
});
// Copyright (c) Microsoft Corporation.  All Rights Reserved. Licensed under the MIT License. See License.txt in the project root for license information.
define('mediaplayerJs',[
    'TVJS/Controls/MediaPlayer'
    // Put references to styles in src/mediaPlayerCss.js
], function () {
});


        require(['mediaplayerJs'], function () {
        });
    }));
}());

